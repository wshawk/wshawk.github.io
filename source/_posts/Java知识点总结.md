---
title: Java知识点总结
date: 2020-04-08 15:20:34
tags: java
---

##  Java知识点总结

### 1.  类的初始化顺序 

1. 父类静态变量（静态代码块）
2. 子类静态变量（静态代码块）
3. 父类成员变量
4. 父类构造方法
5. 子类成员变量
6. 子类构造方法

### 2. final修饰符

* 修饰变量， 必须显示地赋初值，且赋初值后不能再赋值

  > 被final修饰的实例变量必须显示地赋初值，且只能以下三种方式：
  >
  > 　　1.  定义时初始化
  >
  > 　　2.  在非静态初始化块中为final实例变量指定初始值
  >
  > 　　3.  在构造器中指定初始值
  >
  > final修饰的静态变量只能在两个地方进行初始化
  >
  >    1. 定义final类变量时指定初始值 
  >    2. 在静态初始化块中为final类变量指定初始值 

* 修饰方法，该方法不能被重写

* 修饰类，该类不能被继承   

### 3.  static修饰符

- 修饰变量，被`static`修饰的变量实质上就是全局变量，**所有的类实例（对象），共享该变量**；且该变量可以以`类名.变量名`的方式进行访问

- 修饰方法，该方法被称为静态方法，可直接使用`类名.静态方法名`进行调用，不需要实例化对象。

  > 静态方法有以下特点：
  >
  > - 只能访问`static`变量
  > - 只能调用其他`static`方法
  > - 不能使用`this`或者`super`关键字，因为这两个关键字都是需要绑定对象

- `static`一般不能修饰类，只能修饰**内部类**

- `import static com.*.ClassName.*`，静态导入所需要的静态变量，从`jdk5`开始。

### 4. private修饰构造方法

- `private`修饰的构造方法只能在本类里调用

### 5. 重写和重载

- 重写（覆写）：方法名相同，接收参数相同，返回结果相同，处理逻辑不同，发生在子类和父类之间。
- 重载（覆载）：方法名相同，接收参数不同，返回结果可以不同，发生在一个类中。

### 6. 反射

- ` java`反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为`java`语言的反射机制。

### 7.  反射的应用场景

​		平时的业务开发中，很少用到反射，但是**反射是框架设计的灵魂 **，很多框架都用到了反射。

举例如下：

-  我们在使用`JDBC`连接数据库时使用`Class.forName()`通过反射加载数据库的驱动程序； 

-  动态代理；

-  Spring框架也用到很多反射机制，最经典的就是`xml`的配置模式；

  > Spring 通过 `xml`配置模式装载 Bean 的过程：
  >
  > - 将程序内所有 `xml`或 `properties`配置文件加载入内存中;  
  > - Java类里面解析`xml`或`properties`里面的内容，得到对应实体类的字节码字符串以及相关的属性信息;  
  > - 使用反射机制，根据这个字符串获得某个类的Class实例; 
  > - 动态配置实例的属性。 

### 8.`short`、`int`类型提升

```java
short a = 1;
a = a + 1; 
/* 编译报错（原因：使用 + 运算符，会使得short类型自动提升为int类型，int类型的值范围大于short），所以可能
 * 会出现超出范围的报错，故编译不通过
 */
a += 1; //编译通过，java中对 += 做了特殊处理
```

###  9. `String`不变性

- String类是被final进行修饰的，不能被继承；
- 使用`+`运算符连接两个字符串时，会创建一个新的字符串；`+`运算符底层采用了`StringBuilder`实例的`append()`方法实现；
- `String s = new String("hello world");`可能创建两个对象，也可能创建一个对象。如果在静态区中有`"hello world"`字符串常量对象的话，则仅仅在堆中创建一个对象。如果在静态区中没有`"hello world"`对象，则在堆和静态区中都需要创建对象；

### 10.  为什么重写`equals()`方法时，一定要重写`hashCode()`方法

- 因为关于`hashCode()`方法，一致约定是 

  > 1. **如果两个对象通过`equals`调用后返回是`true`，那么这个两个对象的`hashCode`方法也必须返回同样的int型散列码;**
  > 2. **如果两个对象通过equals返回false，他们的hashCode返回的值<font color="red">允许相同</font>**。(然而，程序员必须意识到，`hashCode`返回独一无二的散列码，会让存储这个对象的`hashTables`更好地工作。)

