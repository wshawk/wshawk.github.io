<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MySQL之InnoDB Buffer Pool</title>
      <link href="/post/b70a251f.html"/>
      <url>/post/b70a251f.html</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL之InnoDB-Buffer-Pool"><a href="#MySQL之InnoDB-Buffer-Pool" class="headerlink" title="MySQL之InnoDB Buffer Pool"></a>MySQL之InnoDB Buffer Pool</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在<code>MySQL</code> 服务器启动的时候向操作系统申请了<strong>一片连续的内存</strong>，这块内存就叫做 <code>Buffer Pool </code>。</p><p>默认情况下 <code>Buffer Pool</code> 只有 <code>128M</code> 大小。</p><p>可以在启动服务器的时候配置 <code>innodb_buffer_pool_size</code> 参数的值，来设置<code>Buffer Pool</code>的大小，单位是<strong>字节。</strong>需要注意的是， <code>Buffer Pool</code> 也不能太小，最小值为 <code>5M</code> (当小于该值时会自动设置成 <code>5M </code>)。</p><p>本文内容均来自《MySQL是怎样运行的：从根儿上理解MySQL》</p><h2 id="内部组成"><a href="#内部组成" class="headerlink" title="内部组成"></a>内部组成</h2><p><code>Buffer Pool </code>中默认的缓存页大小和在磁盘上默认的页大小是一样的，都是 <code>16KB</code> 。</p><p>为了更好的管理这些在 <code>Buffer Pool</code> 中的缓存页，衍生了控制信息，主要包括该页所属的表空间编号、页号、缓存页在 <code>Buffer Pool</code> 中的地址、链表节点信息、一些锁信息以及 <code>LSN</code> 信息。</p><p>每个页对应的控制信息占用的一块内存可以称为一个<strong>控制块</strong>，控制块和缓存页是一 一对应的。</p><p>每个缓存页的控制信息的长度是固定大小的，在<code>MySQL5.7.21</code>这个版本中，每个控制块占用的大小是<code>808</code>字节。</p><p>设置的<code>innodb_buffer_pool_size</code>并不包含这部分控制块占用的内存空间大小，也就是说<strong>实际上<code>Buffer Pool</code>的大小是超过预设的值的</strong>，一般是超过<code>5%</code>左右。</p><h2 id="free链表"><a href="#free链表" class="headerlink" title="free链表"></a>free链表</h2><p><code>free</code>链表负责记录<code>Buffer Pool</code>中，每一个节点都代表一个空闲的缓存页，在将磁盘中的页加载到 <code>Buffer Pool </code>时，会从 <code>free</code>链表中寻找空闲的缓存页。</p><p><strong>这里的链表都会有一个基节点，记录着链表中的节点数量，头节点的指针，尾节点的指针等信息。</strong>链表的基节点占用的内存空间并不包含在为 <code>Buffer Pool</code> 申请的一大片连续内存空间之内，而是单独申请的一块内存空间。</p><p>每当需要从磁盘中加载一个页到<code>Buffer Pool</code> 中时，就从 free链表 中 取一个空闲的缓存页，并且把该缓存页对应的 控制块 的信息填上（就是该页所在的表空间、页号之类的信 息），然后把该缓存页对应的<code> free</code>链表 节点从链表中移除，表示该缓存页已经被使用了。</p><h2 id="缓存页的哈希处理"><a href="#缓存页的哈希处理" class="headerlink" title="缓存页的哈希处理"></a>缓存页的哈希处理</h2><blockquote><p>如何判断数据页有没有被缓存到<code>Buffer Pool</code>?</p></blockquote><p>以用 <strong>表空间号 + 页号</strong> 作为 <code>key</code> ， <strong>缓存页</strong> 作为 <code>value</code> 创建一个哈希表，在需要访问某个页的数据 时，先从哈希表中根据 表空间号 + 页号 看看有没有对应的缓存页，如果有，直接使用该缓存页就好，如果没 有，那就从 free链表 中选一个空闲的缓存页，然后把磁盘中对应的页加载到该缓存页的位置。</p><h2 id="flush链表"><a href="#flush链表" class="headerlink" title="flush链表"></a>flush链表</h2><p>修改了 <code>Buffer Pool</code>中某个缓存页的数据，那它就和磁盘上的页不一致了，这样的缓存页也被称为 <strong>脏 页</strong>。</p><p>修改过的缓存页对应的控制块都会作为一个节点加入到一个链表中，因为这个<strong>链表节点对应的缓存页都是需要被刷新到磁盘上的</strong>， 所以也叫 <code>flush</code>链表 。</p><h2 id="lru链表"><a href="#lru链表" class="headerlink" title="lru链表"></a>lru链表</h2><p>当需要缓存的页占用的内存大小超过了 <code>Buffer Pool</code> 大小，也就 是<code> free</code>链表 中已经没有多余的空闲缓存页的时候，就需要把某些旧的 缓存页从 <code>Buffer Pool</code> 中移除，然后再把新的页放进来。</p><p>可以再创建一个链表，由于这个链表是为了按照<strong>最近最少使用的原则</strong>去淘汰缓存页 的，所以这个链表可以被称为 <code>lru</code>链表 （英文全称：Least Recently Used）。</p><h3 id="简单的lru链表"><a href="#简单的lru链表" class="headerlink" title="简单的lru链表"></a>简单的lru链表</h3><p>简单的<code>lru</code>链表逻辑如下：</p><ul><li><p>如果该页不在 <code>Buffer Pool</code> 中，在把该页从磁盘加载到 <code>Buffer Pool </code>中的缓存页时，就把该缓存页对应的 控制块 作为节点塞到链表的头部。</p></li><li><p>如果该页已经缓存在 <code>Buffer Pool</code> 中，则直接把该页对应的 控制块 移动到 <code>lru</code>链表 的头部。</p></li></ul><h3 id="划分区域的lru链表"><a href="#划分区域的lru链表" class="headerlink" title="划分区域的lru链表"></a>划分区域的lru链表</h3><p><code>InnoDB</code> 提供了<strong>预读</strong>服务 ，就是 <code>InnoDB</code> 认为执行当前的请求可能之后会读取某些页面，就预先把它们加载到 <code>Buffer Pool</code> 中。</p><p>预读本来是个好事儿，如果预读到 <code>Buffer Pool</code> 中的页成功的被使用到，那就可以极大的提高语句执 行的效率。可是如果用不到呢？这些预读的页都会放到 <code>lru</code> 链表的头部，但是如果此时 <code>Buffer Pool</code> 的 容量不太大而且很多预读的页面都没有用到的话，这就会导致处在 <code>lru</code> 链表 尾部的一些缓存页会很快的 被淘汰掉，也就是所谓的 劣币驱逐良币 ，会<strong>大大降低缓存命中率</strong>。</p><p>全表扫描，当遇到全表扫描时，会访问表中所有的数据页，会将所有数据页加载到 <code>Buffer Pool </code>中。</p><p>总结：</p><ul><li><p>加载到 <code>Buffer Pool</code> 中的页不一定被用到。 </p></li><li><p>如果非常多的使用频率偏低的页被同时加载到 <code>Buffer Pool</code> 时，可能会把那些使用频率非常高的页从 <code>Buffer Pool</code> 中淘汰掉。</p></li></ul><p><strong>为了提高缓存的命中率，<code>InnoDB</code>将<code>lru</code> 链表按照一定比例分成两截。</strong></p><ul><li><p>一部分存储使用频率非常高的缓存页，所以这一部分链表也叫做 热数据 ，或者称 <code>young</code>区域 。</p></li><li><p> 另一部分存储使用频率不是很高的缓存页，所以这一部分链表也叫做 冷数据 ，或者称 <code>old</code>区域 。</p></li></ul><p>可以查看系统变量 <code>innodb_old_blocks_pct</code> 的值来确定**<code> old</code> 区域 在<code>lru</code>链表 中所占的比例**。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;innodb_old_blocks_pct&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li>启动时修改<code>innodb_old_blocks_pct</code>参数</li><li>运行时修改<code>SET GLOBAL innodb_old_blocks_pct = xx</code>;</li></ul><blockquote><p>ps：这个系统变量属于全局变量 ，一经修改，会对所有客户端生效</p></blockquote><p>优化后：</p><p>当磁盘上的某个页面在初次加载到<code>Buffer Pool</code>中的某个缓存页时，该缓存页对应 的控制块会被放到<code>old</code>区域的头部。</p><p>在对某个处在 <code>old </code>区域的缓存页进行第一次访问时就在它对应的控制块中 记录下来这个访问时间，如果后续的访问时间与第一次访问的时间在某个时间间隔内，那么该页面就不会被 从<code>old</code>区域移动到<code>young</code>区域的头部，否则将它移动到<code>young</code>区域的头部。</p><p>间隔时间是由系统变量 <code>innodb_old_blocks_time </code>控制，默认值是 <code>1000 </code>，单位是<code>毫秒</code>。</p><p>查看：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;innodb_old_blocks_time&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="更进一步优化"><a href="#更进一步优化" class="headerlink" title="更进一步优化"></a>更进一步优化</h3><p>对于 <code>young</code> 区域的缓存页来说，我们每次访问一个缓存页就要把它移动到 <code>lru</code>链表 的头部，开销也比较大。</p><p>在<code>young</code> 区域的缓存页都是热点数据，也就是可能被经常访 问的，这样频繁的对  <code>lru</code>链表进行节点移动操作也不太好。</p><p>优化策略如下：</p><p>只有被访问的缓存页位于 <code>young</code> 区域的 <code>1/4</code> 的后边，才会被移动到 <code>lru</code>链表 头部，这样就 可以降低调整  <code>lru</code>链表 的频率，从而提升性能（也就是说如果某个缓存页对应的节点在 <code>young</code> 区域的前<code>1/4</code> 中， 再次访问该缓存页时也不会将其移动到 <code>lru</code>链表头部）</p><p>优化的最终目标：<strong>尽量高效的提高 Buffer Pool 的缓存命中率</strong>。</p><h2 id="其他的一些链表"><a href="#其他的一些链表" class="headerlink" title="其他的一些链表"></a>其他的一些链表</h2><ul><li><code>unzip lru</code>链表： 用于管理解压页，</li><li><code>zip clean</code>链表：用于管理没有被解压的压缩页</li><li>…</li></ul><h2 id="刷新脏页到磁盘"><a href="#刷新脏页到磁盘" class="headerlink" title="刷新脏页到磁盘"></a>刷新脏页到磁盘</h2><p>后台有专门的线程每隔一段时间负责把脏页刷新到磁盘，这样可以不影响用户线程处理正常的请求。</p><p>主要有两种 刷新路径： </p><ul><li>从  <code>lru</code>链表 的冷数据中刷新一部分页面到磁盘。 后台线程会定时从 <code>lru</code>链表 尾部开始扫描一些页面，扫描的页面数量可以通过系统变量 <code>innodb_lru_scan_depth</code> 来指定，如果从里边儿发现脏页，会把它们刷新到磁盘。这种刷新页面的方式被称之为 <code>BUF_FLUSH_LRU </code>。 </li><li>从 <code>flush</code>链表 中刷新一部分页面到磁盘。 后台线程也会定时从 flush链表 中刷新一部分页面到磁盘，刷新的速率取决于当时系统是不是很繁忙。这种 刷新页面的方式被称之为 <code>BUF_FLUSH_LIST</code> 。 </li></ul><p>有时候后台线程刷新脏页的进度比较慢，导致用户线程在准备加载一个磁盘页到 <code>Buffer Pool</code> 时没有可用的缓存 页，这时就会尝试看看 <code>lru</code>链表 尾部有没有可以直接释放掉的未修改页面，如果没有的话会不得不将 <code>lru</code>链表尾部的一个脏页同步刷新到磁盘（和磁盘交互是很慢的，这会降低处理用户请求的速度）。</p><p>这种刷新单个页面到磁 盘中的刷新方式被称之为 <code>BUF_FLUSH_SINGLE_PAGE </code>。 当然，有时候系统特别繁忙时，也可能出现用户线程批量的从 <code>flush</code>链表中刷新脏页的情况，很显然在处理用户请求过程中去刷新脏页是一种严重降低处理速度的行为（毕竟磁盘的速度满的要死），这属于一种迫不得已的情 况，不过这得放在后边唠叨 <code>redo</code> 日志的 <code>checkpoint</code> 时说了。</p><h2 id="多个Buffer-Pool实例"><a href="#多个Buffer-Pool实例" class="headerlink" title="多个Buffer Pool实例"></a>多个Buffer Pool实例</h2><p> <code>Buffer Pool</code> 本质是 <code>InnoDB</code> 向操作系统申请的一块连续的内存空间，在多线程环境下，访问 <code>Buffer Pool</code> 中的各种链表都需要加锁处理啥的，在 <code>Buffer Pool </code>特别大而且多线程并发访问特别高的情况下， 单一的 <code>Buffer Pool</code> 可能会影响请求的处理速度。所以在 <code>Buffer Pool</code> 特别大的时候，我们可以把它们拆分成若 干个小的 <code>Buffer Pool </code>，每个 <code>Buffer Pool </code>都称为一个 实例 ，它们都是独立的，在多线程并发访问时不会互相影响，从而提高并发能力。</p><p>可以在服务器启动的时候通过设置 <code>innodb_buffer_pool_instances</code> 的值来修改 <code>Buffer Pool</code> 实例的个数。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_buffer_pool_instances <span class="operator">=</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p> <code>Buffer Pool</code> 实例并不是创建的越多越好，分别管理各个 <code>Buffer Pool</code> 也是需要性能开销的，<code>InnoDB</code>规定：<strong>当<code>innodb_buffer_pool_size</code>的值小于<code>1G</code>的时候设置多个实例是无效的，<code>InnoDB</code>会默认把 <code>innodb_buffer_pool_instances</code> 的值修改为<code>1</code>。</strong></p><h2 id="innodb-buffer-pool-chunk-size"><a href="#innodb-buffer-pool-chunk-size" class="headerlink" title="innodb_buffer_pool_chunk_size"></a>innodb_buffer_pool_chunk_size</h2><p>在 <code>MySQL 5.7.5</code> 之前， <code>Buffer Pool </code>的大小只能在服务器启动时通过配置<code>innodb_buffer_pool_size</code>启动参数 来调整大小，在服务器运行过程中是不允许调整该值的。</p><p>在 <code>5.7.5 </code>以及之后的版本中支持 了在服务器运行过程中调整 <code>Buffer Pool </code>大小的功能，但是有一个问题，就是每次当我们要重新调整 <code>Buffer Pool</code> 大小时，都需要重新向操作系统申请一块连续的内存空间，然后将旧的 <code>Buffer Pool</code> 中的内容复制到这一 块新空间，这是极其耗时的。</p><p>后面的<code>MySQL</code>就不再一次性为某个 <code>Buffer Pool </code>实例向操作系统申请 一大片连续的内存空间，而是以一个所谓的 <code>chunk </code>为单位向操作系统申请空间。</p><p>也就是说一个 <code>Buffer Pool </code>实例 其实是由若干个 <code>chunk </code>组成的，一个 <code>chunk</code> 就代表一片连续的内存空间，里边儿包含了若干缓存页与其对应的控制块。</p><p><code>chunk</code> 的大小是我们在启动操作 <code>MySQL</code> 服务器时通过 <code>innodb_buffer_pool_chunk_size</code> 启动参数指定的，它的默认值是 <code>134217728</code> ，也就是 <code>128M</code> 。不过需要注意的是，**<code>innodb_buffer_pool_chunk_size</code>的值只能在服务器启动时指 定，在服务器运行过程中是不可以修改的。**</p><p><code>innodb_buffer_pool_chunk_size</code>的值并不包含缓存页对应的控制块的内存空间大小，所以实际上<code>InnoDB</code>向操作系统申请连续内存空间时，每个<code>chunk</code>的大小要比<code>innodb_buffer_pool_chunk_size </code>的值大一些，约<code>5%</code>。</p><h2 id="配置Buffer-Pool时的注意事项"><a href="#配置Buffer-Pool时的注意事项" class="headerlink" title="配置Buffer Pool时的注意事项"></a>配置Buffer Pool时的注意事项</h2><ul><li><code>innodb_buffer_pool_size</code> 必须是 <code>innodb_buffer_pool_chunk_size</code> * <code>innodb_buffer_pool_instances</code> 的倍数（这主要是想保证每一个 <code>Buffer Pool</code> 实例中包含的 <code>chunk</code>数量相同）。</li></ul><p><code>innodb_buffer_pool_size</code> 的值必须是 <code>2G</code> 或者 <code>2G</code> 的整数倍，如果指定的 <code>innodb_buffer_pool_size </code>大于 <code>2G </code>并且不是 <code>2G</code> 的整数倍，那么服务器会自动的把 <code>innodb_buffer_pool_size</code>的值调整为<code> 2G</code> 的整数倍。</p><ul><li>如果在服务器启动时，<code>innodb_buffer_pool_chunk_size</code> * <code>innodb_buffer_pool_instances</code> 的值已经大 于 <code>innodb_buffer_pool_size</code> 的值，那么 <code>innodb_buffer_pool_chunk_size</code> 的值会被服务器自动设置为<code> innodb_buffer_pool_size</code> / <code>innodb_buffer_pool_instances</code> 的值。</li></ul><h2 id="查看Buffer-Pool的状态信息"><a href="#查看Buffer-Pool的状态信息" class="headerlink" title="查看Buffer Pool的状态信息"></a>查看Buffer Pool的状态信息</h2><p>通过以下命令，可以查看关于 <code>InnoDB</code> 存储引擎运行过程 中的一些状态信息，其中就包括 <code>Buffer Pool </code>的一些信息。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">SHOW</span> ENGINE INNODB STATUS;</span><br><span class="line"> </span><br><span class="line"> (...省略前边的许多状态)</span><br><span class="line"><span class="comment">----------------------</span></span><br><span class="line">BUFFER POOL <span class="keyword">AND</span> MEMORY</span><br><span class="line"><span class="comment">----------------------</span></span><br><span class="line">Total memory allocated <span class="number">13218349056</span>;</span><br><span class="line">Dictionary memory allocated <span class="number">4014231</span></span><br><span class="line">Buffer pool size <span class="number">786432</span></span><br><span class="line"><span class="keyword">Free</span> buffers <span class="number">8174</span></span><br><span class="line">Database pages <span class="number">710576</span></span><br><span class="line"><span class="keyword">Old</span> database pages <span class="number">262143</span></span><br><span class="line">Modified db pages <span class="number">124941</span></span><br><span class="line">Pending <span class="keyword">reads</span> <span class="number">0</span></span><br><span class="line">Pending writes: LRU <span class="number">0</span>, flush list <span class="number">0</span>, single page <span class="number">0</span></span><br><span class="line">Pages made young <span class="number">6195930012</span>, <span class="keyword">not</span> young <span class="number">78247510485</span></span><br><span class="line"><span class="number">108.18</span> youngs<span class="operator">/</span>s, <span class="number">226.15</span> non<span class="operator">-</span>youngs<span class="operator">/</span>s</span><br><span class="line">Pages read <span class="number">2748866728</span>, created <span class="number">29217873</span>, written <span class="number">4845680877</span></span><br><span class="line"><span class="number">160.77</span> <span class="keyword">reads</span><span class="operator">/</span>s, <span class="number">3.80</span> creates<span class="operator">/</span>s, <span class="number">190.16</span> writes<span class="operator">/</span>s</span><br><span class="line">Buffer pool hit rate <span class="number">956</span> <span class="operator">/</span> <span class="number">1000</span>, young<span class="operator">-</span>making rate <span class="number">30</span> <span class="operator">/</span> <span class="number">1000</span> <span class="keyword">not</span> <span class="number">605</span> <span class="operator">/</span> <span class="number">1000</span></span><br><span class="line">Pages read ahead <span class="number">0.00</span><span class="operator">/</span>s, evicted <span class="keyword">without</span> access <span class="number">0.00</span><span class="operator">/</span>s, Random read ahead <span class="number">0.00</span><span class="operator">/</span>s</span><br><span class="line">LRU len: <span class="number">710576</span>, unzip_LRU len: <span class="number">118</span></span><br><span class="line">I<span class="operator">/</span>O sum[<span class="number">134264</span>]:cur[<span class="number">144</span>], unzip sum[<span class="number">16</span>]:cur[<span class="number">0</span>]</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">(...省略后边的许多状态)</span><br></pre></td></tr></table></figure><p><code>Total memory allocated</code> ：代表 <code>Buffer Pool</code> 向操作系统申请的连续内存空间大小，包括全部控制块、缓 存页、以及碎片的大小。 </p><p><code>Dictionary memory allocated</code> ：为数据字典信息分配的内存空间大小，注意这个内存空间和 Buffer Pool 没啥关系，不包括在 <code>Total memory allocated</code> 中。 </p><p><code>Buffer pool size</code> ：代表该 <code>Buffer Pool</code> 可以容纳多少缓存 页 ，注意，<strong>单位是页</strong> ！ </p><p><code>Free buffers</code> ：代表当前 <code>Buffer Pool </code>还有多少空闲缓存页，也就是 <code>free</code>链表 中还有多少个节点。 </p><p><code>Database pages</code> ：代表 <code>LRU </code>链表中的页的数量，包含 <code>young</code> 和 <code>old</code> 两个区域的节点数量。 </p><p><code>Old database pages</code> ：代表<code> LRU</code> 链表 <code>old</code> 区域的节点数量。 </p><p><code>Modified db pages</code> ：代表脏页数量，也就是 <code>flush</code>链表 中节点的数量。 </p><p><code>Pending reads </code>：正在等待从磁盘上加载到 <code>Buffer Pool </code>中的页面数量。 当准备从磁盘中加载某个页面时，会先为这个页面在 <code>Buffer Pool </code>中分配一个缓存页以及它对应的控制块， 然后把这个控制块添加到 <code>LRU </code>的 <code>old</code> 区域的头部，但是这个时候真正的磁盘页并没有被加载进来， <code>Pending reads</code> 的值会跟着加1。 <code>Pending writes LRU</code> ：即将从 <code>LRU</code> 链表中刷新到磁盘中的页面数量。</p><p> <code>Pending writes flush list</code> ：即将从 <code>flush</code> 链表中刷新到磁盘中的页面数量。</p><p><code> Pending writes single page</code> ：即将以单个页面的形式刷新到磁盘中的页面数量。 </p><p><code>Pages made young</code> ：代表<code> LRU</code> 链表中曾经从<code>old</code>区域移动到 <code>young </code>区域头部的节点数量。 这里需要注意，一个节点每次只有从 <code>old</code> 区域移动到<code> young</code> 区域头部时才会将 <code>Pages made young</code> 的值加<code> 1</code>，也就是说如果该节点本来就在<code> young</code> 区域，由于它符合在 <code>young</code> 区域<code>1/4</code>后边的要求，下一次访问这个页 面时也会将它移动到 <code>young </code>区域头部，但这个过程并不会导致<code>Pages made young</code>的值加1。</p><p><code> Page made not young</code> ：在将<code> innodb_old_blocks_time</code> 设置的值大于<code>0</code>时，首次访问或者后续访问某个处 在 <code>old </code>区域的节点时由于不符合时间间隔的限制而不能将其移动到 <code>young</code> 区域头部时， <code>Page made not young</code> 的值会加<code>1</code>。 这里需要注意，对于处在 <code>young</code> 区域的节点，如果由于它在 <code>young </code>区域的<code>1/4</code>处而导致它没有被移动到 <code>young</code> 区域头部，这样的访问并不会将<code>Page made not young</code>的值加1。</p><p> <code>youngs/s </code>：代表每秒从 <code>old</code> 区域被移动到 <code>young</code> 区域头部的节点数量。 </p><p><code>non-youngs/s</code> ：代表每秒由于不满足时间限制而不能从 <code>old</code> 区域移动到 <code>young</code> 区域头部的节点数量。 </p><p><code>Pages read 、 created 、 written </code>：代表读取，创建，写入了多少页。后边跟着读取、创建、写入的速 率。 </p><p><code>Buffer pool hit rate</code> ：表示在过去某段时间，平均访问<code>1000</code>次页面，有多少次该页面已经被缓存到 <code>Buffer Pool</code> 了。 </p><p><code>young-making rate</code> ：表示在过去某段时间，平均访问<code>1000</code>次页面，有多少次访问使页面移动到 <code>young</code> 区 域的头部了。 需要大家注意的一点是，这里统计的将页面移动到 <code>young</code> 区域的头部次数不仅仅包含从 <code>old</code> 区域移动到 <code>young</code> 区域头部的次数，还包括从 <code>young</code> 区域移动到 <code>young</code> 区域头部的次数（访问某个 <code>young</code> 区域的节 点，只要该节点在 <code>young</code> 区域的<code>1/4</code>处往后，就会把它移动到 <code>young</code> 区域的头部）。 </p><p><code>not (young-making rate)</code> ：表示在过去某段时间，平均访问<code>1000</code>次页面，有多少次访问没有使页面移动 到 <code>young </code>区域的头部。 需要大家注意的一点是，这里统计的没有将页面移动到 <code>young</code> 区域的头部次数不仅仅包含因为设置了 <code>innodb_old_blocks_time</code> 系统变量而导致访问了 <code>old</code> 区域中的节点但没把它们移动到 <code>young</code> 区域的次数， 还包含因为该节点在 <code>young</code> 区域的前<code>1/4</code>处而没有被移动到 <code>young</code> 区域头部的次数。 </p><p><code>LRU len</code> ：代表 <code>LRU</code>链表 中节点的数量。 </p><p><code>unzip_LRU</code> ：代表 <code>unzip_LRU</code>链表 中节点的数量。</p><p> <code>I/O sum</code> ：最近<code>50s</code>读取磁盘页的总数。 </p><p><code>I/O cur </code>：现在正在读取的磁盘页数量。 </p><p><code>I/O unzip sum</code> ：最近<code>50s</code>解压的页面数量。 </p><p><code>I/O unzip cur</code> ：正在解压的页面数量。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL之MVCC</title>
      <link href="/post/209c3cef.html"/>
      <url>/post/209c3cef.html</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL之MVCC"><a href="#MySQL之MVCC" class="headerlink" title="MySQL之MVCC"></a>MySQL之MVCC</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote><p>在前面的<strong>MySQL锁</strong>文章中有提到过，<code>MyISAM</code>表的读操作与写操作，以及写操作之间是串行的。</p><p>并且默认情况下写操作命令的执行优先于读操作执行，即使读请求早于写请求到达，写锁也会插队到读请求前面，因为<code>MySQL</code>认为写请求一般比读请求要重要。</p><p>在<code>InnoDB</code>中，就是通过多版本并发控制（<code>MVCC</code>）来解决读请求和写请求的并发问题，<strong>提高数据库的并发能力</strong>。并且在<code>InnoDB</code>中是默认读不加锁，读写不冲突的。</p></blockquote><h2 id="两个概念"><a href="#两个概念" class="headerlink" title="两个概念"></a>两个概念</h2><h3 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h3><blockquote><p>不加锁的<code>select</code>操作就是快照读，即不加锁的非阻塞读。当我们执行<code>select xxx from table_name where xxx=yyy</code>语句时，就是快照读。</p></blockquote><p>不是所有的隔离级别下都支持快照读。</p><blockquote><ul><li><strong>读未提交： 不支持</strong>，未提交读总是读取最新的数据行，而不是符合当前事务版本的数据行</li><li><strong>读已提交：支持</strong>，每次<code>select</code>都生成一个快照读</li><li><strong>可重复读：支持</strong>，开启事务后执行第一个<code>select</code>语句才生成快照读，而不是一开启事务就生成快照读, 并且整个事务只生成一个快照读</li><li><strong>串行化：不支持</strong>，在此隔离级别下，读请求都是当前读。</li></ul></blockquote><h3 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h3><blockquote><p><strong>读取的是最新版本, 并且对读取的记录加锁, 阻塞其他事务同时改动相同记录，避免出现安全问题。</strong></p></blockquote><p>可执行以下语句来进行当前读：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ... <span class="keyword">for</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ... lock <span class="keyword">in</span> share mode</span><br></pre></td></tr></table></figure><p>除此之外，还有隐式的当前读，如执行<code>insert</code>/<code>update</code>/<code>delete</code>语句时，这些语句会获取<strong>排他锁</strong>，自然保证了数据是最新的。</p><blockquote><p><code>ps</code>: 这里获取的排他锁，其实就是<code>InnoDB</code>中的<code>next-key lock</code>(即<code>record lock</code> + <code>gap lock</code>)</p></blockquote><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="隐藏列"><a href="#隐藏列" class="headerlink" title="隐藏列"></a>隐藏列</h3><blockquote><p>在<code>MySQL</code>表中除了我们创建的字段列以外，还有一些隐藏列字段，正是通过一些隐藏列字段来实现<code>MVCC</code>。</p></blockquote><p><strong>DB_TRX_ID</strong></p><blockquote><p>最近修改(修改/插入)事务<code>id</code>(6字节)：记录创建这条记录/最后一次修改该记录的事务<code>id</code></p></blockquote><p><strong>DB_ROLL_PTR</strong></p><blockquote><p>回滚指针（7字节）：指向这条记录的上一个版本（存储于<code>rollback segment</code>里）</p></blockquote><p><strong>DB_ROW_ID</strong></p><blockquote><p>隐藏主键（6字节）：隐含的自增<code>id</code>，如果数据表没有主键，<code>InnoDB</code>会自动以<code>DB_ROW_ID</code>产生一个聚簇索引</p></blockquote><h3 id="Undo-Log-版本链"><a href="#Undo-Log-版本链" class="headerlink" title="Undo Log 版本链"></a>Undo Log 版本链</h3><p><a href="https://blog.csdn.net/thesprit/article/details/112970122">【数据库】MySQL的ReadView</a></p><p><code>undo log</code> 版本链是基于 <code>undo log</code> 实现的。<code>undo log</code> 中主要保存了数据的基本信息，比如说日志开始的位置、结束的位置，主键的长度、表<code>id</code>，日志编号、日志类型。</p><p><img src="https://img-blog.csdnimg.cn/20210121192322560.png#pic_center"></p><p>此外，<code>undo log</code> 还包含两个隐藏字段 <code>trx_id</code> 和 <code>roll_pointer</code>。<code>trx_id</code> 表示当前这个事务的 <code>id</code>，<code>MySQL</code> 会为每个事务分配一个 <code>id</code>，这个<code> id</code> 是递增的。<code>roll_pointer</code> 是一个指针，指向这个事务之前的 <code>undo log</code>。</p><p><img src="https://img-blog.csdnimg.cn/20210121192333997.png#pic_center"></p><p>示例</p><p>执行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;张三&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210121192349964.png#pic_center"></p><p>继续执行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span><span class="string">&#x27;李四&#x27;</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210121192402415.png#pic_center"></p><p>继续执行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span><span class="string">&#x27;王五&#x27;</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210121192413555.png"></p><p>如此，数据行的每一次变化都会记录在<code>undo log</code>中。为了保证事务并发操作时，在写各自的<code>undo log</code>时不产生冲突，<code>InnoDB</code>采用回滚段的方式来维护<code>undo log</code>的并发写入和持久化。回滚段实际上是一种<code>undo</code>文件组织方式。</p><blockquote><p><code>ps</code>：<code>select</code>操作不会记录到<code>undo log</code>中，因为并没有改变数据行。</p></blockquote><h3 id="Read-View（读视图）"><a href="#Read-View（读视图）" class="headerlink" title="Read View（读视图）"></a>Read View（读视图）</h3><p>由上面的<code>Undo Log</code>版本链，我们知道在<code>MySQL</code>中同一行数据会有多个版本，那在事务进行数据读取的时候，怎么判断数据具体应该读取哪一个版本呢？</p><p>在执行<strong>当前读</strong>时，明显我们是要读取数据行的最新版本，这个是确定的。</p><p>当执行<strong>快照读</strong>时，我们可以根据当前事务的事务<code>id</code>来判断，具体该读取数据行的哪一个版本。</p><blockquote><p><code>ps</code>：每个事务开启时，都会被分配一个<code>id</code>，这个<code>id</code>是默认递增的，所以事务越新，<code>id</code>越大</p></blockquote><p>在<code>MySQL</code>执行<strong>快照读</strong>时，会生成数据库系统当前的一个快照，根据事务状态或者事务<code>id</code>，大概有以下几类信息</p><ul><li>已提交事务列表</li><li>未提交事务列表（活跃事务）</li><li>还未分配事务<code>id</code>(最大活跃事务<code>id</code> + 1)</li></ul><blockquote><p>当前事务<code>id</code>可见的数据，是根据事务<code>id</code>来进行判断的。</p><p>大于最大事务<code>id</code>，不可见<br>在活跃事务<code>id</code>集合中的，不可见</p><p>小于最小的活跃事务<code>id</code>的，可见<br>事务<code>id</code>为本事务<code>id</code>的，可见</p></blockquote><p><strong>总结</strong>：</p><blockquote><p><code>Read View</code>就是协助<code>MVCC</code>来实现并发读写时，保证事务能正确读取数据行信息。</p></blockquote><h2 id="可重复读的实现"><a href="#可重复读的实现" class="headerlink" title="可重复读的实现"></a>可重复读的实现</h2><p>在<strong>可重复读</strong>的隔离级别下，我们在事务中，多次读取数据，前后总是一致的。这个就是依赖<code>MVCC</code>来实现的。</p><blockquote><p>在可重复读的隔离级别下，事务中第一个执行<code>select</code>语句的时刻，数据库才会生成一个<code>Read View</code>，事务后续的快照读都会使用这个<code>Read View</code>来读取数据。</p></blockquote><h2 id="MVCC解决幻读了吗"><a href="#MVCC解决幻读了吗" class="headerlink" title="MVCC解决幻读了吗"></a>MVCC解决幻读了吗</h2><p><a href="https://www.modb.pro/db/398186">MySQL(九)：MVCC能否解决幻读问题</a></p><p><strong>幻读：</strong></p><blockquote><p><strong>事务A执行多次读取操作过程中，由于在事务提交之前，事务B（<code>insert</code>/<code>delete</code>/<code>update</code>）写入了一些符合事务A的查询条件的记录，导致事务A在之后的查询结果与之前的结果不一致，这种情况称之为幻读</strong>。</p></blockquote><p>在<strong>可重复读</strong>的隔离级别下</p><blockquote><p><strong>快照读时</strong>，事务读取数据都是通过<code>Read View</code>来读取的，并且事务中第一个执行<code>select</code>语句的时刻，数据库才会生成一个<code>Read View</code>，事务后续的快照读都会使用这个<code>Read View</code>来读取数据。</p><p>这样并不会读取到其他事务提交的数据行，保证了多次读取数据的结果是一致的，所以解决了幻读的问题。</p></blockquote><blockquote><p><strong>当前读时</strong>，事务总是会读取数据行的最新版本，在不做其他限制的情况下，<code>MVCC</code>并不会阻止其他事务进行数据行的插入，所以不能解决幻读的问题。</p></blockquote><p><strong>结论</strong></p><blockquote><p><strong><code>MVCC</code>在快照读的情况下可以解决幻读问题，但是在当前读的情况下不能解决，需要配合间隙锁才能解决</strong></p></blockquote><h2 id="可重复读隔离级别一定不会发生幻读吗？"><a href="#可重复读隔离级别一定不会发生幻读吗？" class="headerlink" title="可重复读隔离级别一定不会发生幻读吗？"></a>可重复读隔离级别一定不会发生幻读吗？</h2><p><strong>不一定</strong>，在事务中交叉使用 <strong>当前读</strong> 和  <strong>快照读</strong> 时，仍然会发生幻读问题。</p><p>情况一：</p><blockquote><ol><li>事务A先查询，此时数据库没有记录a</li><li>事务B插入记录a，并提交事务</li><li>事务A更新不存在的记录a</li><li>然后事务A就可以看到事务B提交的记录a了，即出现了幻读</li></ol></blockquote><p>情况二：</p><blockquote><ol><li>事务A执行快照读，查询记录行数</li><li>事务B插入一条数据，并提交事务</li><li>事务A执行当前读，查询记录行数，行数不一致，即出现了幻读</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL之InnoDB数据页</title>
      <link href="/post/ffd4a6fe.html"/>
      <url>/post/ffd4a6fe.html</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL之InnoDB数据页"><a href="#MySQL之InnoDB数据页" class="headerlink" title="MySQL之InnoDB数据页"></a>MySQL之InnoDB数据页</h1><p>页是<code>InnoDB</code>管理存储空间的基本单位，一个页的大小一般是 <code>16KB</code> 。</p><p><code>InnoDB</code> 为了不同的目的而设计了许多种不同类型的页 ，下文主要讲述存储数据行的页，官方称之为<strong>索引页</strong>。</p><p>页 一般由以下七个部分组成。</p><ul><li>File Header (38字节) ： 文件头，存放页的一些通用信息</li><li>Page Header (56字节)：页面头，存放数据页专有的一些信息</li><li>Infimum + Superemum (26字节)：两个虚拟的行记录，分别指向当前页的最小记录和最大记录</li><li>User Records (大小不确定，数据行信息)： 实际存储的行记录内容</li><li>Free Space (大小不确定)：空闲空间，页中尚未使用的空间</li><li>Page Directory (大小不确定)：页面目录，页中某些记录的相对位置</li><li>File Tailer (8字节)：文件尾部，校验页是否完整</li></ul><h2 id="Infimum、Superemum"><a href="#Infimum、Superemum" class="headerlink" title="Infimum、Superemum"></a>Infimum、Superemum</h2><p> <code>Infimum</code>记录（也就是最小记录）的下一条记录就是 本页中主键值最小的用户记录，</p><p>本页中主键值最大的用户记录的下一条记录就是 <code>Supremum</code>记录（也就是最大记录）</p><h2 id="Page-Directory"><a href="#Page-Directory" class="headerlink" title="Page Directory"></a>Page Directory</h2><p>记录在页中按照主键值由小到大顺序串联成一个单链表。</p><p>如果我们想根据主键值查找页中的某条记录，就只能从前往后遍历，直到遍历到对应的记录为止，明显这种处理方式效率很低。</p><p>每一行的记录都有记录头，信息如下：</p><table><thead><tr><th>名称</th><th>大小（bit）</th><th>说明</th></tr></thead><tbody><tr><td>预留位1</td><td>1</td><td>没有使用</td></tr><tr><td>预留位2</td><td>1</td><td>没有使用</td></tr><tr><td><code>deleted_flag</code></td><td>1</td><td>记录删除标记</td></tr><tr><td><code>min_rec_flag</code></td><td>1</td><td>B+树非叶子节点的最小目录项标记</td></tr><tr><td><code>n_owned</code></td><td>4</td><td>同一页内同一组里最大的记录会记录组里的记录数量，其余记录该值为0</td></tr><tr><td><code>heap_no</code></td><td>13</td><td>当前记录在页面堆里的相对位置</td></tr><tr><td><code>record_type</code></td><td>3</td><td>记录类型。0: 普通记录, 1: <code>B+</code>树非叶子节点目录项记录, 2: <code>Infimum</code>记录, 3: <code>Supremum</code>记录.</td></tr><tr><td><code>next_record</code></td><td>16</td><td>下一条记录的相对位置</td></tr></tbody></table><p>优化处理如下:</p><ol><li><strong>将所有正常的记录（包括最大和最小记录，不包括标记为已删除的记录）划分为几个组</strong>。 </li><li> <strong>每个组的最后一条记录（也就是组内最大的那条记录）的头信息中的 <code>n_owned</code> 属性表示该记录拥有多少条记 录，也就是该组内共有几条记录。</strong> </li><li><strong>将每个组的最后一条记录的地址偏移量(<code>next record</code>)单独提取出来按顺序存储到靠近 页 的尾部的地方，这个地方就是所 谓的 <code>Page Directory</code> ，也就是 页目录 。页面目录中的这些地址 偏移量被称为 槽 （英文名： <code>Slot</code> ），所以这个页面目录就是由 槽 组成的。</strong></li></ol><p><strong>对于最小记录所在的分组只能有 1 条记录， 最大记录所在的分组拥有的记录条数只能在 1<del>8 条之间，剩下的分组中记录的条数范围只能在是 4</del>8 条之间</strong></p><p>分组步骤如下：</p><ul><li><strong>初始情况下一个数据页里只有最小记录和最大记录两条记录，它们分属于两个分组。</strong> </li><li><strong>之后每插入一条记录，都会从 页目录 中找到主键值比本记录的主键值大并且差值最小的槽，然后把该槽对 应的记录的 n_owned 值加1，表示本组内又添加了一条记录，直到该组中的记录数等于8个。</strong> </li><li><strong>在一个组中的记录数等于8个后再插入一条记录时，会将组中的记录拆分成两个组，一个组中4条记录，另一 个5条记录。这个过程会在 页目录 中新增一个 槽 来记录这个新增分组中最大的那条记录的偏移量。</strong></li></ul><p>优化之后的查询过程如下：</p><ol><li><strong>通过二分法确定该记录所在的槽，并找到该槽中主键值最小的那条记录。</strong></li><li><strong>通过记录的 <code>next_record</code> 属性遍历该槽所在的组中的各个记录。</strong></li></ol><h2 id="Page-Header"><a href="#Page-Header" class="headerlink" title="Page Header"></a>Page Header</h2><p>以下部分来源：<a href="https://juejin.cn/post/6974225353371975693">MySQL系列（4）— InnoDB数据页结构 - 掘金 (juejin.cn)</a></p><p>记录数据页中存储的记录的状态信息，比如本页中已经存储了多少条记录，第 一条记录的地址是什么，页目录中存储了多少个槽等等，这个部分占用固定的 56 个字节。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/997d4cc05f05453cb4919db54cfcdb6c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image"></p><ul><li><code>PAGE_N_DIR_SLOTS</code></li></ul><p>页中的记录会按主键顺序分为多个组，每个组会对应到一个槽（<code>Slot</code>），<code>PAGE_N_DIR_SLOTS</code> 就记录了 <code>Page Directory</code> 中槽的数量。</p><ul><li><code>PAGE_HEAP_TOP</code></li></ul><p><code>PAGE_HEAP_TOP</code> 记录了 <code>Free Space</code> 的地址，这样就可以快速从 <code>Free Space</code> 分配空间到 <code>User Records </code>了。</p><ul><li><code>PAGE_N_HEAP</code></li></ul><p>本页中的记录的数量，包括最小记录（<code>Infimum</code>）和最大记录（<code>Supremum</code>）以及标记为删除（<code>delete_mask=1</code>）的记录。</p><ul><li><code>PAGE_FREE</code></li></ul><p>已删除的记录会通过 <code>next_record</code>连成一个单链表，这个单链表中的记录空间可以被重新利用，<code>PAGE_FREE</code> 指向第一个标记为删除的记录地址，就是单链表的头节点。</p><ul><li><code>PAGE_GARBAGE</code></li></ul><p>标记为已删除的记录占用的总字节数。</p><ul><li><code>PAGE_N_RECS</code></li></ul><p>本页中记录的数量，不包括最小记录和最大记录以及被标记为删除的记录，注意和 <code>PAGE_N_HEAP</code> 的区别。</p><h2 id="File-Header"><a href="#File-Header" class="headerlink" title="File Header"></a>File Header</h2><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/afbeb375b5134bf58a3208c4456d692d~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image"></p><ul><li><code>FIL_PAGE_SPACE_OR_CHKSUM</code></li></ul><p>这个代表当前页面的校验和（checksum），每当一个页面在内存中修改了，在同步之前就要把它的校验和算出来。在一个页面被刷到磁盘的时候，首先被写入磁盘的就是这个 checksum。</p><ul><li><code>FIL_PAGE_OFFSET</code></li></ul><p>每一个页都有一个单独的页号，InnoDB 通过页号来唯一定位一个页。</p><p>如某独立表空间 a.ibd 的大小为1GB，页的大小默认为16KB，那么总共有65536个页。FIL_PAGE_OFFSET 表示该页在所有页中的位置。若此表空间的ID为10，那么搜索页（10，1）就表示查找表a中的第二个页。</p><ul><li><code>FIL_PAGE_PREV</code> 和 <code>FIL_PAGE_NEXT</code></li></ul><p>InnoDB 是以页为单位存放数据的，InnoDB 表是索引组织的表，数据是按主键顺序存放的。数据可能会分散到多个不连续的页中存储，这时就会通过 FIL_PAGE_PREV 和 FIL_PAGE_NEXT 将上一页和下一页连起来，就形成了一个双向链表。这样就通过一个双向链表把许许多多的页就都串联起来了，而无需这些页在物理上真正连着。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30a5ee1b6f1543648ecad0b392fbfed6~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="image.png"></p><ul><li><code>FIL_PAGE_TYPE</code></li></ul><p>这个代表当前页的类型，InnoDB 为了不同的目的而设计了许多种不同类型的页。</p><p>InnoDB 有如下的一些页类型：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fcb6dd1fe2b940d88d889e315a6e6562~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="image.png"></p><h2 id="File-Tailer"><a href="#File-Tailer" class="headerlink" title="File Tailer"></a>File Tailer</h2><p>将页写入磁盘时，最先写入的便是 File Header 中的 <code>FIL_PAGE_SPACE_OR_CHKSUM</code> 值，就是页面的校验和。在写入的过程中，数据库可能发生宕机，导致页没有完整的写入磁盘。</p><p>为了校验页是否完整写入磁盘，InnoDB 就设置了 <code>File Trailer</code> 部分。File Trailer 中只有一个<code>FIL_PAGE_END_LSN</code>，占用<code>8字节</code>。FIL_PAGE_END_LSN 又分为两个部分，前<code>4字节</code>代表页的校验和；后<code>4字节</code>代表页面被最后修改时对应的日志序列位置（LSN），与File Header中的<code>FIL_PAGE_LSN</code>相同。</p><p>默认情况下，InnoDB存储引擎每次从磁盘读取一个页就会检测该页的完整性，这时就会将 <code>File Trailer</code> 中的校验和、LSN 与 <code>File Header</code> 中的 <code>FIL_PAGE_SPACE_OR_CHKSUM</code>、<code>FIL_PAGE_LSN</code> 进行比较，以此来保证页的完整性。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL之InnoDB行记录</title>
      <link href="/post/81fc7f34.html"/>
      <url>/post/81fc7f34.html</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL之InnoDB行记录"><a href="#MySQL之InnoDB行记录" class="headerlink" title="MySQL之InnoDB行记录"></a>MySQL之InnoDB行记录</h1><p><code>MySQL</code> 不同的存储引擎中真实数据存放的格式一般是不同的，下文简单介绍<code>InnoDB</code>中的行记录格式。</p><p><code>InnoDB</code>存储引擎目前共支持四种行格式，如下表：</p><table><thead><tr><th><strong>行格式</strong></th><th><strong>紧凑存储</strong></th><th><strong>增强的可变长度列存储</strong></th><th><strong>大索引键前缀支持</strong></th><th><strong>支持压缩</strong></th></tr></thead><tbody><tr><td><code>REDUNDANT</code></td><td>否</td><td>否</td><td>否</td><td>否</td></tr><tr><td><code>COMPACT</code></td><td>是</td><td>否</td><td>否</td><td>否</td></tr><tr><td><code>DYNAMIC</code></td><td>是</td><td>是</td><td>是</td><td>否</td></tr><tr><td><code>COMPRESSED</code></td><td>是</td><td>是</td><td>是</td><td>是</td></tr></tbody></table><p><code>MySQL</code> 5.0之后的默认行格式为<code>Compact </code>，<code>MySQL</code>5.7之后的默认行格式为<code>Dynamic</code>。</p><h2 id="Compact"><a href="#Compact" class="headerlink" title="Compact"></a>Compact</h2><p>示意图如下。</p><p><img src="https://img-blog.csdnimg.cn/859ab55da7e84b9da3ec34cd4ca9d611.png"></p><h3 id="记录的额外信息"><a href="#记录的额外信息" class="headerlink" title="记录的额外信息"></a>记录的额外信息</h3><h4 id="变长字段长度列表"><a href="#变长字段长度列表" class="headerlink" title="变长字段长度列表"></a>变长字段长度列表</h4><p> <code>varchar(M) </code>、 <code>varbinary(M) </code>、<code>text</code>、<code>blob</code>等不确定数据具体长度的数据类型中，存储多少字节的数据是不固定的，我们在存储真实数据的时候需要把这些数据占用的字节数也存起来，读取数据的时候，才能准确读完整这些不确定长度的数据。所以变长字段实际需要存储一下信息</p><ul><li>实际的字段值</li><li>实际字段长度（字节长度）</li></ul><p><strong>如果该可变字段允许存储的最大字节数超过255字节并且真实存储的字节数超过127字节，则使用2个字节，否则使用1个字节。</strong>原由如下所述：</p><p>最大字节数由表设置的字符编码集和<code>varchar(M)</code>的<code>M</code>来共同决定。比如在<code>utf-8</code>字符编码集中，一个字符最多需要使用 3 个字节来来表示，那么最大字节数就是 <strong>3*M</strong>。</p><p><strong>字节长度的最高位不用来表示长度，而是用来区分它正在读的某个字节是一个单独的字段长度还是半个字段长度。</strong>如果该字节的第一个位为0，那 该字节就是一个单独的字段长度（使用一个字节表示不大于127的二进制的第一个位都为0）， 如果该字节的第一个位为1，那该字节就是半个字段长度。</p><p>在 <code>Compact</code> 行格式中，把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长 字段长度列表，各变长字段数据占用的字节数按照列的顺序**<font color=red>逆序存放</font>**。</p><p><strong>变长字段长度列表中只存储值为非NULL 的列内容占用的长度，值为 NULL 的列的长度 是不储存的</strong></p><blockquote><p><strong>char(M)算不算变长？</strong></p></blockquote><p>**<font color=red>看具体使用的字符集！</font>**如果是<code>ascii</code>字符集，所有字符都固定占用1字节，那就不需要记录。如果是<code>utf-8</code>，一个字符占用的字节数为<code>1~3</code>，这种不固定的字符集，就需要存储了变长字段长度了。例如<code>CHAR(10)</code>使用<code>utf-8</code>字符集，占用的存储空间范围是<code>10~30</code>，列的实际长度还是不确定的。</p><h4 id="NULL值列表"><a href="#NULL值列表" class="headerlink" title="NULL值列表"></a>NULL值列表</h4><p>表中的某些列可能存储 <code>NULL</code> 值，如果把这些 <code>NULL</code> 值都放到 记录的真实数据 中存储会浪费磁盘空间，所<br>以 <code>Compact</code> 行格式把这些值为<code>NULL</code> 的列统一管理起来，存储到 <code>NULL</code> 值列表中。</p><ol><li>首先统计表中允许存储 <code>NULL</code>的列有哪些</li><li>如果表中没有允许存储 <code>NULL</code>的列，则 <code>NULL</code>值列表 也不存在了，否则将每个允许存储 <code>NULL</code>的列对应一个 二进制位，**二进制位按照列的顺序<font color=red>逆序排列</font>**，二进制位表示的意义如下<ul><li>二进制位的值为 1 时，代表该列的值为 <code>NULL</code></li><li>二进制位的值为 0 时，代表该列的值不为 <code>NULL</code></li></ul></li><li><code>MySQL</code> 规定 <code>NULL</code>值列表 必须用整数个字节的位表示，如果使用的二进制位个数不是整数个字节，则在字节 的高位补 0</li></ol><blockquote><p><strong>为什么变长字段和<code>NULL</code>值列表都是逆序存储？</strong></p></blockquote><p>记录头信息里有一个指针，将一条条记录串联成单向链表。指针指向的位置并不是一条完整记录的起始位置，而是图中「记录的真实数据」的起始位置。这样的好处是，往右读就是真实数据，往左读就是头信息，<strong>根据计算机的局部性原理，更容易提高二者缓存的命中率。</strong></p><h4 id="记录头信息"><a href="#记录头信息" class="headerlink" title="记录头信息"></a>记录头信息</h4><p>由固定的 5 个字节组 成。 5 个字节也就是 40 个二进制位，不同的位代表不同的意思。</p><table><thead><tr><th>名称</th><th>大小（bit）</th><th>说明</th></tr></thead><tbody><tr><td>预留位1</td><td>1</td><td>没有使用</td></tr><tr><td>预留位2</td><td>1</td><td>没有使用</td></tr><tr><td><code>deleted_flag</code></td><td>1</td><td>记录删除标记</td></tr><tr><td><code>min_rec_flag</code></td><td>1</td><td>B+树非叶子节点的最小目录项标记</td></tr><tr><td><code>n_owned</code></td><td>4</td><td>同一页内同一组里最大的记录会记录组里的记录数量，其余记录该值为0</td></tr><tr><td><code>heap_no</code></td><td>13</td><td>当前记录在页面堆里的相对位置</td></tr><tr><td><code>record_type</code></td><td>3</td><td>记录类型。0: 普通记录, 1: <code>B+</code>树非叶子节点目录项记录, 2: <code>Infimum</code>记录, 3: <code>Supremum</code>记录.</td></tr><tr><td><code>next_record</code></td><td>16</td><td>下一条记录的相对位置</td></tr></tbody></table><p><strong>deleted_flag</strong></p><blockquote><p><code>DELETE</code>命令删除记录，并不会真的将它从磁盘中删除，而是仅仅打一个标记，然后把该条记录加入到「垃圾链表」里，垃圾链表占用的空间称为「可重用空间」，以后如果在这个位置插入新的记录就可以重用这部分空间了。如果一个页内所有的记录都被删除了，那么这个页就称为「可重用的页」。</p></blockquote><p><strong>min_rec_flag</strong></p><blockquote><p><code>InnoDB</code>引擎组织数据的形式采用了<code>B+</code>树，用户记录存储在叶子节点，目录项(也可叫索引项)存储在非叶子节点，一个个节点就是一个个页，同一个非叶子节点内最小的目录项该比特位为1，其余均为0。</p></blockquote><p><strong>n_owned</strong></p><blockquote><p><code>InnoDB</code>引擎页大小默认是<code>16KB</code>，同一个页内可能会存储很多的用户记录，甚至上千条。为了提高页内的检索效率，<code>InnoDB</code>会将记录划分为多个不同的组，组内记录值最大的一条称为“大哥”，其余的都是“小弟”，<strong>“大哥”会利用该属性来记录组内的记录数量</strong>，<strong>各个组的“大哥”的值会按照顺序被记录在页内的页目录位置。</strong></p><p><strong><font color=red>这里记录的组内记录数量是有效记录的数量，不包括被移除到垃圾链表的记录</font></strong></p></blockquote><p><strong>heap_no</strong></p><blockquote><p>用户记录存储在页的<code>User Records</code>部分，<code>MySQL</code>将这部分结构称作堆(Heap)，每申请一块记录空间，都会为其分配一个<code>heap_no</code>，越靠前的记录<code>heap_no</code>越小，越靠后的记录<code>heap_no</code>越大。</p></blockquote><p><strong>record_type</strong></p><blockquote><p>记录类型，共有以下几种值</p><ul><li><strong>0</strong>：用户自己插入的记录，或二级索引叶子节点记录。</li><li><strong>1</strong>：<code>B+</code>树非叶子节点目录项记录，冗余的索引项记录。</li><li><strong>2</strong>：页内虚拟的最小记录：<code>Infimum</code></li><li><strong>3</strong>：页内虚拟的最大记录：<code>Supremum</code></li></ul></blockquote><p><strong>next_record</strong></p><blockquote><p><strong><font color=red>表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量，它指向的位置是记录头和真实列数据的中间，往左读就是记录头信息，往右读就是真实数据</font></strong></p><p>用户记录会根据主键值排序并构建一条单向链表，链表就是通过该属性来构建的。它代表当前记录的真实数据到下一条记录的真实数据的距离，值为正数代表下一条记录在后面，值为负数代表下一条记录在前面。</p><p><code>MySQL</code>规定，页中<code>Infimum</code>的下一条记录是本页中主键值最小的记录，主键值最大的记录<code>next_record</code>一定指向<code>Supremum</code>。</p></blockquote><h2 id="Redundant"><a href="#Redundant" class="headerlink" title="Redundant"></a>Redundant</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/355f10d5b47190e46fbd306e8c54fb29.png"></p><p><strong>字段长度偏移列表</strong><br><code>REDUNDANT</code>没有区别对待定长和变长字段，将所有列占用的存储空间都逆序存放在字段长度偏移列表中。根据字段的偏移量就可以定位到字段的存储位置，和下一个偏移量的差值可以计算出字段的长度，从而取出字段的完整信息。</p><p><strong>记录头信息</strong><br><code>REDUNDANT</code>记录头信息固定占用6字节，即48个比特位，每个比特位代表的含义如下表：</p><table><thead><tr><th>名称</th><th>大小（bit）</th><th>说明</th></tr></thead><tbody><tr><td>预留位1</td><td>1</td><td>没有使用</td></tr><tr><td>预留位2</td><td>1</td><td>没有使用</td></tr><tr><td><code>deleted_flag</code></td><td>1</td><td>记录删除标记</td></tr><tr><td><code>min_rec_flag</code></td><td>1</td><td>B+树非叶子节点的最小目录项标记</td></tr><tr><td><code>n_owned</code></td><td>4</td><td>同一页内同一组里最大的记录会记录组里的记录数量，其余记录该值为0</td></tr><tr><td><code>heap_no</code></td><td>13</td><td>当前记录在页面堆里的相对位置</td></tr><tr><td><code>n_field</code></td><td>10</td><td>记录中列的数量</td></tr><tr><td><code>1byte_offs_flag</code></td><td>1</td><td>标识字段长度偏移列表里用1字节还是2字节存储长度</td></tr><tr><td><code>next_record</code></td><td>16</td><td>下一条记录的相对位置</td></tr></tbody></table><p><strong>使用几个字节来记录字段长度偏移量？</strong><br>当记录所有列的总长度不超过127时，使用1字节存储，因为总长度都没超过127，单个字段的长度肯定不会超过127。列总长度大于127时，使用2字节存储。2字节最多能表示65535，有没有可能一行记录占用的空间超过了65535呢？是有可能的，这种情况称为 <strong>行溢出</strong>，<strong>记录的真实数据处只会保存前768字节的数据+20字节的指针，剩余的数据则存储在专门的「溢出页」中。</strong></p><p><strong>如何处理NULL？</strong><br><code>REDUNDANT</code>没有专门的「<code>NULL</code>值列表」，那它是如何处理NULL值的呢？还记得「字段长度偏移列表」吗？1字节最大能表示255，为啥超过127就开始使用2字节呢？原因就在于，<code>REDUNDANT</code>会把第0位用来标记是否为<code>NULL</code>，第0位是1则代表值为<code>NULL</code>，是0就不为<code>NULL</code>。</p><p><strong>定长列和变长列处理NULL值的区别？</strong><br>如果定长列存储的是<code>NULL</code>值，则<code>NULL</code>值也会占用存储空间，数据全部用<code>0x00</code>字节填充。例如<code>char(10)</code>就会占用<code>10</code>个字节(与字符集有关，<code>utf8</code>则直接占用<code>30</code>字节)，这样做的好处是，以后<code>update</code>该列时，可以直接复用这一块空间。如果变长列存储的是<code>NULL</code>值，则<code>NULL</code>值本身不占空间。</p><h2 id="Dynamic"><a href="#Dynamic" class="headerlink" title="Dynamic"></a>Dynamic</h2><p>和<code>Compact</code>很类似，只是处理<strong>行溢出</strong>的方式不太一样。</p><p>是<code>MySQL</code> 版本 <code>5.7</code> 之后的默认行格式。</p><h2 id="Compressed"><a href="#Compressed" class="headerlink" title="Compressed"></a>Compressed</h2><p><code>Compressed</code> 行格式和 <code>Dynamic</code> 不同的一点是， <code>Compressed</code> 行格式会采用压缩算法对页面进行压缩，以节省空间。</p><h2 id="行溢出"><a href="#行溢出" class="headerlink" title="行溢出"></a>行溢出</h2><p><code>MySQL</code>中管理数据的最小单位是<strong>页</strong>，默认情况下，页大小为**<code>16KB</code><strong>，</strong>并且要求每页至少保存两条记录。**</p><p><code>MySQL</code>规定一行记录，除了<code> BLOB</code> 或者 <code>TEXT</code> 类型的列之 外，其他所有的列（<strong>不包括隐藏列和记录头信息</strong>）占用的字节长度加起来不能超过 <code>65535</code> 个字节。</p><p>比如说我们为了存储一个 <code>VARCHAR(M)</code> 类型的列，其实需要占用3部分存储 空间： </p><ul><li>真实数据 </li><li>真实数据占用字节的长度</li><li><code>NULL</code> 值标识，如果该列有 <code>NOT NULL </code>属性则可以没有这部分存储空间 如果该<code> VARCHAR</code> 类型的列没有 <code>NOT NULL </code>属性，那最多只能存储 <code>65532 </code>个字节的数据，因为真实数据的长度可能 占用<code>2</code>个字节，<code> NULL</code> 值标识需要占用<code>1</code>个字节。</li></ul><p>即会有以下两种情况</p><ol><li>创建表时，定义的数据列所占用的字节大小，超过了<code>MySQL</code>规定的上限（<strong>会报错</strong>）</li><li>一页是**<code>16KB</code><strong>即</strong><code>16384Byte</code>**，一行最大是 <strong><code>65535Byte</code><strong>，如果插入的数据超过了页的大小，也是</strong>行溢出</strong></li></ol><p>不只是 <code>VARCHAR(M)</code> 类型的列，其他的 <code>TEXT</code>、<code>BLOB </code>类型的列在存储数据非常多的时候 也会发生行溢出。</p><p>在<code>Compact</code> 和 <code>Reduntant</code> 行格式中，对于占用存储空间非常大的列，<strong>在记录的真实数据 处只会存储该列的前 768 个字节的数据和一个指向其他页的地址（20字节，这20个字节中还包括这些分散在其他页面中的数据的占用的字节数）</strong>，把剩余的数据分散存储在几个其他的页中。<strong>这个 过程也叫做 行溢出 ，存储超出 768 字节的那些页面也被称为 溢出页 。</strong></p><p><code>Dynamic </code>和 <code>Compressed </code>行格式，它们不会在记 录的真实数据处存储字段真实数据的前<code>768</code>个字节，而是<strong>把所有的字节都存储到其他页面中，只在记录的真实数据处存储其他页面的地址。</strong></p><h2 id="查看、修改行格式"><a href="#查看、修改行格式" class="headerlink" title="查看、修改行格式"></a>查看、修改行格式</h2><h3 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h3><p>查看表信息，即可看到行格式(<code>Row_format</code>)，命令如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">table</span> status <span class="keyword">from</span> db_name <span class="keyword">like</span> &quot;table_name&quot;;</span><br></pre></td></tr></table></figure><p>效果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Name           |Value              |</span><br><span class="line">---------------+-------------------+</span><br><span class="line">Name           |table_name         |</span><br><span class="line">Engine         |InnoDB             |</span><br><span class="line">Version        |10                 |</span><br><span class="line">Row_format     |Dynamic            |</span><br><span class="line">Rows           |0                  |</span><br><span class="line">Avg_row_length |0                  |</span><br><span class="line">Data_length    |16384              |</span><br><span class="line">Max_data_length|0                  |</span><br><span class="line">Index_length   |32768              |</span><br><span class="line">Data_free      |0                  |</span><br><span class="line">Auto_increment |2                  |</span><br><span class="line">Create_time    |2022-08-10 18:41:32|</span><br><span class="line">Update_time    |2022-08-10 18:38:27|</span><br><span class="line">Check_time     |                   |</span><br><span class="line">Collation      |utf8mb4_general_ci |</span><br><span class="line">Checksum       |                   |</span><br><span class="line">Create_options |                   |</span><br><span class="line">Comment        |样例表              |</span><br></pre></td></tr></table></figure><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 ROW_FORMAT <span class="operator">=</span> 行格式名称;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/qq_32099833/article/details/123078604"> MySQL行格式</a></li><li>《从根上理解MySQL是如何运行的》</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL之Redo Log</title>
      <link href="/post/ae3a4492.html"/>
      <url>/post/ae3a4492.html</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL之Redo-Log"><a href="#MySQL之Redo-Log" class="headerlink" title="MySQL之Redo Log"></a>MySQL之Redo Log</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>重做日志，也就是<code>Redo Log</code><strong>是<code>MySQL</code>中<code>InnoDB</code>存储引擎特有的事务日志</strong>，它是一种<strong>物理日志</strong>，存储着数据被修改的具体的数据值。</p><p><code>Redo Log</code>主要有以下作用</p><ul><li><strong>实现事务的持久性，让 <code>MySQL</code> 有 <code>crash-safe</code> 的能力</strong>，能够保证 <code>MySQL </code>在任何时间段突然崩溃，重启后之前已提交的记录都不会丢失；</li><li><strong>将写操作从「随机写」变成了「顺序写」</strong>，提升<code>MySQL</code> 写入磁盘的性能。</li></ul><p><a href="https://zhuanlan.zhihu.com/p/531957976">2 万字 + 30 张图 ｜ 细聊 MySQL undo log、redo log、binlog 有什么用？ - 知乎 (zhihu.com)</a></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><code>MySQL</code>中更新数据的流程大概如下：</p><blockquote><ol><li>将数据从磁盘中读取到内存中(<code>Buffer Pool</code>)</li><li>在内存中修改数据，产生脏页</li><li>将脏页刷回磁盘</li></ol></blockquote><p>说明：</p><blockquote><p><strong>脏页</strong>：修改后的数据，和磁盘上的数据会不一致，称这种有差异的数据为脏页</p><p>页：此处留坑，后面补充。</p></blockquote><p>通过上面的更新流程，大概会产生下列问题：</p><blockquote><ol><li>如果每次有脏页产生就刷回磁盘，就会产生海量<code>IO</code>，严重影响性能</li><li>如果在刷回磁盘的过程中出现故障，就会造成数据的丢失</li></ol></blockquote><p><code>MySQL</code>是怎么解决上面两个问题的呢？答案就是<code>redo log</code>。</p><h2 id="Redo-Log"><a href="#Redo-Log" class="headerlink" title="Redo Log"></a>Redo Log</h2><p><a href="https://www.cnblogs.com/wupeixuan/p/11734501.html">MySQL 日志系统之 redo log 和 binlog </a></p><p><code>Redo Log</code>主要由两部分构成，分别是<code>Redo Log Buffer</code>和<code>Redo Log</code>文件，其中<code>Redo Log Buffer</code>是<code>MySQL</code>在内存中开辟出来的一部分区域。</p><p><code>Redo Log</code>文件有如下几个特点：</p><blockquote><ol><li><strong>循环写</strong>：文件从头开始写，写到末尾之后，又开始从头写。</li><li><strong>固定大小</strong></li></ol></blockquote><p>比如可以配置为一组 4 个文件，每个文件的大小是 1GB，那么日志总共就可以记录 4GB 的操作。从头开始写，写到末尾就又回到开头循环写，如下图所示。</p><p><img src="https://img2018.cnblogs.com/blog/1356806/201910/1356806-20191024195802574-1128675546.png"></p><p><code>check point</code>： 是当前要擦除的位置，擦除记录前需要先把对应的数据落盘（更新内存页，等待刷脏页）。</p><p><code>write pos</code>：当前记录所在的位置，<code>write pos</code>和<code>check point</code>之间的区域即可写区域。</p><blockquote><p>当<code>write pos</code>和<code>check point</code>相遇时，则表明必须要将数据刷入磁盘了，此时数据库会停止进行更新语句的执行，转而进行<code>Redo Log</code> 日志同步到磁盘中。</p></blockquote><p>**<code>innodb_flush_log_at_trx_commit</code>**变量用于控制<code>Redo Log</code>的刷盘策略，有以下几个值可以配置：</p><blockquote><p><strong>0</strong>：每次事务提交，只把<code>Redo Log</code> 内容写入<code>Redo Log Buffer</code>， 通过单独的后台线程，默认每隔<code>1s</code>写入<code>OS Cache</code>并调用 <code>fsync()</code>函数刷盘， <strong>MySQL 进程的崩溃会导致上一秒钟所有事务数据的丢失</strong></p><p><strong>1</strong>：每次事务提交时都把<code>Redo Log</code> 直接持久化到磁盘（调用<code>fsync</code>进行持久化，保证落盘），<strong>数据不会丢失</strong></p><p><strong>2</strong>：事务提交时不写入<code>Redo Log Buffer</code>，而是写入文件系统缓冲（<code>OS Cache</code>）,默认每隔<code>1s</code>调用<code>fsync()</code>函数刷盘， <strong>MySQL 进程的崩溃并不会丢失数据，只有在操作系统崩溃或者系统断电的情况下，上一秒钟所有事务数据才可能丢失</strong></p></blockquote><p>比较如下：</p><ul><li>数据安全性：参数 1 &gt; 参数 2 &gt; 参数 0</li><li>写入性能：参数 0 &gt; 参数 2&gt; 参数 1</li></ul><p><img src="https://pic2.zhimg.com/80/v2-e50b42db395f2d41068c28d054103e45_720w.webp"></p><p><strong><code>innodb_flush_log_at_timeout</code>变量用于控制刷盘的频率</strong></p><blockquote><p>决定了刷新到文件的频率， 默认为<code>1s</code>一次</p></blockquote><p>上面的更新数据流程会变成下面这样：</p><blockquote><ol><li>将数据从磁盘中读取到内存中(<code>Buffer Pool</code>)</li><li>在内存中修改数据，产生脏页，将修改的数据记录到<code>redo log(redolog buffer)</code>里面，并更新内存（<code>Buffer Pool</code>）</li><li>根据<code>innodb_flush_log_at_trx_commit</code>变量和<code>innodb_flush_log_at_timeout</code>变量决定何时将更新的数据刷入磁盘</li></ol></blockquote><p><a href="https://blog.csdn.net/weixin_43213517/article/details/117457184">Mysql中的redo log</a></p><p>更新数据流程大概变成了这样：</p><p><img src="https://img-blog.csdnimg.cn/20210602222622679.png?x-oss-process=image,size_16,color_FFFFFF,t_70"></p><h2 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h2><p>对于<code>MySQL InnoDB</code>存储引擎而言，每次修改后，不仅需要记录<code>Redo Log</code>还需要记录<code>Bin Log</code>，而且这两个操作必须保证同时成功或者同时失败，否则就会造成数据不一致。为此<code>MySQL</code>引入两阶段提交。</p><p><img src="https://img-blog.csdnimg.cn/454d2349ea5540a78457e25dcadaea56.png"></p><h2 id="redo-log-和-binlog-有什么区别？"><a href="#redo-log-和-binlog-有什么区别？" class="headerlink" title="redo log 和 binlog 有什么区别？"></a><strong>redo log 和 binlog 有什么区别？</strong></h2><p>这两个日志有四个区别。</p><p><em>1、适用对象不同：</em></p><ul><li>binlog 是 MySQL 的 Server 层实现的日志，所有存储引擎都可以使用；</li><li>redo log 是 Innodb 存储引擎实现的日志；</li></ul><p><em>2、文件格式不同：</em></p><ul><li><p>binlog 有 3 种格式类型，分别是 STATEMENT（默认格式）、ROW、 MIXED，区别如下：</p></li><li><ul><li>STATEMENT：每一条修改数据的 SQL 都会被记录到 binlog 中（相当于记录了逻辑操作，所以针对这种格式， binlog 可以称为逻辑日志），主从复制中 slave 端再根据 SQL 语句重现。但 STATEMENT 有动态函数的问题，比如你用了 uuid 或者 now 这些函数，你在主库上执行的结果并不是你在从库执行的结果，这种随时在变的函数会导致复制的数据不一致；</li><li>ROW：记录行数据最终被修改成什么样了（这种格式的日志，就不能称为逻辑日志了），不会出现 STATEMENT 下动态函数的问题。但 ROW 的缺点是每行数据的变化结果都会被记录，比如执行批量 update 语句，更新多少行数据就会产生多少条记录，使 binlog 文件过大，而在 STATEMENT 格式下只会记录一个 update 语句而已；</li><li>MIXED：包含了 STATEMENT 和 ROW 模式，它会根据不同的情况自动使用 ROW 模式和 STATEMENT 模式；</li></ul></li></ul><ul><li>redo log 是物理日志，记录的是在某个数据页做了什么修改，比如对 XXX 表空间中的 YYY 数据页 ZZZ 偏移量的地方做了AAA 更新；</li></ul><p><em>3、写入方式不同：</em></p><ul><li>binlog 是追加写，写满一个文件，就创建一个新的文件继续写，不会覆盖以前的日志，保存的是全量的日志。</li><li>redo log 是循环写，日志空间大小是固定，全部写满就从头开始，<strong>保存未被刷入磁盘的脏页日志</strong>。</li></ul><p><em>4、用途不同：</em></p><ul><li>binlog 用于备份恢复、主从复制；</li><li>redo log 用于掉电等故障恢复。</li></ul><blockquote><p>如果不小心整个数据库的数据被删除了，能使用 redo log 文件恢复数据吗？</p></blockquote><p>不可以使用 redo log 文件恢复，只能使用 binlog 文件恢复。</p><p>因为 redo log 文件是循环写，是会边写边擦除日志的，只记录未被刷入磁盘的数据的物理日志，已经刷入磁盘的数据都会从 redo log 文件里擦除。</p><p>binlog 文件保存的是全量的日志，也就是保存了所有数据变更的情况，理论上只要记录在 binlog 上的数据，都可以恢复，所以如果不小心整个数据库的数据被删除了，得用 binlog 文件恢复数据。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL索引</title>
      <link href="/post/43a71ae4.html"/>
      <url>/post/43a71ae4.html</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL-索引"><a href="#MySQL-索引" class="headerlink" title="MySQL 索引"></a>MySQL 索引</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><blockquote><p><strong>将数据存储和索引放到了一块，找到了索引也就找到了数据</strong>。</p><p><code>ps</code>： <code>MySQL</code>的<code>InnoDB</code>引擎中，索引数据结构是B+树，主键索引叶子节点的值存储的就是MySQL的数据行，普通索引的叶子节点的值存储的是主键值。</p></blockquote><p>总结：</p><blockquote><ol><li><p>定义了主键，则该主键就是聚簇索引</p></li><li><p>未定义主键，第一个<code>not NULL unique</code>列是聚集索引</p></li><li><p>所有字段均可为<code>NULL</code>，<code>InnoDB</code>会创建一个隐藏的<code>row-id</code>作为聚集索引</p></li></ol></blockquote><h3 id="非聚簇索引"><a href="#非聚簇索引" class="headerlink" title="非聚簇索引"></a>非聚簇索引</h3><blockquote><p>以主键以外的列值作为键值构建的<code> B+</code> 树索引，我们称之为非聚集索引。</p><p>在<code>InnoDB</code>引擎中，一般一个表只能有一个聚簇索引，但可以有多个非聚簇索引，每一个非聚簇索引的叶子节点都存储了主键的值。</p></blockquote><h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><blockquote><p>索引列的值必须唯一，但允许有空值，且空值只能有一个</p></blockquote><h3 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h3><blockquote><p><code>MySQL5.7</code>版本之前只在<code>MyISAM</code>引擎上支持，全文索引可以在<code>Char</code>、<code>Varchar</code>、<code>Text</code>类型的列上创建。</p></blockquote><h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><blockquote><p>多列联合组成索引。</p></blockquote><p>最左前缀优先原则</p><blockquote><p>最左前缀原则（假设索引为a, b, c）</p><p>则有效索引为:</p><ul><li>a</li><li>a,b</li><li>a,b,c</li></ul></blockquote><h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><blockquote><p>查询字段中，索引 已经“覆盖了”我们的查询需求，我们称为覆盖索引。</p><p>举例： <code>select ID from T where k between 3 and 5</code>，<br>这时只需要查 ID 的值，而 ID 的值已经在 k 索引树上了，因此可以直接提供查询结果，不需要回表</p></blockquote><p>回表</p><blockquote><p>在<code>InnoDB</code>中，非聚簇索引的叶子节点上存储的值为主键的值，并不包含完整行的数据，</p><p>所以需要拿着主键的值，到主键索引树上去查询整行的数据，这个过程称为回表。</p></blockquote><h3 id="索引下推（Index-Condition-Pushdown）"><a href="#索引下推（Index-Condition-Pushdown）" class="headerlink" title="索引下推（Index Condition Pushdown）"></a>索引下推（Index Condition Pushdown）</h3><p>启用版本</p><blockquote><p><code>Mysql5.6</code>的版本上推出，用于优化查询。</p></blockquote><p>可通过下述配置关闭</p><blockquote><p><code>set optimizer_switch=&#39;index_condition_pushdown=off&#39;;</code></p></blockquote><p>优点</p><blockquote><p>索引条件下推优化可以减少存储引擎查询基础表的次数，也可以减少MySQL服务器从存储引擎接收数据的次数。</p></blockquote><p><strong>流程变化</strong></p><p>不使用<code>ICP</code></p><blockquote><ol><li><code>MySQL Server</code>发送查询请求到存储引擎（查询条件里包含索引条件）</li><li>存储引擎根据索引检索数据，将检索出的数据返回给<code>MySQL Server</code></li><li><code>MySQL Server</code>再根据条件筛选数据</li></ol></blockquote><p>使用<code>ICP</code></p><blockquote><ol><li><code>MySQL Server</code>发送查询请求到存储引擎（查询条件里包含索引条件），<strong>并将条件传递给存储引擎</strong></li><li>存储引擎根据索引检索数据，将符合条件的数据返回给<code>MySQL Server</code></li><li><code>MySQL Server</code>不需要根据索引字段再筛选了</li></ol></blockquote><p>适用场景</p><blockquote><ol><li><p>当需要整表扫描</p></li><li><p>适用<code>InnoDB</code>引擎和<code>MyISAM</code>引擎查询，5.6版本不适用分区查询，5.7版本可以用于分区表查询</p></li><li><p><code>InnoDB</code>引擎仅仅适用二级索引(即非聚簇索引)，原因： <code>InnoDB</code>聚簇索引将整行数据读到<code>InnoDB</code>缓冲区</p></li></ol></blockquote><p>不能使用索引下推的情况</p><blockquote><ol><li>子查询条件不能下推</li><li>调用存储过程条件不能下推</li><li>触发条件不能下推（这个不太明白）</li></ol></blockquote><h2 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h2><blockquote><ol><li>使用 <code>like</code> 关键字， 且 <code>%</code> 在前面</li><li>联合索引不符合最左前缀原则</li><li><code>or</code> 语句前后没有同时使用索引。当 <code>or</code> 左右查询字段只有一个是索引，该索引失效</li><li>数据类型出现隐式转化，如<code>varchar</code>不加单引号的话可能会自动转换为<code>int</code>型，使索引无效，产生全表扫描</li><li>在索引字段上使用<code>not</code>，<code>&lt;&gt;</code>，<code>!=</code>， 只会产生全表扫描</li><li>对索引字段进行计算操作、字段上使用函数</li><li>当全表扫描速度比索引速度快时，<code>MySQL</code>会使用全表扫描，此时索引失效</li></ol></blockquote><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><blockquote><ol><li>索引大大减小了服务器需要扫描的数据量，从而大大加快数据的检索速度</li><li>索引可以帮助服务器避免排序和创建临时表</li><li>索引可以将随机<code>IO</code>变成顺序<code>IO</code></li><li>索引对于<code>InnoDB</code>（对索引支持行级锁）非常重要，因为它可以让查询锁更少的元组，提高了表访问并发性</li><li>关于<code>InnoDB</code>、索引和锁：<code>InnoDB</code>在二级索引上使用共享锁（读锁），但访问主键索引需要排他锁（写锁）</li></ol></blockquote><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><blockquote><ol><li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加</li><li>对表进行增删改时，数据库本身会增加一个对索引维护的步骤，所以效率会受到影响</li></ol></blockquote><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>特点</p><p>在<code>InnoDB</code>引擎中，</p><blockquote><ul><li><p>采用除法散列函数</p></li><li><p>解决冲突机制采用链表法</p></li></ul></blockquote><p>自适应哈希索引</p><blockquote><p>在<code>InnoDB</code>引擎中，<strong>用户无法手动创建哈希索引</strong>。</p><p><code>InnoDB</code>会自调优(<code>self-tuning</code>)，如果判定建立自适应哈希索引(<code>Adaptive Hash Index, AHI</code>)，能够提升查询效率，**<code>InnoDB</code>自己会建立相关哈希索引**。</p><p><code>key</code>是索引键值（或者键值前缀）。</p><p><code>value</code>是索引记录页面位置。</p></blockquote><p>优点</p><blockquote><p>检索效率非常高，索引的检索可以一次定位</p></blockquote><p>缺点</p><blockquote><ol><li><code>Hash</code>索引仅仅能满足<code>=</code>、<code>in()</code>、<code>!=</code>，不支持范围查询</li><li><code>Hash</code>索引无法被用来避免数据的排序操作</li><li><code>Hash</code>索引不能利用部分索引键查询通过组合索引的前面一个或几个索引键进行查询的时候，<code>Hash</code>索引也无法被利用</li><li><code>Hash</code>索引在任何时候都不能避免表扫描，由于不同索引键存在相同<code>Hash</code>值，所以即使取满足某个<code>Hash</code>键值的数据的记录条数，也无法从<code>Hash</code>索引中直接完成查询，还是要通过访问表中的实际数据进行相应的比较，并得到相应的结果。</li><li><code>Hash</code>索引遇到大量<code>Hash</code>值相等的情况后性能并不一定就会比<code>BTree</code>索引高</li></ol></blockquote><h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><p>特点</p><ul><li>每个节点包含了索引值和表记录的信息</li><li>叶节点具有相同的深度</li><li>叶子节点的指针为空</li><li>节点中的数据<code>key</code>从左到右递增排列</li></ul><p>优点</p><blockquote><p><code>BTree</code>的结构可以弥补红黑树的缺点，解决数据量过大时整棵树高度过大的问题，<br>相同的数据量只需要更少的层，相同的深度可以存储更多的数据，查找效率更高。</p></blockquote><p>缺点</p><blockquote><p>在查询单条数据是很快的，但是如果范围查询的话，<code>BTree</code>结构每次都需要从根节点查询一遍，会影响效率;</p><p>读取索引数据时，会连带着将整行数据加载进内存，占用更多的内存</p></blockquote><h3 id="B-树"><a href="#B-树" class="headerlink" title="B+ 树"></a>B+ 树</h3><p>特点</p><blockquote><ol><li>非叶子节点不存储数据，只存储<code>key</code>（索引值），会有冗余</li><li>叶子节点存储数据，包含行所有字段</li><li>叶子节点用指针连接（双向）-便于范围查找，提高区间访问的性能</li></ol></blockquote><p> 优点</p><blockquote><ol><li>顺序访问指针，提高区间访问的性能</li><li>层高不会太高，查询速度快</li></ol></blockquote><h2 id="为什么采用B-树，而不是B树"><a href="#为什么采用B-树，而不是B树" class="headerlink" title="为什么采用B+树，而不是B树"></a>为什么采用B+树，而不是B树</h2><p>在操作系统中有个叫“<strong>页</strong>”的概念，是用来存储数据的一种单位，大小为<code>4k</code>。<code>MySQL</code>中也有“页”的概念，但大小为<code>16k</code>，你可以理解为<code>MySQL</code>中的“页”就是上面<code>B</code>树的一个个节点。</p><p>为了尽可能使索引树“变矮”从而减少磁盘<code>IO</code>，最好的做法是让<strong>一个节点尽可能地塞入更多的数据。</strong></p><p><strong>所谓的B+树，就是把原先B树中分散在各个节点的数据都“赶到”最底层的叶子节点，非叶子节点只存储主键-addr形式的数据</strong></p><p>这样每个非叶子节点，能存储的主键就变多了，整棵索引树就变矮了，磁盘<code>IO</code>自然也就减少了。</p><blockquote><p>并且<code>B+</code>树查询效率是稳定的，每次查询一定都要查询到叶子节点才可以获取到数据。</p><p><code>B</code>树的查询效率是不稳定的，最好情况是根节点，最差情况是叶子节点。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础架构</title>
      <link href="/post/b3cb123.html"/>
      <url>/post/b3cb123.html</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL基础架构"><a href="#MySQL基础架构" class="headerlink" title="MySQL基础架构"></a>MySQL基础架构</h1><blockquote><p><code>MySQL</code>大致可以分为客户端层、<code>Server</code>层和存储引擎两层。</p><p><code>Server </code>层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 <code>MySQL</code> 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</p><p>存储引擎层负责数据的存储和提取。其架构模式是<strong>插件式</strong>的，支持 <code>InnoDB</code>、<code>MyISAM</code>、<code>Memory</code> 等多个存储引擎。现在最常用的存储引擎是<code>InnoDB</code>，它从 <code>MySQL 5.5.5</code> 版本开始成为了默认存储引擎。</p><p><strong>不同的存储引擎，是共用同一个<code>Server</code>层的。</strong></p></blockquote><p>组件关系图如下：</p><p><img src="https://hawk-note-image.oss-cn-shenzhen.aliyuncs.com/mysql/mysql_bootstrap.png"></p><h2 id="客户端层"><a href="#客户端层" class="headerlink" title="客户端层"></a>客户端层</h2><blockquote><p>用户访问<code>MySQL</code>的接口。在客户端，用户可以输入<code>SQL</code>语句，通过<code>SQL</code>语句，实现对数据库的访问、操作和控制。</p></blockquote><h2 id="MySQL-Server-层"><a href="#MySQL-Server-层" class="headerlink" title="MySQL Server 层"></a>MySQL Server 层</h2><h3 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h3><blockquote><p>连接器负责跟客户端建立连接、获取权限、维持和管理连接。</p></blockquote><p>注意点：</p><blockquote><ol><li>连接器在用户登录时读取用户权限<strong>并用于后续判断，</strong>所以管理员修改密码对已登录用户无效（除非该用户重新登录）</li><li>客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数 <code>wait_timeout</code> 控制的，默认值是 8 小时</li></ol></blockquote><h3 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h3><blockquote><p>把查询到的结果缓存并返回（<code>KV</code>结构，<code>Key</code>：<code>select</code>语句的<code>hash</code>值，<code>Value</code>：查询结果）。</p><p>但<code>MySQL</code>缓存机制有个弊端，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。如此一来，对于更新频繁的表来说，缓存命中率会非常低！<code>MySQL 8.0 </code>版本直接将查询缓存的整块功能移除了。</p></blockquote><h3 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h3><blockquote><p>对一条<code>SQL</code>进行词法分析、语法分析。也就是准确识别<code>select</code>/<code>update</code>/<code>insert</code>/<code>delete</code>、表名、字段名以及各种条件，并对<code>SQL</code>的语法进行校验。</p></blockquote><h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><blockquote><p>优化器会对执行的<code>SQL</code>进行优化，主要有：</p><ol><li><p>表里面有多个索引的时候，决定使用哪个索引</p></li><li><p>在一个语句有多表关联（<code>join</code>）的时候，决定各个表的连接顺序</p></li></ol></blockquote><h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><blockquote><p>执行器负责调用存储引擎，返回结果，主要有以下几个步骤</p><ol><li>权限校验（连接器阶段已经读取权限，这里只要校验当前用户是否拥有操作这张表的权限）</li><li>选择引擎</li><li>调用引擎提供的接口</li></ol></blockquote><h2 id="存储引擎层"><a href="#存储引擎层" class="headerlink" title="存储引擎层"></a>存储引擎层</h2><blockquote><p>存储引擎层负责数据的存储和提取。其架构模式是<strong>插件式</strong>的，支持 <code>InnoDB</code>、<code>MyISAM</code>、<code>Memory</code> 等多个存储引擎。现在最常用的存储引擎是<code>InnoDB</code>，它从 <code>MySQL 5.5.5</code> 版本开始成为了默认存储引擎。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL锁</title>
      <link href="/post/d940f18d.html"/>
      <url>/post/d940f18d.html</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL锁"><a href="#MySQL锁" class="headerlink" title="MySQL锁"></a>MySQL锁</h1><p>[TOC]</p><hr><h2 id="按照锁思想分类"><a href="#按照锁思想分类" class="headerlink" title="按照锁思想分类"></a>按照锁思想分类</h2><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><blockquote><p>需要应用程序实现，<code>MySQL</code>自身并未实现。</p></blockquote><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><h2 id="按照锁类型分类"><a href="#按照锁类型分类" class="headerlink" title="按照锁类型分类"></a>按照锁类型分类</h2><h3 id="读锁（共享锁、S锁）"><a href="#读锁（共享锁、S锁）" class="headerlink" title="读锁（共享锁、S锁）"></a>读锁（共享锁、S锁）</h3><blockquote><ol><li>加了读锁的事务，允许该事务进行读，不允许其他事务进行修改</li><li>同一行数据，可以被多个事务获得读锁</li><li>其他事务不能再获取写锁，只能等获得读锁的所有事务释放后，才能加写锁</li></ol></blockquote><h3 id="写锁（排他锁、X锁）"><a href="#写锁（排他锁、X锁）" class="headerlink" title="写锁（排他锁、X锁）"></a>写锁（排他锁、X锁）</h3><blockquote><ol><li>一个事务获取了写锁，那么该事务可以进行数据的查看及修改</li><li>在该事务提交（释放锁）之前，不允许其他事务对该数据进行读操作或者写操作，会被阻塞住</li><li>即添加了写锁之后，只允许拥有该锁的事务进行读、写</li></ol></blockquote><h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><blockquote><ol><li>意向锁的主要用途是显示某人正在锁定一行，或者将要锁定表中的一行</li><li>想获取读锁或者写锁，必须先获取意向锁</li><li>申请意向锁的动作是数据库自动完成的</li></ol></blockquote><h4 id="意向共享锁（IS-Lock）"><a href="#意向共享锁（IS-Lock）" class="headerlink" title="意向共享锁（IS Lock）"></a>意向共享锁（IS Lock）</h4><h4 id="意向排他锁（IX-Lock）"><a href="#意向排他锁（IX-Lock）" class="headerlink" title="意向排他锁（IX Lock）"></a>意向排他锁（IX Lock）</h4><h2 id="按照锁级别分类"><a href="#按照锁级别分类" class="headerlink" title="按照锁级别分类"></a>按照锁级别分类</h2><h3 id="全局锁（数据库级别）"><a href="#全局锁（数据库级别）" class="headerlink" title="全局锁（数据库级别）"></a>全局锁（数据库级别）</h3><blockquote><p><code>FTWRL</code>主要包括3个步骤：</p><ol><li>上全局读锁(<code>lock_global_read_lock</code>)</li><li>清理表缓存(<code>close_cached_tables</code>)</li><li>上全局<code>COMMIT</code>锁(<code>make_global_read_lock_block_commit</code>)</li></ol></blockquote><h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><blockquote><ol><li><p>上全局读锁会导致所有更新操作都会被堵塞；关闭表过程中，如果有大查询导致关闭表等待，那么所有访问这个表的查询和更新都需要等待；</p></li><li><p>上全局<code>COMMIT</code>锁时，会堵塞活跃事务提交。</p></li></ol></blockquote><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加锁：flush tables with read lock</span></span><br><span class="line"><span class="comment">// 执行后整个数据库将处于只读状态</span></span><br><span class="line"><span class="comment">// 解锁： unlock tables</span></span><br></pre></td></tr></table></figure><h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>表锁不是由<code>InnoDB</code>存储引擎层管理的，而是由其上一层──<code>MySQL Server</code>负责的。</p><blockquote><p>ps:  仅当<code>autocommit=0</code>、<code>InnoDB_table_locks = 1</code>（默认设置）时，<code>InnoDB</code>层才能知道<code>MySQL</code>加的表锁，</p><p><code>MySQL Server</code>也才能感知<code>InnoDB</code>加的行锁，这种情况下，<code>InnoDB</code>才能自动识别涉及表级锁的死锁，否则，<code>InnoDB</code>将无法自动检测并处理这种死锁。</p></blockquote><blockquote><p>在用<code> LOCK TABLES</code>对<code>InnoDB</code>表加锁时要注意，要将<code>AUTOCOMMIT</code>设为<code>0</code>，否则<code>MySQL</code>不会给表加锁；<br>事务结束前，不要用<code>UNLOCK TABLES</code>释放表锁，因为<code>UNLOCK TABLES</code>会隐含地提交事务；<br><code>COMMIT</code>或<code>ROLLBACK</code>并不能释放用<code>LOCK TABLES</code>加的表级锁，必须用<code>UNLOCK TABLES</code>释放表锁。</p></blockquote><h4 id="意向锁-1"><a href="#意向锁-1" class="headerlink" title="意向锁"></a>意向锁</h4><blockquote><ol><li>意向锁的主要用途是显示某人正在锁定一行，或者将要锁定表中的一行</li><li>想获取读锁或者写锁，必须先获取意向锁</li><li>申请意向锁的动作是数据库自动完成的</li></ol></blockquote><h4 id="自增锁"><a href="#自增锁" class="headerlink" title="自增锁"></a>自增锁</h4><p><code>Innodb_autoinc_lock_mode</code>变量控制用于<strong>自动增量</strong>锁定的算法。它允许您选择如何在可预测的自动增量值序列和插入操作的最大并发性之间进行权衡。</p><p>该变量有三个可选值：<code>0</code>、<code>1</code>、<code>2</code>。</p><h5 id="传统模式（0）"><a href="#传统模式（0）" class="headerlink" title="传统模式（0）"></a>传统模式（0）</h5><blockquote><ol><li><p>所有的<code>insert </code>都会获得一个自增锁</p></li><li><p><code>insert</code>执行结束后就立即释放自增锁，不必等待事务结束</p></li></ol></blockquote><h5 id="连续模式（1）"><a href="#连续模式（1）" class="headerlink" title="连续模式（1）"></a>连续模式（1）</h5><blockquote><ol><li><p>像执行<code>INSERT INTO</code>这样的语句时，可以提前知道要插入的数量</p></li><li><p>使用<code>mutex</code>轻量级锁，分配完毕就释放</p></li></ol></blockquote><h5 id="交叉模式（2）"><a href="#交叉模式（2）" class="headerlink" title="交叉模式（2）"></a>交叉模式（2）</h5><blockquote><ol><li>执行 <code>INSERT </code>和<code>INSERT INTO ... SELECT</code>无法预知插入的数量的情况</li><li>使用较为轻量的 <code>mutex</code> 锁</li><li><del>主从复制时， <code>binlog</code>必须为<code>Row</code>模式，如果是<code>statement</code>模式的话，可能会出现数据不一致</del>【<strong>待考证</strong>，有另一种说法见<a href="https://zhuanlan.zhihu.com/p/376811677">深入剖析 MySQL 自增锁</a>评论区】</li></ol></blockquote><h5 id="注意点-1"><a href="#注意点-1" class="headerlink" title="注意点"></a>注意点</h5><blockquote><p><code>5.1.22</code>版本及之前， 默认为 –&gt; 传统模式</p><p><code>MySQL 8.0 </code>之前，<code>InnoDB</code> 锁模式默认 –&gt; 连续模式</p><p><code>MySQL 8.0</code> 之后，默认模式 –&gt; 交叉模式</p></blockquote><h3 id="扩展（MyISAM表锁）"><a href="#扩展（MyISAM表锁）" class="headerlink" title="扩展（MyISAM表锁）"></a>扩展（<code>MyISAM</code>表锁）</h3><p><code>MyISAM</code>存储引擎只支持表锁，同时<code>MyISAM</code>不会出现死锁（下面会解释）。</p><h4 id="查询MyISAM表级锁争用情况"><a href="#查询MyISAM表级锁争用情况" class="headerlink" title="查询MyISAM表级锁争用情况"></a>查询<code>MyISAM</code>表级锁争用情况</h4><blockquote><p>通过<code>show status like &#39;table%&#39;;</code>， 查看<code>table_locks_waited</code>、<code>table_locks_immediate</code>状态变量，若<code>table_locks_waited</code>变量的值较高，则说明存在较严重的表级锁争抢情况。</p></blockquote><h4 id="DeadLock-Free"><a href="#DeadLock-Free" class="headerlink" title="DeadLock Free"></a><code>DeadLock Free</code></h4><blockquote><p><code>MyISAM</code>在执行<code>lock tables</code>时，必须同时取得所有涉及表的表锁，并且<code>MySQL</code>不支持锁升级；所以<code>MyISAM</code>中不会出现死锁。</p></blockquote><h4 id="MyISAM并发插入"><a href="#MyISAM并发插入" class="headerlink" title="MyISAM并发插入"></a><code>MyISAM</code>并发插入</h4><blockquote><p><code>MyISAM</code>表不支持<code>MVCC</code>。</p><p><code>MyISAM</code>表的读操作与写操作，以及写操作之间是串行的。</p></blockquote><p><code>concurrent_insert</code>变量。</p><blockquote><p>当<code>concurrent_insert=0</code>时，不允许并发插入功能。</p><p>当<code>concurrent_insert=1</code>时，允许对没有空洞的表使用并发插入，新数据位于数据文件结尾(<strong>默认</strong>)。</p><p>当<code>concurrent_insert=2</code>时，不管表有没有空洞，都允许在数据文件结尾并发插入。</p></blockquote><blockquote><p><strong>空洞</strong>：表的中间有被删除的行，空出来的那一行。</p></blockquote><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><blockquote><p><code>MyISAM</code>表的读操作与写操作，以及写操作之间是串行的。</p><p>并且默认情况下写操作命令的执行优先于读操作执行，即使读请求早于写请求到达，写锁也会插队到读请求前面，因为<code>MySQL</code>认为写请求一般比读请求要重要。</p><p>这也导致了有大量的并发更新操作时，读请求很有可能被阻塞。</p><p>可以通过这些方法解决：</p><ol><li><p>通过指定启动参数<code>low-priority-updates</code>，使<code>MyISAM</code>引擎默认给予读请求以优先的权利。</p></li><li><p>通过执行命令<code>SET LOW_PRIORITY_UPDATES=1</code>，使该连接发出的更新请求优先级降低。</p></li><li><p>通过指定<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>语句的<code>LOW_PRIORITY</code>属性，降低该语句的优先级。</p></li></ol></blockquote><h3 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h3><p><strong><code>InnoDB</code>行锁是通过给索引项加锁来实现的，如果没有索引，<code>InnoDB</code>将通过隐藏的聚簇索引来对记录加锁。</strong></p><h4 id="排他锁、共享锁"><a href="#排他锁、共享锁" class="headerlink" title="排他锁、共享锁"></a>排他锁、共享锁</h4><p>在获取排他锁之前，<code>InnoDB</code>会自动申请该表的意向排他锁，不需要用户手动处理。<br>对于<code>update</code>、<code>delete</code>和<code>insert</code>语句，<code>InnoDB</code>会自动给涉及到的数据行加排他锁；<br>对于普通的<code>select</code>语句，<code>InnoDB</code>不会加任何锁。<br>事务可以通过以下语句显式给数据行加共享锁或排他锁。</p><p><code>MySQL5.7</code></p><blockquote><p>共享锁：<code>select * from table_name where ... lock in share mode</code><br>排他锁：<code>select * from table_name where ... for update</code></p></blockquote><p><code>MySQL8.0</code></p><blockquote><p>共享锁：<code>select * from table_name where ... for share</code><br>排他锁：<code>select * from table_name where ... for update [nowait | skip locked]</code></p></blockquote><p><code>MySQL8.0</code>向下兼容，支持<code>MySQL5.7</code>的语法。<br><code>MySQL5.7</code>中的排他锁，如果遇到锁等待，那么<code>session</code>默认会等待<code>50s</code>，在高并发系统中，一旦出现对热点行的争用，<br>将会造成连接数的快速增加，甚至超过最大连接数。<br>所以在<code>MySQL8.0</code>中，增加了两个可选参数<code>nowait</code>、<code>skip locked</code>。</p><blockquote><p><code>nowait</code>: 发现有锁等待后，会立即返回错误，不用等到锁超时后报错<br><code>skip locked</code>: 跳过被锁定的行，直接更新其他行，这样可能会造成更新结果不符合预期</p></blockquote><h4 id="InnoDB行锁的实现方式"><a href="#InnoDB行锁的实现方式" class="headerlink" title="InnoDB行锁的实现方式"></a><code>InnoDB</code>行锁的实现方式</h4><p><code>InnoDB</code>行锁是通过给索引上的索引项加锁来实现的，如果没有索引，<code>InnoDB</code>将通过隐藏的聚簇索引来对记录加锁。</p><blockquote><p><code>InnoDB</code>这种行锁的实现特点导致了， 如果<strong>在加锁的时候不通过索引条件查询数据，那么<code>InnoDB</code>将对表中所有的记录加行锁，实际效果和表锁一样。</strong></p></blockquote><p><code>InnoDB</code>行锁是通过给索引上的索引项加锁来实现的，而不是针对记录加的锁，所以虽然是访问不同行的记录，<strong>如果索引项的值是相同的话，也是会出现锁冲突的。</strong></p><p>当表有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行，不论是使用主键索引、唯一索引还是普通索引，<code>InnoDB</code>都会使用行锁来给数据加锁。</p><h4 id="Record-Lock（记录锁）"><a href="#Record-Lock（记录锁）" class="headerlink" title="Record Lock（记录锁）"></a>Record Lock（记录锁）</h4><blockquote><p>数据行上加锁。</p></blockquote><h4 id="Gap-Lock（间隙锁）、"><a href="#Gap-Lock（间隙锁）、" class="headerlink" title="Gap Lock（间隙锁）、"></a>Gap Lock（间隙锁）、</h4><blockquote><ol><li>只有在可重复读、串行化隔离级别才有该锁</li><li>锁定范围空间的数据（范围条件、相等条件查询不存在的记录时）</li></ol></blockquote><p>举例：</p><blockquote><p>假设id有3,4,5，锁定id&gt;3的数据，是指的4，5及后面的数字都会被锁定</p></blockquote><blockquote><p>对于没有索引的列，当前读操作时，会加全表间隙锁。</p><p>非唯一索引列，如果where条件部分命中(&gt;、&lt;、like等)或者全未命中，则会加附近Gap间隙锁</p></blockquote><p>举例：</p><blockquote><p>某表数据如下，非唯一索引2,6,9,11,15。<br>执行<code>delete from table where t_id = 9</code>;<br>gap锁将会锁定的列是<code>(6,11]</code>，该区间内无法插入数据。</p></blockquote><h4 id="Next-Key-Lock（临键锁）"><a href="#Next-Key-Lock（临键锁）" class="headerlink" title="Next Key Lock（临键锁）"></a>Next Key Lock（临键锁）</h4><blockquote><p>Record Lock + Gap Lock</p></blockquote><h4 id="Insert-Intention-Lock（插入意向锁）"><a href="#Insert-Intention-Lock（插入意向锁）" class="headerlink" title="Insert Intention Lock（插入意向锁）"></a>Insert Intention Lock（插入意向锁）</h4><p>是间隙锁的一种。</p><blockquote><p>插入意向锁不会阻止任何锁，对于插入的记录会持有一个Record Lock</p><p>假设有一个记录索引包含键值<code>4</code>和<code>7</code>，不同的事务分别插入<code>5</code>和<code>6</code>，每个事务都会产生一个加在<code>4-7</code>之间的插入意向锁，<br>获取在插入行上的排它锁，但是不会被互相锁住，因为数据行并不冲突。</p></blockquote><h3 id="页锁"><a href="#页锁" class="headerlink" title="页锁"></a>页锁</h3><blockquote><p>比表锁并发高，比行锁并发低。</p><p><code>BDB</code>存储引擎支持，<code>5.1</code>版本之后就被弃用。</p></blockquote><h2 id="按照加锁方式分类"><a href="#按照加锁方式分类" class="headerlink" title="按照加锁方式分类"></a>按照加锁方式分类</h2><h3 id="自动加锁（隐式加锁）"><a href="#自动加锁（隐式加锁）" class="headerlink" title="自动加锁（隐式加锁）"></a>自动加锁（隐式加锁）</h3><h4 id="DML语句"><a href="#DML语句" class="headerlink" title="DML语句"></a>DML语句</h4><blockquote><p>自动获得所需要的表级锁和行级锁</p></blockquote><h4 id="DDL语句"><a href="#DDL语句" class="headerlink" title="DDL语句"></a>DDL语句</h4><h5 id="排他锁"><a href="#排他锁" class="headerlink" title="排他锁"></a>排他锁</h5><blockquote><p>创建、修改、删除一个数据库对象的 <code>DDL</code> 语句获得操作对象的 排它锁</p></blockquote><h5 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h5><blockquote><p>需在数据库对象之间建立相互依赖关系的 <code>DDL</code> 语句通常需共享获得 <code>DDL</code>锁</p></blockquote><h3 id="显式加锁"><a href="#显式加锁" class="headerlink" title="显式加锁"></a>显式加锁</h3><h5 id="LOCK-TABLES"><a href="#LOCK-TABLES" class="headerlink" title="LOCK TABLES"></a>LOCK TABLES</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LOCK TABLES  tbl_name  read<span class="operator">|</span>write, tbl_name read<span class="operator">|</span>write, ...  # 手动加表锁</span><br><span class="line"></span><br><span class="line">UNLOCK TABLES  # 解开该事务全部的锁，后面不跟表名，必须在事务提交之后再执行，此操作会隐式的提交事务</span><br></pre></td></tr></table></figure><h5 id="FLUSH-TABLES"><a href="#FLUSH-TABLES" class="headerlink" title="FLUSH TABLES"></a>FLUSH TABLES</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FLUSH TABLES tbl_name,... [<span class="keyword">WITH</span> READ LOCK];</span><br></pre></td></tr></table></figure><h2 id="Two-Phase-Locking-2PL，两阶段锁定"><a href="#Two-Phase-Locking-2PL，两阶段锁定" class="headerlink" title="Two-Phase Locking(2PL，两阶段锁定)"></a>Two-Phase Locking(2PL，两阶段锁定)</h2><h3 id="加锁阶段"><a href="#加锁阶段" class="headerlink" title="加锁阶段"></a>加锁阶段</h3><blockquote><p>事务开始时处于加锁阶段，此时只允许加锁，不允许解锁；并且所有加锁操作必须在解锁操作之前。</p></blockquote><h3 id="解锁阶段"><a href="#解锁阶段" class="headerlink" title="解锁阶段"></a>解锁阶段</h3><blockquote><p>事务<code>commit</code>或者<code>rollback</code>时，进入解锁阶段，此阶段只允许解锁，不允许加锁。</p></blockquote><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><blockquote><p><code>Basic 2PL</code>(基本<code>2PL</code>):  在事务过程中，分为获得锁和释放锁两个阶段</p><p><code>Strict 2PL</code>(严格<code>2PL</code>):  直到事务结束为止，都不释放获得的锁</p><p><code>Static 2PL</code>(静态<code>2PL</code>):  在事务开始前，获得所需的全部锁</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><ol><li><strong>加锁和解锁操作不能交叉执行（同一个事务内）</strong></li><li><strong>加锁总是优先于解锁</strong></li><li><strong><code>2PL</code>并不能够避免死锁，只是用来防止并发事务对数据的干扰</strong></li></ol></blockquote><p> 参考：<a href="https://www.bookstack.cn/read/aliyun-rds-core/2a01f200518fbdb0.md">数据库系统 · 事物并发控制 · Two-phase Lock Protocol</a></p><h3 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h3><blockquote><p><code>MySQL</code> 在开始某个事务的时候，会隐式提交上一个事务。所以 <code>MySQL</code> 本身是不支持事务嵌套的。</p><p>但 <code>MySQL</code> 也给我们提供了一个 <code>SAVEPOINT</code> 来做出类似事务嵌套的动作。</p></blockquote><p>参考：<a href="https://blog.csdn.net/github_35780607/article/details/115630361">MySQL事务嵌套</a></p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="关于死锁"><a href="#关于死锁" class="headerlink" title="关于死锁"></a>关于死锁</h3><blockquote><p><code>MyISAM</code>是<code>DeadLock Free</code>的，因为它总是一次获取整个事务需要的资源，要么全部满足，要么等待。</p><p>在<code>InnoDB</code>中，除了单个<code>SQL</code>组成的事务外，锁是逐步获取的，所以会出现死锁。</p></blockquote><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><blockquote><p>一般情况下，发生死锁后，<code>InnoDB</code>都能够检测到死锁，并使一个事务释放锁并回退，另一个事务获得锁，继续完成事务。</p><p>但在涉及外部锁或者涉及表锁的情况下，<code>InnoDB</code>并不能完全自动检测到死锁，这个时候，可以设置锁等待超时参数<code>innodb_lock_wait_timeout</code>，降低锁等待时间，尽快失败，避免高并发时数据库性能问题。</p></blockquote><h3 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h3><blockquote><ul><li>合理划分事务大小</li><li>在代码中理清表之间的资源关系，避免形成互相等待资源的局面</li><li>在事务中，如果要更新记录，应直接申请足够级别的锁，而不是先申请共享锁，等到更新时再申请排他锁</li></ul></blockquote><h3 id="wait-for-graph（死锁检测机制）"><a href="#wait-for-graph（死锁检测机制）" class="headerlink" title="wait-for graph（死锁检测机制）"></a>wait-for graph（死锁检测机制）</h3><h4 id="死锁的必要条件"><a href="#死锁的必要条件" class="headerlink" title="死锁的必要条件"></a>死锁的必要条件</h4><blockquote><ol><li>多个并发事务（2个或者以上）；</li><li>每个事务都持有锁（或者是已经在等待锁）；</li><li>每个事务都需要再继续持有锁（为了完成事务逻辑，还必须更新更多的行）；</li><li>事务之间产生加锁的循环等待，形成死锁。</li></ol></blockquote><h4 id="wait-for-graph-算法"><a href="#wait-for-graph-算法" class="headerlink" title="wait-for graph 算法"></a>wait-for graph 算法</h4><blockquote><p><code>InnoDB</code>将各个事务看为一个个节点，资源就是各个事务占用的锁，当事务<code>1</code>需要等待事务<code>2</code>的锁时，就生成一条有向边从<code>1</code>指向<code>2</code>，最后行成一个有向图。</p><p>我们只要检测这个有向图是否出现环路即可，出现环路就是死锁！这就是<code>wait-for graph </code>算法。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL优化笔记（MySQL）</title>
      <link href="/post/9ae99909.html"/>
      <url>/post/9ae99909.html</url>
      
        <content type="html"><![CDATA[<h1 id="SQL优化笔记（MySQL）"><a href="#SQL优化笔记（MySQL）" class="headerlink" title="SQL优化笔记（MySQL）"></a>SQL优化笔记（MySQL）</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ol><li><strong>减少IO次数</strong></li><li><strong>降低CPU的计算</strong></li></ol><h2 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h2><ol><li><strong>尽量少 join</strong></li></ol><p>　　MySQL 的优势在于简单，但这在某些方面其实也是其劣势。MySQL  优化器效率高，但是由于其统计信息的量有限，优化器工作过程出现偏差的可能性也就更多。对于复杂的多表 Join，一方面由于其优化器受限，再者在  Join 这方面所下的功夫还不够，所以性能表现离 Oracle  等关系型数据库前辈还是有一定距离。但如果是简单的单表查询，这一差距就会极小甚至在有些场景下要优于这些数据库前辈。</p><ol start="2"><li><strong>尽量少排序</strong></li></ol><p>　　排序操作会消耗较多的 CPU 资源，所以减少排序可以在缓存命中率高等 IO 能力足够的场景下会较大影响 SQL 的响应时间。</p><p>　　对于MySQL来说，减少排序有多种办法，比如：</p><p>　　上面误区中提到的通过利用索引来排序的方式进行优化</p><p>　　减少参与排序的记录条数</p><p>　　非必要不对数据进行排序</p><p>　　…</p><ol start="3"><li>**尽量避免 select ***</li></ol><p>　　很多人看到这一点后觉得比较难理解，上面不是在误区中刚刚说 select 子句中字段的多少并不会影响到读取的数据吗?</p><p>　　是的，大多数时候并不会影响到 IO 量，但是当我们还存在 order by 操作的时候，select 子句中的字段多少会在很大程度上影响到我们的排序效率，这一点可以通过我之前一篇介绍 MySQL ORDER BY 的实现分析的文章中有较为详细的介绍。</p><p>　　此外，上面误区中不是也说了，只是大多数时候是不会影响到 IO 量，当我们的查询结果仅仅只需要在索引中就能找到的时候，还是会极大减少 IO 量的。</p><ol start="4"><li><strong>尽量用 join 代替子查询</strong></li></ol><p>　　虽然 Join 性能并不佳，但是和 MySQL 的子查询比起来还是有非常大的性能优势。MySQL  的子查询执行计划一直存在较大的问题，虽然这个问题已经存在多年，但是到目前已经发布的所有稳定版本中都普遍存在，一直没有太大改善。虽然官方也在很早就承认这一问题，并且承诺尽快解决，但是至少到目前为止我们还没有看到哪一个版本较好的解决了这一问题。</p><ol start="5"><li><strong>尽量少 or</strong></li></ol><p>　　当 where 子句中存在多个条件以“或”并存的时候，MySQL 的优化器并没有很好的解决其执行计划优化问题，再加上 MySQL  特有的 SQL 与 Storage 分层架构方式，造成了其性能比较低下，很多时候使用 union all  或者是union(必要的时候)的方式来代替“or”会得到更好的效果。</p><ol start="6"><li><strong>尽量用 union all 代替 union</strong></li></ol><p>　　union 和 union all  的差异主要是前者需要将两个(或者多个)结果集合并后再进行唯一性过滤操作，这就会涉及到排序，增加大量的 CPU  运算，加大资源消耗及延迟。所以当我们可以确认不可能出现重复结果集或者不在乎重复结果集的时候，尽量使用 union all 而不是 union。</p><ol start="7"><li><strong>尽量早过滤</strong></li></ol><p>　　这一优化策略其实最常见于索引的优化设计中(将过滤性更好的字段放得更靠前)。</p><p>　　在 SQL 编写中同样可以使用这一原则来优化一些 Join 的  SQL。比如我们在多个表进行分页数据查询的时候，我们最好是能够在一个表上先过滤好数据分好页，然后再用分好页的结果集与另外的表  Join，这样可以尽可能多的减少不必要的 IO 操作，大大节省 IO 操作所消耗的时间。</p><ol start="8"><li><strong>避免类型转换</strong></li></ol><p>　　这里所说的“类型转换”是指 where 子句中出现 column 字段的类型和传入的参数类型不一致的时候发生的类型转换：</p><p>　　人为在column_name 上通过转换函数进行转换</p><p>　　直接导致 MySQL(实际上其他数据库也会有同样的问题)无法使用索引，如果非要转换，应该在传入的参数上进行转换</p><p>　　由数据库自己进行转换</p><p>　　如果我们传入的数据类型和字段类型不一致，同时我们又没有做任何类型转换处理，MySQL 可能会自己对我们的数据进行类型转换操作，也可能不进行处理而交由存储引擎去处理，这样一来，就会出现索引无法使用的情况而造成执行计划问题。</p><ol start="9"><li><strong>优先优化高并发的 SQL，而不是执行频率低某些“大”SQL</strong></li></ol><p>　　对于破坏性来说，高并发的 SQL 总是会比低频率的来得大，因为高并发的 SQL  一旦出现问题，甚至不会给我们任何喘息的机会就会将系统压跨。而对于一些虽然需要消耗大量 IO 而且响应很慢的  SQL，由于频率低，即使遇到，最多就是让整个系统响应慢一点，但至少可能撑一会儿，让我们有缓冲的机会。</p><ol start="10"><li><strong>从全局出发优化，而不是片面调整</strong></li></ol><p>　　SQL 优化不能是单独针对某一个进行，而应充分考虑系统中所有的 SQL，尤其是在通过调整索引优化 SQL 的执行计划的时候，千万不能顾此失彼，因小失大。</p><ol start="11"><li><strong>尽可能对每一条运行在数据库中的SQL进行 explain</strong></li></ol><p>　　优化 SQL，需要做到心中有数，知道 SQL 的执行计划才能判断是否有优化余地，才能判断是否存在执行计划问题。在对数据库中运行的  SQL 进行了一段时间的优化之后，很明显的问题 SQL 可能已经很少了，大多都需要去发掘，这时候就需要进行大量的 explain  操作收集执行计划，并判断是否需要进行优化。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL事务</title>
      <link href="/post/f91535f.html"/>
      <url>/post/f91535f.html</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL事务-InnoDB"><a href="#MySQL事务-InnoDB" class="headerlink" title="MySQL事务(InnoDB)"></a>MySQL事务(InnoDB)</h1><h2 id="事务的概念"><a href="#事务的概念" class="headerlink" title="事务的概念"></a>事务的概念</h2><p>事务就是一个不可分割的操作单元，其中的多个操作被认为是一个整体，要么全部执行成功，要么执行失败。</p><h2 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h2><p>通常来说，我们一般认为事务具有四个特性。</p><h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h3><blockquote><p>不同的事务之间，是互相隔离的，不会互相影响。</p><p>通过锁和<code>MVCC</code>来实现。</p></blockquote><h3 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h3><blockquote><p>一旦事务执行完成，那么对事务中影响到的数据的变化，是永久的，一般是指持久化到磁盘上或者日志文件中。</p><p>通过<code>redo log</code>来实现</p></blockquote><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><blockquote><p>一个事务中的多个操作，被认为是一个整体，不可再分割，只要其中一个操作执行失败，就认为整个事务执行失败了。</p><p>基于<code>undo log</code>。</p></blockquote><h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><blockquote><p>事务执行完成后，对于数据的变化，要求要一致。举例来说，转帐，A向B转账，B向C转账，在两个操作结束之后，数据结果要求一致。</p><p>通过回滚，以及恢复，和在并发环境下的隔离做到一致性，也就是基于上述的 <code>redo log</code>、<code>undo log</code>、<code>MVCC</code>等一起实现。</p></blockquote><h2 id="并发事务可能产生的问题"><a href="#并发事务可能产生的问题" class="headerlink" title="并发事务可能产生的问题"></a>并发事务可能产生的问题</h2><h3 id="数据丢失"><a href="#数据丢失" class="headerlink" title="数据丢失"></a>数据丢失</h3><blockquote><p>多个事务选择同一行数据进行更新，最后一个提交的事务所做的修改覆盖了前面其他事务提交的更新。</p></blockquote><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><blockquote><p>事务A可以读到事务B未<code>commit</code>的数据</p></blockquote><h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><blockquote><p>同一事务的其他实例在该实例处理其间可能会有新的<code>commit</code>，同一<code>select</code>可能返回不同结果, 查询结果的值有变化</p></blockquote><h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><blockquote><p>用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行， 查询结果行数变化。</p></blockquote><h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><p>事务隔离级别是一个标准，在不同的事务隔离级别下，对于事务特性的保证是有差异的，随之也会产生一些问题。</p><h3 id="读未提交"><a href="#读未提交" class="headerlink" title="读未提交"></a>读未提交</h3><p>不同的事务之间，会读到其他事务未提交的数据。保证了<strong>持久性</strong>、<strong>原子性</strong>，但是<strong>没有保证隔离性及一致性</strong>，会出现以下问题：</p><ul><li>脏读</li><li>幻读</li><li>不可重复读</li></ul><h3 id="读已提交"><a href="#读已提交" class="headerlink" title="读已提交"></a>读已提交</h3><p>不同事务之间，只会读取到其他事务提交的数据，解决了脏读的问题，但依然存在</p><ul><li>幻读</li><li>不可重复读</li></ul><h3 id="可重复读（MySQL默认的隔离级别）"><a href="#可重复读（MySQL默认的隔离级别）" class="headerlink" title="可重复读（MySQL默认的隔离级别）"></a>可重复读（MySQL默认的隔离级别）</h3><p>解决了不可重复读的问题，保证了同一事务中多次读取的数据是一样的。会存在</p><ul><li>幻读</li></ul><h3 id="串行化"><a href="#串行化" class="headerlink" title="串行化"></a>串行化</h3><p>不同的事务之间，不再具备并发能力，只能一个个排着队执行，解决了上述的问题，但性能极差。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github搭建Hexo双分支博客防止本地文件丢失</title>
      <link href="/post/6c408847.html"/>
      <url>/post/6c408847.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>转载于： <a href="https://www.jianshu.com/p/7d8df0de1fc7">Github搭建Hexo双分支博客防止本地文件丢失</a></p></blockquote><h1 id="一、关于搭建流程"><a href="#一、关于搭建流程" class="headerlink" title="一、关于搭建流程"></a>一、关于搭建流程</h1><ol><li><p>创建仓库，Godbn.github.io</p></li><li><p>创建两个分支:master和hexo</p></li><li><p>在options里面设置hexo为默认分支(注意这个分支保存的是网站源文件，并不是生成后上传github上用于显示的)</p></li><li><p>使用以下命令拷贝仓库到本地桌面</p></li></ol><blockquote><p>git clone <a href="mailto:&#103;&#x69;&#116;&#64;&#x67;&#x69;&#116;&#x68;&#x75;&#x62;&#46;&#99;&#111;&#109;">&#103;&#x69;&#116;&#64;&#x67;&#x69;&#116;&#x68;&#x75;&#x62;&#46;&#99;&#111;&#109;</a>:Godbn/Godbn.github.io.git</p></blockquote><ol start="5"><li>终端进入Godbn.github.io目录，依次执行</li></ol><blockquote><p>  npm install hexo</p><p>  hexo init</p><p>  npm install</p><p>  npm install hexo-deployer-git (用于生成上传至github)</p></blockquote><ol start="6"><li>修改_config.yml中的deploy参数</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/4797359-7085b85ebbfdd97d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/374/format/webp" alt="img"></p><ol start="7"><li>下载hexo themes主题自己百度安装调试好,我目前使用的是Sky，地址我贴出来</li></ol><blockquote><p><a href="https://github.com/iJinxin/hexo-theme-sky">https://github.com/iJinxin/hexo-theme-sky</a></p></blockquote><ol start="8"><li>依次执行以下三条命令提交网站相关的文件</li></ol><blockquote><p>git add .</p><p>git commit -m “…”</p><p>git push origin hexo</p></blockquote><ol start="9"><li>执行hexo g -d 生成网站并部署到github上 (每次可以在前面输入 hexo clean 清理下)</li></ol><blockquote><p>hexo clean</p><p>hexo g -d</p></blockquote><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><p><strong>分支hexo储存的是网站的原始文件</strong></p><p><strong>分支master用来储存生成的静态网页</strong></p><h1 id="二、日常改动"><a href="#二、日常改动" class="headerlink" title="二、日常改动"></a>二、日常改动</h1><h3 id="本地添加文章，样式等"><a href="#本地添加文章，样式等" class="headerlink" title="本地添加文章，样式等"></a>本地添加文章，样式等</h3><ol><li>依次执行以下命令git到分支hexo上</li></ol><blockquote><p>git add .</p><p>git commit -m “…”</p><p>git push origin hexo</p></blockquote><ol start="2"><li>再执行以下命令发布网站到分支master</li></ol><blockquote><p>hexo g -d</p></blockquote><h1 id="三、其他电脑更新github博客"><a href="#三、其他电脑更新github博客" class="headerlink" title="三、其他电脑更新github博客"></a>三、其他电脑更新github博客</h1><ol><li>使用命令将仓库拷贝到本地</li></ol><blockquote><p>git clone <a href="mailto:&#x67;&#x69;&#x74;&#64;&#x67;&#105;&#x74;&#104;&#x75;&#98;&#46;&#99;&#111;&#x6d;">&#x67;&#x69;&#x74;&#64;&#x67;&#105;&#x74;&#104;&#x75;&#98;&#46;&#99;&#111;&#x6d;</a>:Godbn/Godbn.github.io.git</p></blockquote><ol start="2"><li>在Godbn.github.io文件夹中通过以下恢复原始文件</li></ol><blockquote><p>npm install hexo</p><p>npm install</p><p>npm install hexo-deployer-git –save</p></blockquote><h1 id="四、结束"><a href="#四、结束" class="headerlink" title="四、结束"></a>四、结束</h1><p>以上是get到知乎上的回答搭建的</p><p>传送门：</p><blockquote><p><a href="https://www.zhihu.com/question/21193762">https://www.zhihu.com/question/21193762</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat概述</title>
      <link href="/post/b5f2cfa4.html"/>
      <url>/post/b5f2cfa4.html</url>
      
        <content type="html"><![CDATA[<h1 id="Tomcat概述"><a href="#Tomcat概述" class="headerlink" title="Tomcat概述"></a>Tomcat概述</h1><h2 id="1-Tomcat-核心组件"><a href="#1-Tomcat-核心组件" class="headerlink" title="1. Tomcat 核心组件"></a>1. Tomcat 核心组件</h2><p><img src="https://hawk-note-doc.oss-cn-shenzhen.aliyuncs.com/Java/tomcat/image/image-20220416104036286.png" alt="image-20220416104036286"></p><blockquote><p>Connector(连接器): 由 端口号 + 协议 组成。</p></blockquote><h2 id="2-核心组件协作过程"><a href="#2-核心组件协作过程" class="headerlink" title="2. 核心组件协作过程"></a>2. 核心组件协作过程</h2><p><img src="https://hawk-note-doc.oss-cn-shenzhen.aliyuncs.com/Java/tomcat/image/image-20220416104036286.png" alt="image-20220416104220796"></p><blockquote><p>要点：</p><ol><li>连接器可以有多个，不同的连接器可以对应同一个站点</li><li>同一个连接器下，可以有多个站点</li></ol><p>即，连接器和站点之间的关系是多对多的。</p><p>站点和应用上下文之间是一对多的关系，即一个站点对应该站点下多个应用上下文。站点和资源同样是一对多的关系</p></blockquote><h2 id="3-源码剖析"><a href="#3-源码剖析" class="headerlink" title="3. 源码剖析"></a>3. 源码剖析</h2><h3 id="3-1-server-xml"><a href="#3-1-server-xml" class="headerlink" title="3.1 server.xml"></a>3.1 server.xml</h3><p><img src="https://hawk-note-doc.oss-cn-shenzhen.aliyuncs.com/Java/tomcat/image/image-20220416111749492.png" alt="image-20220416111749492"></p><blockquote><p>Connector(连接器)：</p><ul><li>port：端口</li><li>protocol：协议</li></ul><p>Host(站点)：</p><ul><li>name: 域名</li><li>appBase：站点对应资源的路径，可配置全路径或者相对路径，相对路径是相对于tomcat的根路径。</li><li>unpackWARs：是否自动将WAR文件解压</li><li>autoDeploy：是否自动部署</li></ul></blockquote><p><img src="https://hawk-note-doc.oss-cn-shenzhen.aliyuncs.com/Java/tomcat/image/image-20220416130805986.png" alt="image-20220416130805986"></p><blockquote><p>Context(应用上下文): 在Host对应的appBase目录下的文件夹是隐式的Context， 通过Context标签可以显示的设置Host下的Context</p></blockquote><h3 id="3-2-请求流程分析"><a href="#3-2-请求流程分析" class="headerlink" title="3.2 请求流程分析"></a>3.2 请求流程分析</h3><p><img src="https://hawk-note-doc.oss-cn-shenzhen.aliyuncs.com/Java/tomcat/image/image-20220416131334951.png" alt="image-20220416131334951"></p><blockquote><p>Engine、Host、Context 每一层都有自己的一个pipline结构，里面包含多个Valve</p></blockquote><p><img src="https://hawk-note-doc.oss-cn-shenzhen.aliyuncs.com/Java/tomcat/image/image-20220416131729641.png" alt="image-20220416131729641"></p><p><img src="https://hawk-note-doc.oss-cn-shenzhen.aliyuncs.com/Java/tomcat/image/image-20220416134256318.png" alt="image-20220416134256318"></p><blockquote><p>Tomcat 请求处理源码入口为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">org.apache.catalina.connector.CoyoteAdapter#service() 方法</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (postParseSuccess) &#123;</span><br><span class="line">                <span class="comment">//check valves if we support async</span></span><br><span class="line">                request.setAsyncSupported(</span><br><span class="line">                        connector.getService().getContainer().getPipeline().isAsyncSupported());</span><br><span class="line">                <span class="comment">// Calling the container 根据connector 获取到对应的Service、Container，</span></span><br><span class="line">         <span class="comment">// 然后获取到pipline中的第一个Engine，执行invoke方法，默认会有一个标准的StandardEngine</span></span><br><span class="line">                connector.getService().getContainer().getPipeline().getFirst().invoke(</span><br><span class="line">                        request, response);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure></blockquote><p><strong>StandardEngineValve</strong>如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">StandardEngineValve</span> <span class="keyword">extends</span> <span class="title class_">ValveBase</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StandardEngineValve</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(Request request, Response response)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="comment">// 根据请求获取对应的host站点</span></span><br><span class="line">        <span class="type">Host</span> <span class="variable">host</span> <span class="operator">=</span> request.getHost();</span><br><span class="line">        <span class="keyword">if</span> (host == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!response.isError()) &#123;</span><br><span class="line">                response.sendError(<span class="number">404</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// 判断是否支持异步</span></span><br><span class="line">            <span class="keyword">if</span> (request.isAsyncSupported()) &#123;</span><br><span class="line">                request.setAsyncSupported(host.getPipeline().isAsyncSupported());</span><br><span class="line">            &#125;</span><br><span class="line">  <span class="comment">// 获取到 host 的 pipline 中的第一个 Valve 执行invoke方法，最后会到StandardHostValve</span></span><br><span class="line">            host.getPipeline().getFirst().invoke(request, response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>StandaHostValve</strong>中的invoke方法如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(Request request, Response response)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"><span class="comment">// 获取host下的context</span></span><br><span class="line">      <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> request.getContext();</span><br><span class="line">      <span class="keyword">if</span> (context == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!response.isError()) &#123;</span><br><span class="line">              response.sendError(<span class="number">404</span>);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">//....省略一些代码</span></span><br><span class="line">                      <span class="keyword">if</span> (!response.isErrorReportRequired()) &#123;</span><br><span class="line">                          <span class="comment">// context 下的pipline，最后进入StandardContextValve</span></span><br><span class="line">                          context.getPipeline().getFirst().invoke(request, response);</span><br><span class="line">                      &#125;</span><br><span class="line">  <span class="comment">//....省略一些代码        </span></span><br><span class="line">                  &#125; </span><br><span class="line">  <span class="comment">//....省略一些代码              </span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>StandardContextValve</strong>的invoke方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(Request request, Response response)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">     <span class="type">MessageBytes</span> <span class="variable">requestPathMB</span> <span class="operator">=</span> request.getRequestPathMB();</span><br><span class="line">     <span class="keyword">if</span> (!requestPathMB.startsWithIgnoreCase(<span class="string">&quot;/META-INF/&quot;</span>, <span class="number">0</span>) &amp;&amp; !requestPathMB.equalsIgnoreCase(<span class="string">&quot;/META-INF&quot;</span>) &amp;&amp; !requestPathMB.startsWithIgnoreCase(<span class="string">&quot;/WEB-INF/&quot;</span>, <span class="number">0</span>) &amp;&amp; !requestPathMB.equalsIgnoreCase(<span class="string">&quot;/WEB-INF&quot;</span>)) &#123;</span><br><span class="line">         <span class="type">Wrapper</span> <span class="variable">wrapper</span> <span class="operator">=</span> request.getWrapper();</span><br><span class="line">         <span class="keyword">if</span> (wrapper != <span class="literal">null</span> &amp;&amp; !wrapper.isUnavailable()) &#123;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 response.sendAcknowledgement(ContinueResponseTiming.IMMEDIATELY);</span><br><span class="line">             &#125; <span class="keyword">catch</span> (IOException var6) &#123;</span><br><span class="line">                 <span class="built_in">this</span>.container.getLogger().error(sm.getString(<span class="string">&quot;standardContextValve.acknowledgeException&quot;</span>), var6);</span><br><span class="line">                 request.setAttribute(<span class="string">&quot;javax.servlet.error.exception&quot;</span>, var6);</span><br><span class="line">                 response.sendError(<span class="number">500</span>);</span><br><span class="line">                 <span class="keyword">return</span>;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span> (request.isAsyncSupported()) &#123;</span><br><span class="line">                 request.setAsyncSupported(wrapper.getPipeline().isAsyncSupported());</span><br><span class="line">             &#125;</span><br><span class="line"><span class="comment">// 继续获取pipline中的valve执行，最后进入 StandardWrapperValve</span></span><br><span class="line">             wrapper.getPipeline().getFirst().invoke(request, response);</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             response.sendError(<span class="number">404</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         response.sendError(<span class="number">404</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>StandardWrapperValve</strong> 中invoke方法会在经过FilterChain最后进入Serlvet。</p><blockquote><p>总结：</p><p>总的请求处理流程是这样的：</p><p>Connector –&gt; Service –&gt; Engine  –&gt; Host –&gt; Context –&gt; Wrapper(资源)</p><p>从Engine开始到Wrapper中的每一层，都有一个pipline的对象，且都有标准实现，即形成了一个多pipline的结构。</p><p>每一个pipline中可以存在多个Valve，默认最后一个是StandardValve，我们添加的Valve都在标准Valve的前面。</p><p>执行到Engine时，会获取Engine中的pipline，然后开始依次执行pipline中xxxValve的invoke方法，直到执行到标准Valve，然后再进入下一层的pipline。</p></blockquote><h2 id="4-线程池配置理论"><a href="#4-线程池配置理论" class="headerlink" title="4. 线程池配置理论"></a>4. 线程池配置理论</h2><p>常用的配置主要有：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">tomcat:</span></span><br><span class="line">    <span class="attr">max-threads:</span> <span class="number">5</span> <span class="comment"># 最大线程数</span></span><br><span class="line">    <span class="attr">min-spare-threads:</span> <span class="number">2</span> <span class="comment"># 最小线程数，初始化的线程数量</span></span><br><span class="line">    <span class="attr">max-connections:</span> <span class="number">10</span> <span class="comment"># 最大连接数</span></span><br><span class="line">    <span class="attr">accept-count:</span> <span class="number">5</span> <span class="comment"># 等待队列</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>tomcat线程配置说明：</p><p>tomcat启动时会初始化配置指定的最小线程数量的业务线程</p><p>当业务线程满了，仍有请求来的话，会创建新的线程来处理请求，直到达到配置的最大线程数</p><p>当达到最大线程数，仍有请求进入时，会放到tomcat线程池中的 任务队列 中，此队列能够存储的请求数量为Integer.MAX_VALUE</p><p>当队列里存储的请求数 + 最大线程数 达到了配置中的 最大连接数 时，请求会进入accept-count配置的等待队列中</p><p>此时内核可以建立TCP连接，但不会在JVM中建立新的连接，当请求数量达到了 等待队列 的上限后，内核也会直接拒绝连接。</p><p>综上，tomcat最大连接数是由maxConnection + acceptCount 来决定的。</p><p>maxConnection决定能在JVM中建立的最大连接数量。</p><p>acceptCount决定在操作系统中能建立的连接数量。</p></blockquote><p>Tomcat建立连接入口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">org.apache.tomcat.util.net.Acceptor#run()</span><br><span class="line"></span><br><span class="line">   <span class="comment">// ---省略一些代码----</span></span><br><span class="line">  <span class="comment">// 此处是检查连接的数量是否达到了最大连接数</span></span><br><span class="line">  <span class="built_in">this</span>.endpoint.countUpOrAwaitConnection();</span><br><span class="line">  <span class="comment">// ---省略一些代码----</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">           socket = <span class="built_in">this</span>.endpoint.serverSocketAccept();</span><br><span class="line">      &#125;</span><br><span class="line">  <span class="comment">// ---省略一些代码----</span></span><br></pre></td></tr></table></figure><p>**org.apache.tomcat.util.net.NioEndpoint#initServerSocket()**方法</p><p><img src="https://hawk-note-doc.oss-cn-shenzhen.aliyuncs.com/Java/tomcat/image/image-20220416144101469.png" alt="image-20220416144101469"></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高并发名词</title>
      <link href="/post/b39fa119.html"/>
      <url>/post/b39fa119.html</url>
      
        <content type="html"><![CDATA[<h1 id="高并发名词"><a href="#高并发名词" class="headerlink" title="高并发名词"></a>高并发名词</h1><h2 id="1-PV（Page-View）"><a href="#1-PV（Page-View）" class="headerlink" title="1. PV（Page View）"></a>1. PV（Page View）</h2><blockquote><p>页面浏览量统计，用户每刷新一次页面，PV值加一。</p></blockquote><h2 id="2-UV（User-View）"><a href="#2-UV（User-View）" class="headerlink" title="2. UV（User View）"></a>2. UV（User View）</h2><blockquote><p>用户访问量统计，根据用户来统计，同一个用户在系统里无论点击多少个页面，UV 统计只加一。</p></blockquote><h2 id="3-RT（Response-Time）"><a href="#3-RT（Response-Time）" class="headerlink" title="3. RT（Response Time）"></a>3. RT（Response Time）</h2><blockquote><p>响应时间。前端页面发出请求开始到接收到后台响应之间的时间。</p><p>一般来说，</p><p>1ms~100ms之间的响应，人们基本感觉不到这个请求的耗时；</p><p>1s左右的响应时间，人们明显能感觉的到系统反应慢，但勉强能接受；</p><p>大于3s的响应时间，人们已经无法接受了，基本都会认为系统有问题；</p></blockquote><h2 id="4-并发用户数"><a href="#4-并发用户数" class="headerlink" title="4. 并发用户数"></a>4. 并发用户数</h2><blockquote><p>并发用户数是指系统可以同时承载的正常使用系统功能的用户的数量。</p></blockquote><h2 id="5-TPS（Transactions-Per-Second）"><a href="#5-TPS（Transactions-Per-Second）" class="headerlink" title="5. TPS（Transactions Per Second）"></a>5. TPS（Transactions Per Second）</h2><blockquote><p>系统每秒处理交易数。</p><p>比如下单事务，中间可能调用多个接口，但是属于下单这个流程，完成一整个下单流程，TPS记为 1。 </p></blockquote><h2 id="6-QPS（Query-Per-Second）"><a href="#6-QPS（Query-Per-Second）" class="headerlink" title="6.  QPS（Query Per Second）"></a>6.  QPS（Query Per Second）</h2><blockquote><p>系统每秒处理查询次数，单位是次/秒。 对于互联网业务中，如果某些业务有且仅有一个请求连接，那么TPS=QPS=HPS，一般情况下用TPS来衡量整个业务流程，用QPS来衡量接口查询次数，用HPS来表示对服务器单击请求。</p></blockquote><h2 id="7-RPS（Request-Per-Second）"><a href="#7-RPS（Request-Per-Second）" class="headerlink" title="7. RPS（Request Per Second）"></a>7. RPS（Request Per Second）</h2><blockquote><p>每秒请求数，等同于QPS，都是接口级别的统计。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP的Content-Length头字段</title>
      <link href="/post/3857b8c0.html"/>
      <url>/post/3857b8c0.html</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP的Content-Length头字段"><a href="#HTTP的Content-Length头字段" class="headerlink" title="HTTP的Content-Length头字段"></a>HTTP的Content-Length头字段</h1><p><em><strong>Content-Length</strong></em>用于<strong>描述HTTP消息实体的传输长度</strong>（<em>the transfer-length of the message-body</em>）。</p><p>在<code>HTTP</code>协议中，消息实体长度和消息实体的传输长度是有区别的。</p><blockquote><p>消息实体长度：消息实体本身的长度。</p><p>消息实体的传输长度：消息实体在传输时的长度。</p></blockquote><p>比如说gzip压缩下，消息实体长度就是压缩前的长度，消息实体的传输长度是gzip压缩后的长度。</p><p>在具体的HTTP交互中，客户端是如何获取消息长度的呢，主要基于以下几个规则：<br>响应为<code>1xx</code>，<code>204</code>，<code>304</code>或者head请求，则直接忽视掉消息实体内容。</p><p>如果有<em><strong>Transfer-Encoding</strong></em>，则优先采用<em><strong>Transfer-Encoding</strong></em>里面的方法来找到对应的长度。比如说<em><strong>Chunked</strong></em>模式。</p><p>如果<em><strong>head</strong></em>中有<em><strong>Content-Length</strong></em>，那么这个<em><strong>Content-Length</strong></em>既表示实体长度，又表示传输长度。</p><p>如果实体长度和传输长度不相等（比如说设置了<em><strong>Transfer-Encoding</strong></em>），那么则不能设置<em><strong>Content-Length</strong></em>。如果设置了<em><strong>Transfer-Encoding</strong></em>，那么<em><strong>Content-Length</strong></em>将被忽视。</p><p><strong>有chunk就不能有content-length</strong> 。</p><p>其实后面几条几乎可以忽视，简单总结后如下：<br>1、<em><strong>Content-Length</strong></em>如果存在并且有效的话，则必须和<strong>消息内容的传输长度</strong>完全一致。（经过测试，如果过短则会截断，过长则会导致超时。）<br>2、如果存在<em><strong>Transfer-Encoding</strong></em>（重点是<em><strong>chunked</strong></em>），则在<em><strong>header</strong></em>中不能有<em><strong>Content-Length</strong></em>，有也会被忽视。<br>3、如果采用短连接，则直接可以通过服务器关闭连接来确定消息的传输长度。（这个很容易懂）</p><p>结合<code>HTTP</code>协议其他的特点，比如说HTTP1.1之前的不支持keep alive。那么可以得出以下结论：<br>1、在<code>HTTP1.0</code>及之前版本中，<em><strong>Content-Length</strong></em>字段可有可无。<br>2、在<code>HTTP1.1</code>及之后版本。如果是<em><strong>keep alive</strong></em>，则<em><strong>Content-Length</strong></em>和<em><strong>chunk</strong></em>必然是二选一。若是非<em><strong>keep alive</strong></em>，则和<code>HTTP1.0</code>一样。<em><strong>Content-Length</strong></em>可有可无。</p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接口幂等性</title>
      <link href="/post/a26b78e0.html"/>
      <url>/post/a26b78e0.html</url>
      
        <content type="html"><![CDATA[<h1 id="接口幂等性"><a href="#接口幂等性" class="headerlink" title="接口幂等性"></a>接口幂等性</h1><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><p><strong>接口幂等性</strong></p><blockquote><p><strong>一次和多次请求某一个资源，对资源本身所产生的的影响均与一次执行的影响相同</strong>。</p><p>幂等性是系统服务对外的一种承诺，承诺只要调用接口成功了，多次调用对系统的影响是一致的。</p></blockquote><h2 id="2-幂等性与重复提交比较"><a href="#2-幂等性与重复提交比较" class="headerlink" title="2. 幂等性与重复提交比较"></a>2. 幂等性与重复提交比较</h2><p><strong>幂等性</strong> 更多使用的情况是第一次请求知道结果，但是由于网络抖动或连接超时等情况未进行正常返回，在这种情况下系统自动再次发起请求，其目的是确认第一次是否请求完成。</p><p><strong>重复提交</strong> 更多使用的情况是第一次请求成功或请求结果暂未返回的情况下，人为的进行多次操作。</p><p>实际上二者表现的情况是一样的，都会多次的调用一个接口，并且传参相同。</p><h2 id="3-SQL语句的幂等性"><a href="#3-SQL语句的幂等性" class="headerlink" title="3. SQL语句的幂等性"></a>3. SQL语句的幂等性</h2><h3 id="3-1-SELECT"><a href="#3-1-SELECT" class="headerlink" title="3.1 SELECT"></a>3.1 SELECT</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `table_name` <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1024</span>;</span><br></pre></td></tr></table></figure><p><code>select</code>语句具有天然的幂等性，因为select语句只是进行查询，并不会修改数据。</p><h3 id="3-2-UPDATE"><a href="#3-2-UPDATE" class="headerlink" title="3.2 UPDATE"></a>3.2 UPDATE</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> table_name <span class="keyword">SET</span> column_xx <span class="operator">=</span> <span class="string">&#x27;xxx&#x27;</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1024</span>;</span><br></pre></td></tr></table></figure><p>像上面这个<code>update</code>语句，执行多次和执行一次是一样的效果，这样的是幂等的。</p><p>下面这个<code>update</code>语句就不是幂等的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> table_name <span class="keyword">SET</span> column_xx <span class="operator">=</span> column_xx <span class="operator">+</span> <span class="number">1</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1024</span>;</span><br></pre></td></tr></table></figure><h3 id="3-3-DELETE"><a href="#3-3-DELETE" class="headerlink" title="3.3 DELETE"></a>3.3 DELETE</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1024</span>;</span><br></pre></td></tr></table></figure><p>这样的删除语句也是幂等的。</p><h3 id="3-4-INSERT"><a href="#3-4-INSERT" class="headerlink" title="3.4 INSERT"></a>3.4 INSERT</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name (xxx, xxx, xxx) <span class="keyword">VALUES</span> (aa, bb, cc);</span><br></pre></td></tr></table></figure><p>插入语句不是幂等的。除非插入的数据项中有一个唯一索引，并且语句如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name (xxx, xxx, xxx) <span class="keyword">VALUES</span> (aa, bb, cc) <span class="keyword">ON</span> DUPLICATE KEY <span class="keyword">UPDATE</span> ...</span><br></pre></td></tr></table></figure><h2 id="4-实现方案"><a href="#4-实现方案" class="headerlink" title="4. 实现方案"></a>4. 实现方案</h2><h3 id="4-1-方案一"><a href="#4-1-方案一" class="headerlink" title="4.1 方案一"></a>4.1 方案一</h3><p>下游系统提供相应查询接口。</p><p>上游系统在 <code>timeout</code> 后，首先去查询一下，如果查到了，就表明已经做了，成功了就不用做了，失败了就走失败流程。</p><h3 id="4-2-方案二"><a href="#4-2-方案二" class="headerlink" title="4.2 方案二"></a>4.2 方案二</h3><p>将这个查询操作交给下游系统，上游系统只管重试，下游系统保证一次和多次的请求产生的影响是一样的。这时我们就说下游系统提供的接口支持幂等性。</p><h2 id="5-下游系统实现接口幂等性"><a href="#5-下游系统实现接口幂等性" class="headerlink" title="5. 下游系统实现接口幂等性"></a>5. 下游系统实现接口幂等性</h2><h3 id="5-1-通过代码逻辑判断实现"><a href="#5-1-通过代码逻辑判断实现" class="headerlink" title="5.1 通过代码逻辑判断实现"></a>5.1 通过代码逻辑判断实现</h3><blockquote><p><a href="https://www.cnblogs.com/huaixiaonian/p/9577567.html">https://www.cnblogs.com/huaixiaonian/p/9577567.html</a></p></blockquote><h3 id="5-2-通过token机制实现"><a href="#5-2-通过token机制实现" class="headerlink" title="5.2 通过token机制实现"></a>5.2 通过token机制实现</h3><p>使用token机制实现接口幂等性,通用性强的实现方法</p><p>   token机制实现步骤:</p><ol><li><p>生成全局唯一的token,token放到redis或jvm内存,token会在页面跳转时获取.存放到pageScope中,支付请求提交先获取token</p></li><li><p>提交后后台校验token，执行提交逻辑,提交成功同时删除token，生成新的token更新redis ,这样当第一次提交后token更新了,页面再次提交携带的token是已删除的token后台验证会失败不让提交</p></li></ol><p>   token特点：  要申请，一次有效性，可以限流</p><p>   注意： redis要用删除操作来判断token，删除成功代表token校验通过，如果用select+delete来校验token，存在并发问题，不建议使用</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux安装Redis 6.0.5 ./install_server.sh报错</title>
      <link href="/post/d30a1526.html"/>
      <url>/post/d30a1526.html</url>
      
        <content type="html"><![CDATA[<h1 id="Linux安装Redis-6-0-5-install-server-sh报错"><a href="#Linux安装Redis-6-0-5-install-server-sh报错" class="headerlink" title="Linux安装Redis 6.0.5   ./install_server.sh报错"></a>Linux安装Redis 6.0.5   ./install_server.sh报错</h1><p>linux 安装Redis6.0.5时<br>进行到<code>./install_server.sh</code>时报错，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">This systems seems to use systemd.</span><br><span class="line">Please take a look at the provided example service unit files in this directory, and adapt and install them. Sorry!</span><br></pre></td></tr></table></figure><p>解决方案：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi ./install_server.sh</span><br></pre></td></tr></table></figure><p>注释下面的代码即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">bail <span class="keyword">if</span> this system is managed by systemd</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">_pid_1_exe=<span class="string">&quot;<span class="subst">$(readlink -f /proc/1/exe)</span>&quot;</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$&#123;_pid_1_exe##*/&#125;</span>&quot;</span> = systemd ]</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="keyword">then</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">      <span class="built_in">echo</span> <span class="string">&quot;This systems seems to use systemd.&quot;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">      <span class="built_in">echo</span> <span class="string">&quot;Please take a look at the provided example service unit files in this directory, and adapt and install them. Sorry!&quot;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">      <span class="built_in">exit</span> 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="keyword">fi</span></span></span><br></pre></td></tr></table></figure><p>然后重新运行 <code>./install_server.sh</code>即可。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7 防火墙相关命令</title>
      <link href="/post/372de7b5.html"/>
      <url>/post/372de7b5.html</url>
      
        <content type="html"><![CDATA[<h1 id="CentOS7-防火墙相关命令"><a href="#CentOS7-防火墙相关命令" class="headerlink" title="CentOS7 防火墙相关命令"></a>CentOS7 防火墙相关命令</h1><ol><li>查看防火墙状态</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --state</span><br></pre></td></tr></table></figure><ol start="2"><li>停止firewall</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld.service</span><br></pre></td></tr></table></figure><ol start="3"><li>开启firewall</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld.service</span><br></pre></td></tr></table></figure><ol start="4"><li>禁止firewall 开机启动</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl disable firewalld.service</span><br></pre></td></tr></table></figure><ol start="5"><li>设置开机启动防火墙</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable firewalld.service</span><br></pre></td></tr></table></figure><ol start="6"><li>重启防火墙</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><ol start="7"><li>对外开放端口</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">说明:</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">–zone 作用域</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">–add-port=80/tcp 添加端口，格式为：端口/通讯协议</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">–permanent 永久生效，没有此参数重启后失效</span></span><br><span class="line">firewall-cmd --zone=public --add-port=端口号/tcp --permanent</span><br></pre></td></tr></table></figure><ol start="8"><li>关闭对外端口</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --remove-port=端口号/tcp --permanent</span><br></pre></td></tr></table></figure><ol start="9"><li>查看已经对外开放的端口</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置开放某个端口后，需要重启防火墙，才能看到刚刚开启的端口</span></span><br><span class="line">firewall-cmd --list-ports</span><br></pre></td></tr></table></figure><ol start="10"><li>查看防火墙所有相关信息</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --list-all</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Bean</title>
      <link href="/post/cb377708.html"/>
      <url>/post/cb377708.html</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-Bean"><a href="#Spring-Bean" class="headerlink" title="Spring Bean"></a>Spring Bean</h1><p>在Spring中，bean 是一个被实例化，组装，并通过 Spring IoC 容器所管理的<strong>对象</strong>。（**<font color="red">也就是由spring来进行管理的资源对象</font>**）</p><h2 id="1-如何将bean放入spring容器中"><a href="#1-如何将bean放入spring容器中" class="headerlink" title="1. 如何将bean放入spring容器中"></a>1. 如何将bean放入spring容器中</h2><p><strong>既然要让spring来管理这些资源类，那么就需要将资源放入到容器中，这样spring容器才能将资源提供给有需要的类进行使用，那么如何将bean对象放入到spring容器中呢？</strong></p><p>有以下三种方法：</p><ul><li><strong><font color="red">Java config配置</font></strong></li></ul><p>使用Java config的方式进行配置时，不需要创建额外的xml文件，需要创建一个java的config类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> byJavaConfig;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span> <span class="comment">// 表明是一个配置类</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;byJavaConfig&quot;)</span> <span class="comment">// 扫描路径</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringBeanConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;helloworld&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> HelloWorld <span class="title function_">getHelloWorld</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HelloWorld</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bean对象的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="keyword">package</span> byJavaConfig;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello Spring By JavaConfig&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试运行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> byJavaConfig;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Run</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 通过IOC容器获得Bean</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringBeanConfig.class);</span><br><span class="line">        <span class="type">HelloWorld</span> <span class="variable">helloWorld</span> <span class="operator">=</span> (HelloWorld)context.getBean(<span class="string">&quot;helloworld&quot;</span>);</span><br><span class="line">        helloWorld.getMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><font color="red">xml配置</font></strong></li></ul><p>使用xml配置，需要创建一个xml文件，命名可以进行自定义，示例代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;helloWorld&quot;</span> <span class="attr">class</span>=<span class="string">&quot;byXML.HelloWorld&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>XML 格式配置文件的根元素是 <code>&lt;beans&gt;</code>，该元素包含了多个<code>&lt;bean&gt;</code>子元素，每一个<code> &lt;bean&gt;</code> 子元素定义了一个 Bean，并描述了该 Bean 如何被装配到 Spring 容器中。</p><p>bean对象的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> byXML;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello Spring By XML&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试运行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> byXML;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Run</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;spring-XML.xml&quot;</span>);</span><br><span class="line">        <span class="type">HelloWorld</span> <span class="variable">obj</span> <span class="operator">=</span> (HelloWorld) context.getBean(<span class="string">&quot;helloWorld&quot;</span>);</span><br><span class="line">        obj.getMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><font color="red">注解配置</font></strong></li></ul><p>注解配置也是需要一份xml的配置文件的，如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">         http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">         http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">         http://www.springframework.org/schema/context/spring-context-3.0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;byZHUJIE&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 声明包扫描路径 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Bean对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> byZHUJIE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component(&quot;hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello Spring By 注解&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> byZHUJIE;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Run</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span></span><br><span class="line">                (<span class="string">&quot;spring-ZHUJIE.xml&quot;</span>);</span><br><span class="line">        <span class="type">HelloWorld</span> <span class="variable">helloWorld</span> <span class="operator">=</span> (HelloWorld) ctx.getBean(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        helloWorld.getMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-Bean的作用域"><a href="#2-Bean的作用域" class="headerlink" title="2. Bean的作用域"></a>2. Bean的作用域</h2><p>Spring 容器在初始化一个 Bean 的实例时，同时会指定该实例的作用域。Spring3 为 Bean 定义了五种作用域，具体如下。</p><h4 id="1）singleton"><a href="#1）singleton" class="headerlink" title="1）singleton"></a>1）singleton</h4><p>单例模式，使用 singleton 定义的 Bean 在 Spring 容器中只有一个实例，这也是 Bean 默认的作用域。</p><h4 id="2）prototype"><a href="#2）prototype" class="headerlink" title="2）prototype"></a>2）prototype</h4><p>原型模式，每次通过 Spring 容器获取 prototype 定义的 Bean 时，容器都将创建一个新的 Bean 实例。</p><h4 id="3）request"><a href="#3）request" class="headerlink" title="3）request"></a>3）request</h4><p>在一次 HTTP 请求中，容器会返回该 Bean 的同一个实例。而对不同的 HTTP 请求，会返回不同的实例，该作用域仅在当前 HTTP Request 内有效。</p><h4 id="4）session"><a href="#4）session" class="headerlink" title="4）session"></a>4）session</h4><p>在一次 HTTP Session 中，容器会返回该 Bean 的同一个实例。而对不同的 HTTP 请求，会返回不同的实例，该作用域仅在当前 HTTP Session 内有效。</p><h4 id="5）global-Session"><a href="#5）global-Session" class="headerlink" title="5）global Session"></a>5）global Session</h4><p>在一个全局的 HTTP Session 中，容器会返回该 Bean 的同一个实例。该作用域仅在使用 portlet context 时有效。</p><h2 id="3-Bean的生命周期"><a href="#3-Bean的生命周期" class="headerlink" title="3. Bean的生命周期"></a>3. Bean的生命周期</h2><p><font color="#FF3030" size="3">注意：Spring 只帮我们管理单例模式 Bean 的完整生命周期,对于 prototype 的 bean ,Spring 在创建好交给使用者之后则不会再管理后续的生命周期。</font></p><p>1、实例化一个Bean－－也就是我们常说的new；</p><p>2、按照Spring上下文对实例化的Bean进行配置－－也就是依赖注入；</p><p>3、如果这个Bean已经实现了BeanNameAware接口，会调用它实现的setBeanName(String)方法，此处传递的就是Spring配置文件中Bean的id值</p><p>4、如果这个Bean已经实现了BeanFactoryAware接口，会调用它实现的setBeanFactory(setBeanFactory(BeanFactory)传递的是Spring工厂自身（可以用这个方式来获取其它Bean，只需在Spring配置文件中配置一个普通的Bean就可以）；</p><p>5、如果这个Bean已经实现了ApplicationContextAware接口，会调用setApplicationContext(ApplicationContext)方法，传入Spring上下文（同样这个方式也可以实现步骤4的内容，但比4更好，因为ApplicationContext是BeanFactory的子接口，有更多的实现方法）；<br><font color="#FF3030" size="3">注：去掉此步骤就是BeanFactory的Bean的生命周期</font></p><p>6、如果这个Bean关联了BeanPostProcessor接口，将会调用postProcessBeforeInitialization(Object obj, String s)方法，BeanPostProcessor经常被用作是Bean内容的更改，并且由于这个是在Bean初始化结束时调用那个的方法，也可以被应用于内存或缓存技术；</p><p>7、如果Bean在Spring配置文件中配置了init-method属性会自动调用其配置的初始化方法。</p><p>8、如果这个Bean关联了BeanPostProcessor接口，将会调用postProcessAfterInitialization(Object obj, String s)方法、；</p><p><font color="#FF3030" size="3">注：以上工作完成以后就可以应用这个Bean了，那这个Bean是一个Singleton的，所以一般情况下我们调用同一个id的Bean会是在内容地址相同的实例</font></p><p>9、当Bean不再需要时，会经过清理阶段，如果Bean实现了DisposableBean这个接口，会调用那个其实现的destroy()方法；</p><p>10、最后，如果这个Bean的Spring配置中配置了destroy-method属性，会自动调用其配置的销毁方法</p><p>简单来说就四步</p><ul><li>实例化</li><li>属性赋值</li><li>初始化</li><li>销毁</li></ul><p>其余的操作都是在穿插在这四步之中</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap详解-源码分析</title>
      <link href="/post/9ca5d950.html"/>
      <url>/post/9ca5d950.html</url>
      
        <content type="html"><![CDATA[<h1 id="HashMap详解-源码分析"><a href="#HashMap详解-源码分析" class="headerlink" title="HashMap详解-源码分析"></a>HashMap详解-源码分析</h1><h2 id="HashMap类声明"><a href="#HashMap类声明" class="headerlink" title="HashMap类声明"></a>HashMap类声明</h2><p>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable </span><br></pre></td></tr></table></figure><p>分析：</p><ul><li>继承了AbstractMap抽象类，而AbstractMap类已经实现了Map部分接口，可以直接使用</li><li>实现了Map、Cloneable、Serializable接口，即实现Map接口中的相应方法，支持clone，支持序列化及反序列化</li></ul><h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><p>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">362498820763181265L</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> modCount;</span><br><span class="line"></span><br><span class="line"> <span class="type">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>分析：</p><ul><li>serialVersionUID：序列化版本号</li><li>DEFAULT_INITIAL_CAPACITY：默认初始化的数组容量</li><li>MAXIMUM_CAPACITY：最大的容量，1&gt;&gt;30即为2的30次方</li><li>DEFAULT_LOAD_FACTOR：默认的扩容因子</li><li>TREEIFY_THRESHOLD：树化的阈值</li><li>UNTREEIFY_THRESHOLD：退化为链表的阈值</li><li>MIN_TREEIFY_CAPACITY： 树的最小容量</li><li>table：用于保存键值对元素的数组</li><li>entrySet：存放具体元素的集合</li><li>size：实际存储元素的个数</li><li>modCount：记录数组长度变化</li><li>threshold：临界值 当实际大小(容量*扩容因子)超过临界值时，会进行扩容</li><li>loadFactor：扩容因子</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的代理</title>
      <link href="/post/e63723a.html"/>
      <url>/post/e63723a.html</url>
      
        <content type="html"><![CDATA[<h3 id="Java中的代理"><a href="#Java中的代理" class="headerlink" title="Java中的代理"></a>Java中的代理</h3><pre><code>   代理模式（Proxy）是通过代理对象访问目标对象，这样可以在目标对象基础上增强额外的功能，如添加权限，访问控制和审计等功能。 </code></pre><ul><li>增加额外功能，进行增强</li><li>引入第三方代理类，进行解耦</li></ul><blockquote><ol><li><strong>静态代理</strong></li></ol></blockquote><p>请参考下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*声明一个明星接口，明星只需要关注自己的唱、跳</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StarService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sing</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">jump</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*明星接口的具体实现类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StarServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">StarService</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sing</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; sing a song &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">jump</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; just dance &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*代理类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StarServiceProxy</span> <span class="keyword">implements</span> <span class="title class_">StarService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StarService starService;</span><br><span class="line"><span class="comment">// 通过构造方法将目标实现类注入</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StarServiceProxy</span><span class="params">(StarService starService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.starService = starService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sing</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;唱歌之前先联系综艺节目，确定时间、地点&quot;</span>);</span><br><span class="line">        starService.sing();</span><br><span class="line">        System.out.println(<span class="string">&quot;表演结束之后，安排下一场演出&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">jump</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> starService.jump();</span><br><span class="line">        System.out.println(<span class="string">&quot;跳舞之后，观众鼓掌&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StarService</span> <span class="variable">starService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StarServiceImpl</span>();</span><br><span class="line">        <span class="type">StarServiceProxy</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StarServiceProxy</span>(starService);</span><br><span class="line">        proxy.sing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输出：</span><br><span class="line"> 唱歌之前先联系综艺节目，确定时间、地点</span><br><span class="line">  sing a song </span><br><span class="line"> 表演结束之后，安排下一场演出</span><br></pre></td></tr></table></figure><blockquote><p><strong>总结</strong>：</p><ul><li> 静态代理模式在不改变目标对象的前提下，实现了对目标对象的功能扩展；</li><li>不足： 静态代理<strong>实现了目标对象的所有方法</strong>，一旦目标接口增加方法，代理对象和目标对象都要进行相应的修改，增加维护成本。 </li></ul></blockquote><blockquote><ol start="2"><li><strong>动态代理</strong></li></ol></blockquote><p>Java中的动态代理需要<code>java.lang.reflect.InvocationHandler</code>接口和<code> java.lang.reflect.Proxy</code> 类的支持 。**<code>jdk</code>的动态代理是面向接口的，即<code>jdk</code>的动态代理只能代理实现接口的类，不能代理抽象类或者没有实现接口的类。**</p><p> <code>java.lang.reflect.InvocationHandler</code>接口的定义如下： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*Object proxy   被代理的对象  </span></span><br><span class="line"><span class="comment">*Method method  要调用的方法  </span></span><br><span class="line"><span class="comment">*Object[] args  方法调用时所需要参数  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InvocationHandler</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>java.lang.reflect.Proxy</code>类的定义如下： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*CLassLoader loader    类的加载器 </span></span><br><span class="line"><span class="comment">*Class&lt;?&gt; interfaces   得到全部的接口  </span></span><br><span class="line"><span class="comment">*InvocationHandler h   得到InvocationHandler接口的子类的实例</span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</span> <span class="keyword">throws</span> IllegalArgumentException  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>jdk</code>动态代理流程：</p><ol><li> 通过实现 <code>InvocationHandler </code>接口创建自己的调用处理器； </li><li> 通过为 Proxy 类指定<code> ClassLoader</code> 对象和一组<code>interface</code>来创建动态代理类； </li><li> 通过反射机制获得动态代理类的构造函数，其唯一参数类型是调用处理器接口类型； </li><li> 通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数被传入。 </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义中间代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YourHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="comment">// 目标对象  </span></span><br><span class="line">    <span class="keyword">private</span> Object targetObject;  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProxyHandler</span><span class="params">( Object proxied )</span> &#123;   </span><br><span class="line">    <span class="built_in">this</span>.proxied = proxied;   </span><br><span class="line">  &#125;  </span><br><span class="line">    </span><br><span class="line">     <span class="comment">/*proxy表示代理目标对象，method表示原对象被调用的方法，args表示方法的参数*/</span>  </span><br><span class="line">    <span class="meta">@Ovrride</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">( Object proxy, Method method, Object[] args )</span> <span class="keyword">throws</span> Throwable &#123;   </span><br><span class="line">    <span class="comment">//在转调具体目标对象之前，可以执行一些功能处理</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//转调具体目标对象的方法</span></span><br><span class="line">    <span class="keyword">return</span> method.invoke( proxy, args);  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在转调具体目标对象之后，可以执行一些功能处理</span></span><br><span class="line">  &#125;    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>实际应用时代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RealSubject  要代理的目标对象</span></span><br><span class="line"><span class="type">RealSubject</span> <span class="variable">real</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealSubject</span>(); </span><br><span class="line"><span class="comment">// Subject 目标对象实现的接口</span></span><br><span class="line">    <span class="type">Subject</span> <span class="variable">proxySubject</span> <span class="operator">=</span>   (Subject)Proxy.newProxyInstance(Subject.class.getClassLoader(), </span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Subject.class&#125;, </span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">YourHandler</span>(real));</span><br><span class="line"> <span class="comment">// proxySubject 为中间代理类        </span></span><br><span class="line">    proxySubject.method( Object[] args);</span><br></pre></td></tr></table></figure><blockquote><ol start="3"><li><strong><code>Cglib</code>代理</strong></li></ol></blockquote><p>​        Cglib代理补充了jdk中只面向接口进行代理的不足，Cglib代理支持基于对象代理，不用关心该对象是否实现了某个接口。 Cglib是一个java字节码的生成工具，它动态生成一个被代理类的子类，子类重写被代理的类的所有不是final的方法。在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。 </p><p>以上面的<code>StarServiceImpl</code>为被代理对象，举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  自定义中间代理类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMethodInterceptor</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">&quot;Before: &quot;</span>  + method.getName());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> methodProxy.invokeSuper(o, objects);</span><br><span class="line">        System.out.println(<span class="string">&quot;After: &quot;</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试如下</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">//继承被代理类</span></span><br><span class="line">        enhancer.setSuperclass(Star.class);</span><br><span class="line">        <span class="comment">//设置回调</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">MyMethodInterceptor</span>());</span><br><span class="line">        <span class="comment">//设置代理类对象</span></span><br><span class="line">        <span class="type">StarServiceImpl</span> <span class="variable">starService</span> <span class="operator">=</span> (StarServiceImpl) enhancer.create();</span><br><span class="line">        <span class="comment">//在调用代理类中方法时会被我们实现的方法拦截器进行拦截</span></span><br><span class="line">        starService.sing();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输出结果如下：</span><br><span class="line">    Before: sing</span><br><span class="line">sing a song</span><br><span class="line">After: sing</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 代理 </tag>
            
            <tag> 动态代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java知识点总结</title>
      <link href="/post/d842f132.html"/>
      <url>/post/d842f132.html</url>
      
        <content type="html"><![CDATA[<h2 id="Java知识点总结"><a href="#Java知识点总结" class="headerlink" title="Java知识点总结"></a>Java知识点总结</h2><h3 id="1-类的初始化顺序"><a href="#1-类的初始化顺序" class="headerlink" title="1.  类的初始化顺序"></a>1.  类的初始化顺序</h3><ol><li>父类静态变量（静态代码块）</li><li>子类静态变量（静态代码块）</li><li>父类成员变量</li><li>父类构造方法</li><li>子类成员变量</li><li>子类构造方法</li></ol><h3 id="2-final修饰符"><a href="#2-final修饰符" class="headerlink" title="2. final修饰符"></a>2. final修饰符</h3><ul><li><p>修饰变量， 必须显示地赋初值，且赋初值后不能再赋值</p><blockquote><p>被final修饰的实例变量必须显示地赋初值，且只能以下三种方式：</p><p>　　1.  定义时初始化</p><p>　　2.  在非静态初始化块中为final实例变量指定初始值</p><p>　　3.  在构造器中指定初始值</p><p>final修饰的静态变量只能在两个地方进行初始化</p><ol><li>定义final类变量时指定初始值 </li><li>在静态初始化块中为final类变量指定初始值 </li></ol></blockquote></li><li><p>修饰方法，该方法不能被重写</p></li><li><p>修饰类，该类不能被继承   </p></li></ul><h3 id="3-static修饰符"><a href="#3-static修饰符" class="headerlink" title="3.  static修饰符"></a>3.  static修饰符</h3><ul><li><p>修饰变量，被<code>static</code>修饰的变量实质上就是全局变量，<strong>所有的类实例（对象），共享该变量</strong>；且该变量可以以<code>类名.变量名</code>的方式进行访问</p></li><li><p>修饰方法，该方法被称为静态方法，可直接使用<code>类名.静态方法名</code>进行调用，不需要实例化对象。</p><blockquote><p>静态方法有以下特点：</p><ul><li>只能访问<code>static</code>变量</li><li>只能调用其他<code>static</code>方法</li><li>不能使用<code>this</code>或者<code>super</code>关键字，因为这两个关键字都是需要绑定对象</li></ul></blockquote></li><li><p><code>static</code>一般不能修饰类，只能修饰<strong>内部类</strong></p></li><li><p><code>import static com.*.ClassName.*</code>，静态导入所需要的静态变量，从<code>jdk5</code>开始。</p></li></ul><h3 id="4-private修饰构造方法"><a href="#4-private修饰构造方法" class="headerlink" title="4. private修饰构造方法"></a>4. private修饰构造方法</h3><ul><li><code>private</code>修饰的构造方法只能在本类里调用</li></ul><h3 id="5-重写和重载"><a href="#5-重写和重载" class="headerlink" title="5. 重写和重载"></a>5. 重写和重载</h3><ul><li>重写（覆写）：方法名相同，接收参数相同，返回结果相同，处理逻辑不同，发生在子类和父类之间。</li><li>重载（覆载）：方法名相同，接收参数不同，返回结果可以不同，发生在一个类中。</li></ul><h3 id="6-反射"><a href="#6-反射" class="headerlink" title="6. 反射"></a>6. 反射</h3><ul><li><code> java</code>反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为<code>java</code>语言的反射机制。</li></ul><h3 id="7-反射的应用场景"><a href="#7-反射的应用场景" class="headerlink" title="7.  反射的应用场景"></a>7.  反射的应用场景</h3><p>​        平时的业务开发中，很少用到反射，但是**反射是框架设计的灵魂 **，很多框架都用到了反射。</p><p>举例如下：</p><ul><li><p> 我们在使用<code>JDBC</code>连接数据库时使用<code>Class.forName()</code>通过反射加载数据库的驱动程序； </p></li><li><p> 动态代理；</p></li><li><p> Spring框架也用到很多反射机制，最经典的就是<code>xml</code>的配置模式；</p></li></ul><blockquote><p>Spring 通过 <code>xml</code>配置模式装载 Bean 的过程：</p><ul><li>将程序内所有 <code>xml</code>或 <code>properties</code>配置文件加载入内存中;  </li><li>Java类里面解析<code>xml</code>或<code>properties</code>里面的内容，得到对应实体类的字节码字符串以及相关的属性信息;  </li><li>使用反射机制，根据这个字符串获得某个类的Class实例; </li><li>动态配置实例的属性。 </li></ul></blockquote><h3 id="8-short、int类型提升"><a href="#8-short、int类型提升" class="headerlink" title="8.short、int类型提升"></a>8.<code>short</code>、<code>int</code>类型提升</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">a = a + <span class="number">1</span>; </span><br><span class="line"><span class="comment">/* 编译报错（原因：使用 + 运算符，会使得short类型自动提升为int类型，int类型的值范围大于short），所以可能</span></span><br><span class="line"><span class="comment"> * 会出现超出范围的报错，故编译不通过</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">a += <span class="number">1</span>; <span class="comment">//编译通过，java中对 += 做了特殊处理</span></span><br></pre></td></tr></table></figure><h3 id="9-String不变性"><a href="#9-String不变性" class="headerlink" title="9. String不变性"></a>9. <code>String</code>不变性</h3><ul><li>String类是被final进行修饰的，不能被继承；</li><li>使用<code>+</code>运算符连接两个字符串时，会创建一个新的字符串；<code>+</code>运算符底层采用了<code>StringBuilder</code>实例的<code>append()</code>方法实现；</li><li><code>String s = new String(&quot;hello world&quot;);</code>可能创建两个对象，也可能创建一个对象。如果在静态区中有<code>&quot;hello world&quot;</code>字符串常量对象的话，则仅仅在堆中创建一个对象。如果在静态区中没有<code>&quot;hello world&quot;</code>对象，则在堆和静态区中都需要创建对象；</li></ul><h3 id="10-为什么重写equals-方法时，一定要重写hashCode-方法"><a href="#10-为什么重写equals-方法时，一定要重写hashCode-方法" class="headerlink" title="10.  为什么重写equals()方法时，一定要重写hashCode()方法"></a>10.  为什么重写<code>equals()</code>方法时，一定要重写<code>hashCode()</code>方法</h3><ul><li><p>因为关于<code>hashCode()</code>方法，一致约定是 </p><blockquote><ol><li><strong>如果两个对象通过<code>equals</code>调用后返回是<code>true</code>，那么这个两个对象的<code>hashCode</code>方法也必须返回同样的int型散列码;</strong></li><li>**如果两个对象通过equals返回false，他们的hashCode返回的值<font color="red">允许相同</font>**。(然而，程序员必须意识到，<code>hashCode</code>返回独一无二的散列码，会让存储这个对象的<code>hashTables</code>更好地工作。)</li></ol></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么重写equals()方法时，要重写hashCode()方法</title>
      <link href="/post/300023f4.html"/>
      <url>/post/300023f4.html</url>
      
        <content type="html"><![CDATA[<h2 id="为什么重写equals-方法时，要重写hashCode-方法"><a href="#为什么重写equals-方法时，要重写hashCode-方法" class="headerlink" title="为什么重写equals()方法时，要重写hashCode()方法"></a>为什么重写equals()方法时，要重写hashCode()方法</h2><h3 id="1-Object类中equals-方法源代码如下所示："><a href="#1-Object类中equals-方法源代码如下所示：" class="headerlink" title="1. Object类中equals()方法源代码如下所示："></a>1. <code>Object</code>类中<code>equals()</code>方法源代码如下所示：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*Object类中的equals()方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p> 由以上源代码知，<code>Object</code>类中的<code>equals()</code>方法是直接使用<code>==</code>运算符来判断两个对象相等的。</p><ul><li>引用类型变量使用<code>==</code>时，比较的是引用类型变量指向的对象的内存地址</li><li>基本类型使用<code>==</code>时，比较值</li></ul></blockquote><p><code>Objcect</code>类中的<code>hashCode</code>源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns a hash code value for the object. This method is</span></span><br><span class="line"><span class="comment">    * supported for the benefit of hash tables such as those provided by</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> java.util.HashMap&#125;.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * The general contract of &#123;<span class="doctag">@code</span> hashCode&#125; is:</span></span><br><span class="line"><span class="comment">    * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">    * &lt;li&gt;Whenever it is invoked on the same object more than once during</span></span><br><span class="line"><span class="comment">    *     an execution of a Java application, the &#123;<span class="doctag">@code</span> hashCode&#125; method</span></span><br><span class="line"><span class="comment">    *     must consistently return the same integer, provided no information</span></span><br><span class="line"><span class="comment">    *     used in &#123;<span class="doctag">@code</span> equals&#125; comparisons on the object is modified.</span></span><br><span class="line"><span class="comment">    *     This integer need not remain consistent from one execution of an</span></span><br><span class="line"><span class="comment">    *     application to another execution of the same application.</span></span><br><span class="line"><span class="comment">    * &lt;li&gt;If two objects are equal according to the &#123;<span class="doctag">@code</span> equals(Object)&#125;</span></span><br><span class="line"><span class="comment">    *     method, then calling the &#123;<span class="doctag">@code</span> hashCode&#125; method on each of</span></span><br><span class="line"><span class="comment">    *     the two objects must produce the same integer result.</span></span><br><span class="line"><span class="comment">    * &lt;li&gt;It is &lt;em&gt;not&lt;/em&gt; required that if two objects are unequal</span></span><br><span class="line"><span class="comment">    *     according to the &#123;<span class="doctag">@link</span> java.lang.Object#equals(java.lang.Object)&#125;</span></span><br><span class="line"><span class="comment">    *     method, then calling the &#123;<span class="doctag">@code</span> hashCode&#125; method on each of the</span></span><br><span class="line"><span class="comment">    *     two objects must produce distinct integer results.  However, the</span></span><br><span class="line"><span class="comment">    *     programmer should be aware that producing distinct integer results</span></span><br><span class="line"><span class="comment">    *     for unequal objects may improve the performance of hash tables.</span></span><br><span class="line"><span class="comment">    * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * As much as is reasonably practical, the hashCode method defined by</span></span><br><span class="line"><span class="comment">    * class &#123;<span class="doctag">@code</span> Object&#125; does return distinct integers for distinct</span></span><br><span class="line"><span class="comment">    * objects. (This is typically implemented by converting the internal</span></span><br><span class="line"><span class="comment">    * address of the object into an integer, but this implementation</span></span><br><span class="line"><span class="comment">    * technique is not required by the</span></span><br><span class="line"><span class="comment">    * Java&amp;trade; programming language.)</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>  a hash code value for this object.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span>     java.lang.Object#equals(java.lang.Object)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span>     java.lang.System#identityHashCode</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;<span class="comment">// java8中的hashCode方法，</span></span><br></pre></td></tr></table></figure><blockquote><p>上面的注释中有说明如下几点：</p><ul><li>对象的<code>hashCode</code>值通常是根据对象的内存地址计算得来</li><li>两个对象<code>equals()</code>结果为<code>true</code>时，两个对象的<code>hashCode</code>值一定相等，不同对象的<code>hashCode</code>不等</li><li><code>native</code>标识此方法不是<code>java</code>语言实现</li></ul></blockquote><p><code>Object</code>类中的<code>toString()</code>方法源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 从这里就能看出打印对象时不重写toString()方法时，就会打印出对象的hashCode值</span></span><br><span class="line">        <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="2-String类中equals-方法和hashCode-方法"><a href="#2-String类中equals-方法和hashCode-方法" class="headerlink" title="2. String类中equals()方法和hashCode()方法"></a>2. <code>String</code>类中<code>equals()</code>方法和<code>hashCode()</code>方法</h3><blockquote><p><code>String</code>类中部分源代码如下所示：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line"><span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 无参构造方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.value = <span class="string">&quot;&quot;</span>.value;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 有参构造方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">(String original)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.value = original.value;</span><br><span class="line">      <span class="built_in">this</span>.hash = original.hash;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*String类重写的equals方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object anObject)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span> == anObject) &#123;<span class="comment">// 此处的this指向a.equals(b)的a对象，即谁调用指向谁</span></span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">          <span class="type">String</span> <span class="variable">anotherString</span> <span class="operator">=</span> (String)anObject;</span><br><span class="line">          <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> value.length;</span><br><span class="line">          <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">              <span class="type">char</span> v1[] = value;</span><br><span class="line">              <span class="type">char</span> v2[] = anotherString.value;</span><br><span class="line">              <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">              <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                  i++;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns a hash code for this string. The hash code for a</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@code</span> String&#125; object is computed as</span></span><br><span class="line"><span class="comment">   * &lt;blockquote&gt;&lt;pre&gt;</span></span><br><span class="line"><span class="comment">   * s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]</span></span><br><span class="line"><span class="comment">   * &lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment">   * using &#123;<span class="doctag">@code</span> int&#125; arithmetic, where &#123;<span class="doctag">@code</span> s[i]&#125; is the</span></span><br><span class="line"><span class="comment">   * &lt;i&gt;i&lt;/i&gt;th character of the string, &#123;<span class="doctag">@code</span> n&#125; is the length of</span></span><br><span class="line"><span class="comment">   * the string, and &#123;<span class="doctag">@code</span> ^&#125; indicates exponentiation.</span></span><br><span class="line"><span class="comment">   * (The hash value of the empty string is zero.)</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span>  a hash code value for this object.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> hash;</span><br><span class="line">      <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="type">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">              h = <span class="number">31</span> * h + val[i];</span><br><span class="line">          &#125;</span><br><span class="line">          hash = h;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> h;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从上面的源码中，我们不难发现<code>String</code>类已经重写了<code>equals()</code>方法和<code>hashCode()</code>方法。</p><p><code>String</code>类重写的<code>equals()</code>方法判断流程如下：</p><blockquote><ol><li>使用<code>==</code>来判断两个对象的内存地址是否相同，相同返回<code>true；</code></li><li>如果两个对象的内存地址不同，程序继续往下走，判断另一个对象是否是<code>String</code>类型的；</li><li>如果比较对象不是<code>String</code>类型，直接返回<code>false</code>；</li><li>如果是<code>String</code>类型的，进行类型强转；</li><li>比较两个<code>String</code>的字符数组长度，如果长度不同，返回<code>false</code>；</li><li>利用<code>while</code>循环来逐位比较字符是否相等，直到循环结束，所有字符都相等，则返回<code>true</code>，否则返回<code>false</code>;</li></ol></blockquote><p>下面来看一下重写的<code>hashCode()</code>方法。</p><blockquote><ol><li>首先<code>String</code>类中定义了一个<code>int</code>类型的变量<code>hash</code>用来缓存<code>String</code>对象的<code>hash</code>值；</li><li>如果当前调用<code>hashCode()</code>方法的<code>String</code>对象在常量池没有找到，并且该对象的<code>length</code>长度大于<code>0</code>,则继续往下走，否则返回<code>0</code>;即<code>String</code>类默认<code>&quot;&quot;</code>字符串的<code>hashCode()</code>值为<code>0</code>;</li><li>遍历字符数组，获取每一个字符的<code>ASCII</code>码表对应的值 和之前的<code>hash</code>值相加，这样就保证了相同的字符串的<code>hashCode()</code>返回值相同，计算公式在注释里已经写出来了：**<code>s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]</code>**</li><li>将计算出来的结果保存到<code>hash</code>变量中，并返回该值；</li></ol></blockquote><p>这里为什么要乘以<code>31</code>呢？原因是为了<strong>性能</strong>，不仅仅指降低了计算速度，也降低了哈希冲突的概率。</p><blockquote><p> 哈希冲突：此处指不同的字符串生成了相同的<code>hashCode</code>值。</p></blockquote><p><code>31</code>是一个<strong>奇素数</strong>。如果乘数是偶数，并且乘法溢出的话，信息就会丢失，因为与2相乘等价于移位运算（低位补<code>0</code>）。使用素数的好处并不很明显，但是习惯上使用素数来计算散列结果。 <strong><code>31</code> 有个很好的性能，即用移位和减法来代替乘法</strong>，可以得到更好的性能： <code>31 * i == (i &lt;&lt; 5）- i</code>， 现代的 <code>VM</code>  可以自动完成这种优化。这个公式可以很简单的推导出来。 —- 《<code>Effective Java</code>》 </p><blockquote><p>素数：质数又称素数，指在一个大于1的自然数中，除了1和此整数自身外，没法被其他自然数整除的数。 </p></blockquote><h3 id="说了这么多，为什么重写equals-方法要重写hashCode-方法呢？"><a href="#说了这么多，为什么重写equals-方法要重写hashCode-方法呢？" class="headerlink" title="说了这么多，为什么重写equals()方法要重写hashCode()方法呢？"></a>说了这么多，为什么重写equals()方法要重写hashCode()方法呢？</h3><p>原因如下：</p><ul><li><font color="red"><strong>避免两个对象不同时出现相同的hashCode值</strong></font></li><li><font color="red"><strong>避免重写过equals()方法的对象使用equals()判断为相等时，返回不同的hashCode值</strong></font></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>equals()方法和hashCode()方法详解</title>
      <link href="/post/e8d9b9d3.html"/>
      <url>/post/e8d9b9d3.html</url>
      
        <content type="html"><![CDATA[<h2 id="equals-方法和hashCode-方法详解"><a href="#equals-方法和hashCode-方法详解" class="headerlink" title="equals()方法和hashCode()方法详解"></a><code>equals()</code>方法和<code>hashCode()</code>方法详解</h2><h3 id="1-Object类中equals-方法源代码如下所示："><a href="#1-Object类中equals-方法源代码如下所示：" class="headerlink" title="1. Object类中equals()方法源代码如下所示："></a>1. <code>Object</code>类中<code>equals()</code>方法源代码如下所示：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*Object类中的equals()方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p> 由以上源代码知，<code>Object</code>类中的<code>equals()</code>方法是直接使用<code>==</code>运算符来判断两个对象相等的。</p><ul><li>引用类型变量使用<code>==</code>时，比较的是引用类型变量指向的对象的内存地址</li><li>基本类型使用<code>==</code>时，比较值</li></ul></blockquote><p><code>Objcect</code>类中的<code>hashCode</code>源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns a hash code value for the object. This method is</span></span><br><span class="line"><span class="comment">    * supported for the benefit of hash tables such as those provided by</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> java.util.HashMap&#125;.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * The general contract of &#123;<span class="doctag">@code</span> hashCode&#125; is:</span></span><br><span class="line"><span class="comment">    * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">    * &lt;li&gt;Whenever it is invoked on the same object more than once during</span></span><br><span class="line"><span class="comment">    *     an execution of a Java application, the &#123;<span class="doctag">@code</span> hashCode&#125; method</span></span><br><span class="line"><span class="comment">    *     must consistently return the same integer, provided no information</span></span><br><span class="line"><span class="comment">    *     used in &#123;<span class="doctag">@code</span> equals&#125; comparisons on the object is modified.</span></span><br><span class="line"><span class="comment">    *     This integer need not remain consistent from one execution of an</span></span><br><span class="line"><span class="comment">    *     application to another execution of the same application.</span></span><br><span class="line"><span class="comment">    * &lt;li&gt;If two objects are equal according to the &#123;<span class="doctag">@code</span> equals(Object)&#125;</span></span><br><span class="line"><span class="comment">    *     method, then calling the &#123;<span class="doctag">@code</span> hashCode&#125; method on each of</span></span><br><span class="line"><span class="comment">    *     the two objects must produce the same integer result.</span></span><br><span class="line"><span class="comment">    * &lt;li&gt;It is &lt;em&gt;not&lt;/em&gt; required that if two objects are unequal</span></span><br><span class="line"><span class="comment">    *     according to the &#123;<span class="doctag">@link</span> java.lang.Object#equals(java.lang.Object)&#125;</span></span><br><span class="line"><span class="comment">    *     method, then calling the &#123;<span class="doctag">@code</span> hashCode&#125; method on each of the</span></span><br><span class="line"><span class="comment">    *     two objects must produce distinct integer results.  However, the</span></span><br><span class="line"><span class="comment">    *     programmer should be aware that producing distinct integer results</span></span><br><span class="line"><span class="comment">    *     for unequal objects may improve the performance of hash tables.</span></span><br><span class="line"><span class="comment">    * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * As much as is reasonably practical, the hashCode method defined by</span></span><br><span class="line"><span class="comment">    * class &#123;<span class="doctag">@code</span> Object&#125; does return distinct integers for distinct</span></span><br><span class="line"><span class="comment">    * objects. (This is typically implemented by converting the internal</span></span><br><span class="line"><span class="comment">    * address of the object into an integer, but this implementation</span></span><br><span class="line"><span class="comment">    * technique is not required by the</span></span><br><span class="line"><span class="comment">    * Java&amp;trade; programming language.)</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>  a hash code value for this object.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span>     java.lang.Object#equals(java.lang.Object)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span>     java.lang.System#identityHashCode</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;<span class="comment">// java8中的hashCode方法，</span></span><br></pre></td></tr></table></figure><blockquote><p>上面的注释中有说明如下几点：</p><ul><li>对象的<code>hashCode</code>值通常是根据对象的内存地址计算得来</li><li>两个对象<code>equals()</code>结果为<code>true</code>时，两个对象的<code>hashCode</code>值一定相等，不同对象的<code>hashCode</code>不等</li><li><code>native</code>标识此方法不是<code>java</code>语言实现</li></ul></blockquote><p><code>Object</code>类中的<code>toString()</code>方法源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 从这里就能看出打印对象时不重写toString()方法时，就会打印出对象的hashCode值</span></span><br><span class="line">        <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="2-String类中equals-方法和hashCode-方法"><a href="#2-String类中equals-方法和hashCode-方法" class="headerlink" title="2. String类中equals()方法和hashCode()方法"></a>2. <code>String</code>类中<code>equals()</code>方法和<code>hashCode()</code>方法</h3><blockquote><p><code>String</code>类中部分源代码如下所示：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line"><span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 无参构造方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.value = <span class="string">&quot;&quot;</span>.value;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 有参构造方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">(String original)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.value = original.value;</span><br><span class="line">      <span class="built_in">this</span>.hash = original.hash;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*String类重写的equals方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object anObject)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span> == anObject) &#123;<span class="comment">// 此处的this指向a.equals(b)的a对象，即谁调用指向谁</span></span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">          <span class="type">String</span> <span class="variable">anotherString</span> <span class="operator">=</span> (String)anObject;</span><br><span class="line">          <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> value.length;</span><br><span class="line">          <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">              <span class="type">char</span> v1[] = value;</span><br><span class="line">              <span class="type">char</span> v2[] = anotherString.value;</span><br><span class="line">              <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">              <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                  i++;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns a hash code for this string. The hash code for a</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@code</span> String&#125; object is computed as</span></span><br><span class="line"><span class="comment">   * &lt;blockquote&gt;&lt;pre&gt;</span></span><br><span class="line"><span class="comment">   * s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]</span></span><br><span class="line"><span class="comment">   * &lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment">   * using &#123;<span class="doctag">@code</span> int&#125; arithmetic, where &#123;<span class="doctag">@code</span> s[i]&#125; is the</span></span><br><span class="line"><span class="comment">   * &lt;i&gt;i&lt;/i&gt;th character of the string, &#123;<span class="doctag">@code</span> n&#125; is the length of</span></span><br><span class="line"><span class="comment">   * the string, and &#123;<span class="doctag">@code</span> ^&#125; indicates exponentiation.</span></span><br><span class="line"><span class="comment">   * (The hash value of the empty string is zero.)</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span>  a hash code value for this object.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> hash;</span><br><span class="line">      <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="type">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">              h = <span class="number">31</span> * h + val[i];</span><br><span class="line">          &#125;</span><br><span class="line">          hash = h;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> h;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从上面的源码中，我们不难发现<code>String</code>类已经重写了<code>equals()</code>方法和<code>hashCode()</code>方法。</p><p><code>String</code>类重写的<code>equals()</code>方法判断流程如下：</p><blockquote><ol><li>使用<code>==</code>来判断两个对象的内存地址是否相同，相同返回<code>true；</code></li><li>如果两个对象的内存地址不同，程序继续往下走，判断另一个对象是否是<code>String</code>类型的；</li><li>如果比较对象不是<code>String</code>类型，直接返回<code>false</code>；</li><li>如果是<code>String</code>类型的，进行类型强转；</li><li>比较两个<code>String</code>的字符数组长度，如果长度不同，返回<code>false</code>；</li><li>利用<code>while</code>循环来逐位比较字符是否相等，直到循环结束，所有字符都相等，则返回<code>true</code>，否则返回<code>false</code>;</li></ol></blockquote><p>下面来看一下重写的<code>hashCode()</code>方法。</p><blockquote><ol><li>首先<code>String</code>类中定义了一个<code>int</code>类型的变量<code>hash</code>用来缓存<code>String</code>对象的<code>hash</code>值；</li><li>如果当前调用<code>hashCode()</code>方法的<code>String</code>对象在常量池没有找到，并且该对象的<code>length</code>长度大于<code>0</code>,则继续往下走，否则返回<code>0</code>;即<code>String</code>类默认<code>&quot;&quot;</code>字符串的<code>hashCode()</code>值为<code>0</code>;</li><li>遍历字符数组，获取每一个字符的<code>ASCII</code>码表对应的值 和之前的<code>hash</code>值相加，这样就保证了相同的字符串的<code>hashCode()</code>返回值相同，计算公式在注释里已经写出来了：**<code>s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]</code>**</li><li>将计算出来的结果保存到<code>hash</code>变量中，并返回该值；</li></ol></blockquote><p>这里为什么要乘以<code>31</code>呢？原因是为了<strong>性能</strong>，不仅仅指降低了计算速度，也降低了哈希冲突的概率。</p><blockquote><p> 哈希冲突：此处指不同的字符串生成了相同的<code>hashCode</code>值。</p></blockquote><p><code>31</code>是一个<strong>奇素数</strong>。如果乘数是偶数，并且乘法溢出的话，信息就会丢失，因为与2相乘等价于移位运算（低位补<code>0</code>）。使用素数的好处并不很明显，但是习惯上使用素数来计算散列结果。 <strong><code>31</code> 有个很好的性能，即用移位和减法来代替乘法</strong>，可以得到更好的性能： <code>31 * i == (i &lt;&lt; 5）- i</code>， 现代的 <code>VM</code>  可以自动完成这种优化。这个公式可以很简单的推导出来。 —- 《<code>Effective Java</code>》 </p><blockquote><p>素数：质数又称素数，指在一个大于1的自然数中，除了1和此整数自身外，没法被其他自然数整除的数。 </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/post/4a17b156.html"/>
      <url>/post/4a17b156.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue项目中实现回车登录</title>
      <link href="/post/8184ba83.html"/>
      <url>/post/8184ba83.html</url>
      
        <content type="html"><![CDATA[<h3 id="Vue项目中实现回车登录"><a href="#Vue项目中实现回车登录" class="headerlink" title="Vue项目中实现回车登录"></a>Vue项目中实现回车登录</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">created</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">let</span> that = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">onkeypress</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> keycode = <span class="variable language_">document</span>.<span class="property">all</span> ? event.<span class="property">keyCode</span> : e.<span class="property">which</span>;</span><br><span class="line">      <span class="keyword">if</span> (keycode == <span class="number">13</span>) &#123;<span class="comment">// 回车键对应值为13</span></span><br><span class="line">        that.<span class="title function_">login</span>();<span class="comment">// 登录方法名</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>The literal 10000000000 of type int is out of range</title>
      <link href="/post/b2df998f.html"/>
      <url>/post/b2df998f.html</url>
      
        <content type="html"><![CDATA[<p><img src="data:image/png;base64,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" alt="image"><br>出现上述报错的主要原因是：  </p><blockquote><p>Java中默认整数为int类型，虽然图片中的数字未超过long类型的最大值，但由于默认整数为int类型，该数超过了int类型的最大值，所以报错；  </p></blockquote><h4 id="解决方法如下："><a href="#解决方法如下：" class="headerlink" title="解决方法如下："></a>解决方法如下：</h4><blockquote><p>在声明时，在数字的后面添加<font color="red">l</font>或者<font color="red">L</font>即可，建议添加<font color="red">L</font>，更容易区别</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 踩坑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>unix时间戳转时间</title>
      <link href="/post/3b7df5c1.html"/>
      <url>/post/3b7df5c1.html</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String unixTimeStr=  <span class="string">&quot;1572251400&quot;</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">s</span> <span class="operator">=</span> Long.parseLong(unixTimeStr);</span><br><span class="line">s *= <span class="number">1000</span>; <span class="comment">// 乘以1000，变成毫秒</span></span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> t.format(<span class="keyword">new</span> <span class="title class_">Date</span>(s));</span><br><span class="line">System.out.println(date); <span class="comment">//2019-10-28 16:30:00</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 时间戳 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS中this的指向</title>
      <link href="/post/b0088be2.html"/>
      <url>/post/b0088be2.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>JS中this的指向</p></blockquote><pre><code> 1. 以函数形式调用时，this是window 2. 以方法形式调用时，this是调用方法的对象 3. 以构造函数形式调用时，this是新建的那个对象 4. 使用call()和apply()调用时，this是指定的那个对象</code></pre><p>在调用函数时，浏览器每次都会传递两个隐含的参数<br>    1. 函数的上下文对象this<br>    2. 封装实参的对象arguments<br>        – arguments是一个类数组对象(不是数组)，它可以用过索引来操作数据，也可以获取长度<br>        – 在调用函数时，我们所传递的实参都会保存在arguments中<br>        – 即使在函数中不定义形参，也可以通过arguments来进行操作，只是相对而言麻烦一些</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String类的常用方法</title>
      <link href="/post/1e0a855.html"/>
      <url>/post/1e0a855.html</url>
      
        <content type="html"><![CDATA[<h3 id="String类的常用方法"><a href="#String类的常用方法" class="headerlink" title="String类的常用方法"></a>String类的常用方法</h3><blockquote><p><strong>split(“reg”)</strong><br>将字符串以reg为分隔符进行分割，返回一个String类型的数组    </p></blockquote><blockquote><p><strong>replace(char oldChar, char newChar)</strong><br>替换字符串中的字符，返回一个新的String类型的变量  </p></blockquote><blockquote><p><strong>replaceAll(String regex,String replacement)</strong><br>基于正则表达式的替换,比如，可以通过<code>replaceAll("\d", "*")</code>把一个字符串所有的数字字符都换成星号;如果参数不是基于正则表达式的，那么效果和replace()相同</p></blockquote><blockquote><p><strong>replaceFirst(String regex,String replacement)</strong><br>基于正则表达式的替换,只替换第一次出现的</p></blockquote><blockquote><p><strong>trim()</strong><br>去除字符串首尾的空格，返回一个新的String类型的变量  </p></blockquote><blockquote><p><strong>equals()</strong><br>比较两个String类型变量的内容是否相同，区分大小写  </p></blockquote><blockquote><p><strong>equalsIgnoreCase()</strong><br>和equals()方法的作用相同，只是忽略大小写  </p></blockquote><blockquote><p><strong>substring(fromTndex,toIndex)</strong><br>字符串截取，包含包含起始位置，不包含结束位置<br>如果只有起始位置，没有结束位置，就返回从起始位置到字符串的末尾  </p></blockquote><blockquote><p><strong>charAt(int index)</strong><br>返回字符串中指定位置的字符，Char类型   </p></blockquote><blockquote><p><strong>boolean statWith(String prefix)</strong><br>判断字符串是是否是以prefix为开始，是返回true，否返回false  </p></blockquote><blockquote><p><strong>boolean endWith(String suffix)</strong><br>判断字符串是是否是以suffix为结束，是返回true，否返回false  </p></blockquote><blockquote><p><strong>String toLowerCase()</strong><br>返回将当前字符串中所有字符转换成小写后的新串</p></blockquote><blockquote><p><strong>String toUpperCase()</strong><br>返回将当前字符串中所有字符转换成大写后的新串  </p></blockquote><blockquote><p><strong>contains(String str)</strong><br>判断参数s是否被包含在字符串中，是返回true，否返回false  </p></blockquote><blockquote><p><strong>int indexOf(int ch/String str)</strong><br>用于查找当前字符串中字符或子串，返回字符或子串在当前字符串中从左边起首次出现的位置，若没有出现则返回-1</p></blockquote><blockquote><p><strong>indexOf(int ch/String str, int fromIndex)</strong><br>从fromIndex位置向后查找  </p></blockquote><blockquote><p><strong>lastIndexOf(int ch/String str)</strong><br>从字符串的末尾位置向前查找  </p></blockquote><h3 id="字符串与基本类型的转换"><a href="#字符串与基本类型的转换" class="headerlink" title="字符串与基本类型的转换"></a>字符串与基本类型的转换</h3><pre>int n = Integer.parseInt("12");  float f = Float.parseFloat("12.34");  double d = Double.parseDouble("1.124");</pre>  <pre>String a = String.valueOf(12);String b = String.valueOf(13.14);</pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux环境工作常用命令</title>
      <link href="/post/5b3efa13.html"/>
      <url>/post/5b3efa13.html</url>
      
        <content type="html"><![CDATA[<h3 id="Linux环境工作常用命令"><a href="#Linux环境工作常用命令" class="headerlink" title="Linux环境工作常用命令"></a>Linux环境工作常用命令</h3><code>  cd /  进入根目录  mkdir dirName  创建文件夹    touch fileName  创建一个空文件vi/vim fileName 编辑一个文件，如果文件不存在，则会新建该文件  mv fileName/dirName 剪切/修改 文件或者文件夹的名称  cp -r sourceDirPath targetDirPath  复制文件夹，会将子文件夹一并复制  tail -numf fileName  查看文件末尾num行，可以动态刷新文件，用于查看日志  && 命令连接符 可以多条命令连接起来，从左到右执行ps -ef|grep processName  查看某个进程的状态kill -9 processId 根据进程ID杀进程  rm -rf fileName/dirName/dirPath 强制删除某个文件或者文件夹下所有内容，请慎用。如果不要强制，则去掉f  ssh userName@HostIP  ssh远程连接  ls -l | grep "^-" | wc -l 查看文件夹下文件个数（不包括子文件夹）  scp -r  local_file remote_username@remote_ip:remote_folder  从本地复制到远程（从远程复制到本地，只需要将两个参数的位置调换一下）  解压命令  tar -xvf file.tar //解压 tar包  tar -xzvf file.tar.gz //解压tar.gz  tar -xjvf file.tar.bz2   //解压 tar.bz2  tar -xZvf file.tar.Z   //解压tar.Z  unrar e file.rar //解压rar  unzip file.zip //解压zip</code>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程和线程</title>
      <link href="/post/6ac22eb.html"/>
      <url>/post/6ac22eb.html</url>
      
        <content type="html"><![CDATA[<p>记录：  </p><h2 id="多任务操作系统的实现方式"><a href="#多任务操作系统的实现方式" class="headerlink" title="多任务操作系统的实现方式"></a>多任务操作系统的实现方式</h2><blockquote><p>单核cpu  </p><p>  操作系统让cpu轮流交替执行任务，因为cpu的执行效率远高于计算机内的其他组件，所以让人感觉有多个任务在同时进行，实际上确定的时间点上，cpu只执行某一个任务。    </p><p>多核cpu  </p><p> 多个核心的cpu可在真正意义上实现多任务执行。但由于任务数量会超过cpu的核心数，所以操作系统也会自动把很多任务轮流调度到每个核心上执行。 </p></blockquote><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><p>进程：  </p><blockquote><p> 对于操作系统来说，一个任务就是一个进程（Process），比如打开一个浏览器就是启动一个浏览器进程，打开一个记事本就启动了一个记事本进程，打开两个记事本就启动了两个记事本进程，打开一个Word就启动了一个Word进程。  </p></blockquote><p>线程：</p><blockquote><p>有些进程还不止同时干一件事，比如Word，它可以同时进行打字、拼写检查、打印等事情。在一个进程内部，要同时干多件事，就需要同时运行多个“子任务”，我们把进程内的这些“子任务”称为线程（Thread）</p></blockquote><p>小结</p><blockquote><p>线程是最小的执行单元，而进程由至少一个线程组成。如何调度进程和线程，完全由操作系统决定，程序自己不能决定什么时候执行，执行多长时间  </p><p>进程和线程都是一个时间段的描述，是CPU工作时间段的描述<br>CPU+RAM+各种资源（比如显卡，光驱，键盘，GPS, 等等外设）构成我们的电脑，但是电脑的运行，实际就是CPU和相关寄存器以及RAM之间的事情。<br>一个最最基础的事实：CPU太快，太快，太快了，寄存器仅仅能够追的上他的脚步，RAM和别的挂在各总线上的设备完全是难以望其项背。那当多个任务要执行的时候怎么办呢？轮流着来?或者谁优先级高谁来？不管怎么样的策略，一句话就是在CPU看来就是轮流着来。</p></blockquote><blockquote><p>一个必须知道的事实：执行一段程序代码，实现一个功能的过程介绍 ，当得到CPU的时候，相关的资源必须也已经就位，就是显卡啊，GPS啊什么的必须就位，然后CPU开始执行。这里除了CPU以外所有的就构成了这个程序的执行环境，也就是我们所定义的程序上下文。当这个程序执行完了，或者分配给他的CPU执行时间用完了，那它就要被切换出去，等待下一次CPU的临幸。在被切换出去的最后一步工作就是保存程序上下文，因为这个是下次他被CPU临幸的运行环境，必须保存。</p></blockquote><blockquote><p>串联起来的事实：前面讲过在CPU看来所有的任务都是一个一个的轮流执行的，具体的轮流方法就是：先加载程序A的上下文，然后开始执行A，保存程序A的上下文，调入下一个要执行的程序B的程序上下文，然后开始执行B,保存程序B的上下文。。。。</p></blockquote><blockquote><p>========= 重要的东西出现了========  </p></blockquote><p>进程和线程就是这样的背景出来的，两个名词不过是对应的CPU时间段的描述，名词就是这样的功能。<br>进程就是包换上下文切换的程序执行时间总和 = CPU加载上下文+CPU执行+CPU保存上下文<br>线程是什么呢？<br>进程的颗粒度太大，每次都要有上下的调入，保存，调出。如果我们把进程比喻为一个运行在电脑上的软件，那么一个软件的执行不可能是一条逻辑执行的，必定有多个分支和多个程序段，就好比要实现程序A，实际分成 a，b，c等多个块组合而成。那么这里具体的执行就可能变成：</p><blockquote><p>程序A得到CPU =》CPU加载上下文，开始执行程序A的a小段，然后执行A的b小段，然后再执行A的c小段，最后CPU保存A的上下文。</p></blockquote><blockquote><p>这里a，b，c的执行是共享了A的上下文，CPU在执行的时候没有进行上下文切换的。这里的a，b，c就是线程，也就是说线程是共享了进程的上下文环境，的更为细小的CPU时间段。</p></blockquote><blockquote><p>到此全文结束，再一个总结：</p></blockquote><blockquote><p>进程和线程都是一个时间段的描述，是CPU工作时间段的描述，不过是颗粒大小不同。</p></blockquote><blockquote><p>进程是资源分配的最小单位，线程是CPU调度的最小单位</p></blockquote><h3 id="Java中的参数传值方式—-值传递"><a href="#Java中的参数传值方式—-值传递" class="headerlink" title="Java中的参数传值方式—-值传递"></a>Java中的参数传值方式—-值传递</h3><blockquote><p>Java中传递参数时：      </p><p>基本类型：复制一份该参数的实际值，传递<br>引用类型：复制一份该引用类型的引用的值，传递</p></blockquote><h3 id="Java中的四种引用"><a href="#Java中的四种引用" class="headerlink" title="Java中的四种引用"></a>Java中的四种引用</h3><blockquote><p>强引用  </p><p>指创建一个对象并把这个对象赋给一个引用变量比如 Object object = new Object();String a = “test”;<br>这样生成的对象一直到该方法执行结束之后才会回收，否则永远都不会回收  </p></blockquote><blockquote><p>软引用  </p></blockquote><pre name="code" class="java">if(i > 0){    System.out.println("it is a test for markdown");}</pre>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中到底是值传递还是引用传递</title>
      <link href="/post/4338db12.html"/>
      <url>/post/4338db12.html</url>
      
        <content type="html"><![CDATA[<h2 id="Java中到底是值传递还是引用传递？"><a href="#Java中到底是值传递还是引用传递？" class="headerlink" title="Java中到底是值传递还是引用传递？"></a>Java中到底是值传递还是引用传递？</h2><p>我们先回顾一下基本概念</p><h3 id="实参和形参"><a href="#实参和形参" class="headerlink" title="实参和形参"></a>实参和形参</h3><p>参数在编程语言中是执行程序需要的数据，这个数据一般保存在变量中。在Java中定义一个方法时，可以定义一些参数，<br>举个例子：    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">myName</span> <span class="operator">=</span> <span class="string">&quot;hawk&quot;</span>;</span><br><span class="line">sayYourName(myName);<span class="comment">// 实际参数是myName</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sayYourName</span><span class="params">(String name)</span> &#123;<span class="comment">// 形式参数是name</span></span><br><span class="line">System.out.println(name);</span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中定义一个名为sayYourName的方法，如果想要执行这个方法，那么你需要传入一个String类型的变量给这个方法，定义这个方法时声明的String类型的name就是形式参数，而在这个方法执行时传入的myName就是实际参数。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><blockquote><p>实际参数是调用有参方法的时候真正传递的内容，而形式参数是用于接收实参内容的参数。  </p></blockquote><h3 id="传参的几种方式"><a href="#传参的几种方式" class="headerlink" title="传参的几种方式"></a>传参的几种方式</h3><p> 按值传递(call by value)  </p><blockquote><p>按值传递，就是指在调用函数时，将实参对应的值做一个拷贝指向函数对应的形参。在函数内改变形参对应的值并不会影响外部实参的值  </p></blockquote><p> 按引用传递 (call by reference)</p><blockquote><p>按引用传递，是指在调用函数时，传递给函数的是实参的地址即引用，而不是实参的拷贝。在函数内部参数的值，对外部的实参是可见的。  </p></blockquote><p>按共享传递 （call by sharing）  </p><blockquote><p>按共享传递，是指在调用函数时，传递给函数的是实参的地址的拷贝（如果实参在栈中，则直接拷贝该值）。在函数内部对参数进行操作时，需要先拷贝的地址寻找到具体的值，再进行操作。如果该值在栈中，那么因为是直接拷贝的值，所以函数内部对参数进行操作不会对外部变量产生影响。如果原来拷贝的是原值在堆中的地址，那么需要先根据该地址找到堆中对应的位置，再进行操作。因为传递的是地址的拷贝所以函数内对值的操作对外部变量是可见的。  </p></blockquote><blockquote><p>按共享传递可以理解为<strong>按值传递</strong>的一个特例，这里的值是对象的引用地址，而不是具体对象。  </p></blockquote><p>上面描述的传参方式实际上是函数调用时参数的求值策略(Evaluation Strategy)，这个其实比较好理解，比如我们调用上面的sayYourName()方法<br>我们可以这样：sayYourName(“hawk”);<br>可以这样:sayYourName(“ha”+”wk”);<br>可以这样：sayYourName(“hawk”+x.subString(2));// 此处的x是一个变量,进行截取后和”hawk”合并    </p><p>但是所有这些实参的形式，都统称为表达式(Expression)。求值（Evaluation）即是指对这些表达式的简化并求解其值的过程。</p><p>求值策略(值传递和引用传递)的关注的点在于，这些表达式在调用函数的过程中，求值的时机、值的形式的选取等问题。求值的时机，可以是在函数调用前，也可以是在函数调用后，由被调用者自己求值。这里所谓调用后求值，可以理解为Lazy Load或On Demand的一种求值方式。<br>而且，除了按值传递和按引用传递，还有一些其它的求值策略。这些求值策略的划分依据是：求值的时机（调用前还是调用中）和值本身的传递方式。详见下表：  </p><table><tr>    <td>求值策略</td>    <td>求值时间</td>    <td>传值方式</td></tr><tr>    <td>按值传递( pass by value )</td>    <td>调用前</td>    <td>值的结果(只是结果的副本)</td></tr><tr>    <td>按引用传递( pass by reference )</td>    <td>调用前</td>    <td>原值(原始对象，无副本)</td></tr><tr>    <td>按名传递( pass by name )</td>    <td>调用后(用到才求值)</td>    <td>与值无关的一个名</td></tr></table>  <p><strong>按值传递和按引用传递在行为表现上的差异如下：</strong>  </p><table><tr>    <td></td>    <td>按值传递</td>    <td>按引用传递</td></tr><tr>    <td>本质区别</td>    <td>创建副本</td>    <td>不创建副本</td></tr><tr>    <td>表现结果</td>    <td>函数中无法改变原始对象</td>    <td>函数中可以改变原始对象</td></tr></table>**这里面的改变，是指把一个变量指向另一个对象，而不是指仅仅改变属性或者成员什么的**  <p>只要是按值传递，不管传递的参数类型是值类型还是引用类型，都会在调用栈上面创建一个实参的副本，区别只是如果传递的参数类型是值类型，该副本就是实际参数的值的复制，而对于引用类型来说，引用类型的实例(即对象)是保存在堆中的，在栈上只有一个该实例的引用（一般情况下是该实例在堆中的内存地址），此时，实际参数的副本并不是该对象，而是引用的副本。</p><p><strong>所以，综上所述，对于Java的函数调用方式最准确的描述是：参数藉由值传递方式，传递的值是个引用。（句中两个“值”不是一个意思，第一个值是evaluation result，第二个值是value content）</strong></p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>说到Java是值传递还是引用传递，一般都会举下面三个例子，我们来一一说明一下：<br>第一个例子，基本类型参数传值：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">changeValue(i);</span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">changeValue</span><span class="params">(<span class="type">int</span> a )</span> &#123;</span><br><span class="line">a = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>上面的代码解释如下：<br>定义了一个int类型的变量i，并赋值为10<br>调用changeValue方法，传入i，changeValue方法将传入的变量赋值为20<br>输出i  </p><p>结果是：<strong>10</strong><br>changValue方法内部对<strong>形参a</strong>的修改并没有影响到<strong>实参i</strong><br><strong>第一个结论：Java中基本类型的传值方式是按值传递</strong>  </p><p>第二个例子，引用类型传值：    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">i</span> <span class="operator">=</span> <span class="string">&quot;hawk&quot;</span>;</span><br><span class="line">changString(i);</span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">changString</span><span class="params">(String a )</span> &#123;</span><br><span class="line">a = <span class="string">&quot;HAWK&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>上面的代码解释如下：<br>定义一个String类型的变量i，赋值为”hawk”<br>调用changeString方法，将传入的变量赋值为”HAWK”<br>输出i  </p><p>结果： <strong>hawk</strong><br>在Java中String类型虽然可以直接赋值，但是是引用类型，<strong>因为String类型的具体值保存在堆中，而不是栈上</strong><br>既然String是引用类型， 上面的例子又说明String是值传递的  那么我们是不是就可以得出：<br><strong>Java中引用类型也是值传递的</strong>，这样的结论呢？  </p><p>我们来看第三个例子：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Example</span> <span class="variable">ex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Example</span>();</span><br><span class="line">changValue(ex);</span><br><span class="line">System.out.println(ex.i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">changValue</span><span class="params">(Example e )</span> &#123;</span><br><span class="line">e.i = <span class="number">30</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>上面的代码解释如下：<br>实例化一个Example对象ex，ex中只有一个属性i，初始值为20<br>调用changValue方法，将ex中的属性i的值赋值为30<br>输出ex中属性i的值  </p><p>结果是：<strong>30</strong><br>这样的结果就让很多人产生了困惑，String类型是引用类型，对象也是引用类型，为什么第二个例子不能改变i的值，第三个例子却改变了ex中i的值呢？<strong>Java中引用类型的参数传递到底是引用传递还是值传递呢？</strong>  </p><p>其实，第二个例子和第三个例子我们所关注的点已经是错误的了，自然无法得出正确的结论<br>我们回顾一下<strong>引用传递和值传递的本质区别和行为表现上的区别</strong> </p><table><tr>    <td></td>    <td>按值传递</td>    <td>按引用传递</td></tr><tr>    <td>本质区别</td>    <td>创建副本</td>    <td>不创建副本</td></tr><tr>    <td>表现结果</td>    <td>函数中<b>无法改变原始对象</b></td>    <td>函数中<b>可以改变原始对象</b></td></tr></table>注意到了吗？我们应该关注的是**原始对象的变化**  > **Java中，引用类型的原始对象（即原始值）是保存在堆中的，变量中存储的是原始值的引用（Java中存储的是该对象在堆中的内存地址），**> **该引用指向堆中的对象,所以我们<font color="red">关注的关键点应该是对象的引用有没有发生变化</font>，而不是原始对象中的内容有没有发生变化**<p><strong><font color="red">重要依据：</font>如果可以改变对象的引用，就说明是引用传递，如果不能改变对象的引用就说明是值传递</strong><br>下面我们多举一个例子： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Example</span> <span class="variable">ex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Example</span>();</span><br><span class="line">changValue(ex);</span><br><span class="line">System.out.println(ex.i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">changValue</span><span class="params">(Example e )</span> &#123;</span><br><span class="line">e = <span class="keyword">new</span> <span class="title class_">Example</span>();</span><br><span class="line">e.i = <span class="number">50</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>这个例子和上面第三个例子很相似，区别在于：<br>changValue方法中将一个新的原始对象的引用赋值给了形参e<br><strong>如果Java是按引用传递的话，e = new Example();就是修改了实参ex的引用，即就是改变了原始对象<br>如果Java是按值传递的话，实参ex不会有任何变化</strong>  </p><p>结果：<strong>20</strong>  </p><p>这个结果说明：<strong>changValue方法并没有修改到ex的引用，也就是说，e只是ex的副本，对e的引用进行的所有操作都不会影响到ex，所以我们<br>从上述代码运行的结果也可以证明Java中是只有值传递的</strong></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.hollischuang.com/archives/2275" target="_blank">为什么说Java中只有值传递</a><br><a href="http://menzhongxin.com/2017/02/07/%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92-%E6%8C%89%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E5%92%8C%E6%8C%89%E5%85%B1%E4%BA%AB%E4%BC%A0%E9%80%92/" target="_blank">按值传递、按引用传递、按共享传递</a><br><a href="https://www.zhihu.com/question/20628016/answer/28970414" target="_blank">为什么 Java 只有值传递，但 C# 既有值传递，又有引用传递，这种语言设计有哪些好处？</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
