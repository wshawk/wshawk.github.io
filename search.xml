<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title></title>
      <url>/2022/10/18/Github%E6%90%AD%E5%BB%BAHexo%E5%8F%8C%E5%88%86%E6%94%AF%E5%8D%9A%E5%AE%A2%E9%98%B2%E6%AD%A2%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E4%B8%A2%E5%A4%B1/</url>
      <content type="html"><![CDATA[<blockquote>
<p>转载于： <a href="https://www.jianshu.com/p/7d8df0de1fc7" target="_blank" rel="noopener">Github搭建Hexo双分支博客防止本地文件丢失</a></p>
</blockquote>
<h1 id="一、关于搭建流程"><a href="#一、关于搭建流程" class="headerlink" title="一、关于搭建流程"></a>一、关于搭建流程</h1><ol>
<li><p>创建仓库，Godbn.github.io</p>
</li>
<li><p>创建两个分支:master和hexo</p>
</li>
<li><p>在options里面设置hexo为默认分支(注意这个分支保存的是网站源文件，并不是生成后上传github上用于显示的)</p>
</li>
<li><p>使用以下命令拷贝仓库到本地桌面</p>
</li>
</ol>
<blockquote>
<p>git clone <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:Godbn/Godbn.github.io.git</p>
</blockquote>
<ol start="5">
<li>终端进入Godbn.github.io目录，依次执行</li>
</ol>
<blockquote>
<p>  npm install hexo</p>
<p>  hexo init</p>
<p>  npm install</p>
<p>  npm install hexo-deployer-git (用于生成上传至github)</p>
</blockquote>
<ol start="6">
<li>修改_config.yml中的deploy参数</li>
</ol>
<figure class="image-box">
                <img src="https:////upload-images.jianshu.io/upload_images/4797359-7085b85ebbfdd97d.png?imageMogr2/auto-orient/strip|imageView2/2/w/374/format/webp" alt="img" title class>
                <p>img</p>
            </figure>

<ol start="7">
<li>下载hexo themes主题自己百度安装调试好,我目前使用的是Sky，地址我贴出来</li>
</ol>
<blockquote>
<p><a href="https://github.com/iJinxin/hexo-theme-sky" target="_blank" rel="noopener">https://github.com/iJinxin/hexo-theme-sky</a></p>
</blockquote>
<ol start="8">
<li>依次执行以下三条命令提交网站相关的文件</li>
</ol>
<blockquote>
<p>git add .</p>
<p>git commit -m “…”</p>
<p>git push origin hexo</p>
</blockquote>
<ol start="9">
<li>执行hexo g -d 生成网站并部署到github上 (每次可以在前面输入 hexo clean 清理下)</li>
</ol>
<blockquote>
<p>hexo clean</p>
<p>hexo g -d</p>
</blockquote>
<h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><p><strong>分支hexo储存的是网站的原始文件</strong></p>
<p><strong>分支master用来储存生成的静态网页</strong></p>
<h1 id="二、日常改动"><a href="#二、日常改动" class="headerlink" title="二、日常改动"></a>二、日常改动</h1><h3 id="本地添加文章，样式等"><a href="#本地添加文章，样式等" class="headerlink" title="本地添加文章，样式等"></a>本地添加文章，样式等</h3><ol>
<li>依次执行以下命令git到分支hexo上</li>
</ol>
<blockquote>
<p>git add .</p>
<p>git commit -m “…”</p>
<p>git push origin hexo</p>
</blockquote>
<ol start="2">
<li>再执行以下命令发布网站到分支master</li>
</ol>
<blockquote>
<p>hexo g -d</p>
</blockquote>
<h1 id="三、其他电脑更新github博客"><a href="#三、其他电脑更新github博客" class="headerlink" title="三、其他电脑更新github博客"></a>三、其他电脑更新github博客</h1><ol>
<li>使用命令将仓库拷贝到本地</li>
</ol>
<blockquote>
<p>git clone <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:Godbn/Godbn.github.io.git</p>
</blockquote>
<ol start="2">
<li>在Godbn.github.io文件夹中通过以下恢复原始文件</li>
</ol>
<blockquote>
<p>npm install hexo</p>
<p>npm install</p>
<p>npm install hexo-deployer-git –save</p>
</blockquote>
<h1 id="四、结束"><a href="#四、结束" class="headerlink" title="四、结束"></a>四、结束</h1><p>以上是get到知乎上的回答搭建的</p>
<p>传送门：</p>
<blockquote>
<p><a href="https://www.zhihu.com/question/21193762" target="_blank" rel="noopener">https://www.zhihu.com/question/21193762</a></p>
</blockquote>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Java中的代理]]></title>
      <url>/2020/04/08/Java%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%90%86/</url>
      <content type="html"><![CDATA[<h3 id="Java中的代理"><a href="#Java中的代理" class="headerlink" title="Java中的代理"></a>Java中的代理</h3><pre><code>代理模式（Proxy）是通过代理对象访问目标对象，这样可以在目标对象基础上增强额外的功能，如添加权限，访问控制和审计等功能。 </code></pre><ul>
<li>增加额外功能，进行增强</li>
<li>引入第三方代理类，进行解耦</li>
</ul>
<blockquote>
<ol>
<li><strong>静态代理</strong></li>
</ol>
</blockquote>
<p>请参考下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*声明一个明星接口，明星只需要关注自己的唱、跳</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StarService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sing</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">jump</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*明星接口的具体实现类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StarServiceImpl</span> <span class="keyword">implements</span> <span class="title">StarService</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">" sing a song "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jump</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">" just dance "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*代理类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StarServiceProxy</span> <span class="keyword">implements</span> <span class="title">StarService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StarService starService;</span><br><span class="line">	<span class="comment">// 通过构造方法将目标实现类注入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StarServiceProxy</span><span class="params">(StarService starService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.starService = starService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"唱歌之前先联系综艺节目，确定时间、地点"</span>);</span><br><span class="line">        starService.sing();</span><br><span class="line">        System.out.println(<span class="string">"表演结束之后，安排下一场演出"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jump</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> starService.jump();</span><br><span class="line">        System.out.println(<span class="string">"跳舞之后，观众鼓掌"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StarService starService = <span class="keyword">new</span> StarServiceImpl();</span><br><span class="line">        StarServiceProxy proxy = <span class="keyword">new</span> StarServiceProxy(starService);</span><br><span class="line">        proxy.sing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输出：</span><br><span class="line"> 唱歌之前先联系综艺节目，确定时间、地点</span><br><span class="line">  sing a song </span><br><span class="line"> 表演结束之后，安排下一场演出</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>总结</strong>：</p>
<ul>
<li>静态代理模式在不改变目标对象的前提下，实现了对目标对象的功能扩展；</li>
<li>不足： 静态代理<strong>实现了目标对象的所有方法</strong>，一旦目标接口增加方法，代理对象和目标对象都要进行相应的修改，增加维护成本。 </li>
</ul>
</blockquote>
<blockquote>
<ol start="2">
<li><strong>动态代理</strong></li>
</ol>
</blockquote>
<p>Java中的动态代理需要<code>java.lang.reflect.InvocationHandler</code>接口和<code>java.lang.reflect.Proxy</code> 类的支持 。<strong><code>jdk</code>的动态代理是面向接口的，即<code>jdk</code>的动态代理只能代理实现接口的类，不能代理抽象类或者没有实现接口的类。</strong></p>
<p> <code>java.lang.reflect.InvocationHandler</code>接口的定义如下： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*	Object proxy   被代理的对象  </span></span><br><span class="line"><span class="comment">*	Method method  要调用的方法  </span></span><br><span class="line"><span class="comment">*	Object[] args  方法调用时所需要参数  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InvocationHandler</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>java.lang.reflect.Proxy</code>类的定义如下： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*	CLassLoader loader    类的加载器 </span></span><br><span class="line"><span class="comment">*	Class&lt;?&gt; interfaces   得到全部的接口  </span></span><br><span class="line"><span class="comment">*	InvocationHandler h   得到InvocationHandler接口的子类的实例</span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</span> <span class="keyword">throws</span> IllegalArgumentException</span></span><br></pre></td></tr></table></figure>

<p><code>jdk</code>动态代理流程：</p>
<ol>
<li>通过实现 <code>InvocationHandler</code>接口创建自己的调用处理器； </li>
<li>通过为 Proxy 类指定<code>ClassLoader</code> 对象和一组<code>interface</code>来创建动态代理类； </li>
<li>通过反射机制获得动态代理类的构造函数，其唯一参数类型是调用处理器接口类型； </li>
<li>通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数被传入。 </li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义中间代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YourHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 目标对象  </span></span><br><span class="line">    <span class="keyword">private</span> Object targetObject;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyHandler</span><span class="params">( Object proxied )</span> </span>&#123;   </span><br><span class="line">    	<span class="keyword">this</span>.proxied = proxied;   </span><br><span class="line">  	&#125;  </span><br><span class="line">    </span><br><span class="line">     <span class="comment">/*proxy表示代理目标对象，method表示原对象被调用的方法，args表示方法的参数*/</span>  </span><br><span class="line">    <span class="meta">@Ovrride</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">( Object proxy, Method method, Object[] args )</span> <span class="keyword">throws</span> Throwable </span>&#123;   </span><br><span class="line">    <span class="comment">//在转调具体目标对象之前，可以执行一些功能处理</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//转调具体目标对象的方法</span></span><br><span class="line">    <span class="keyword">return</span> method.invoke( proxy, args);  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在转调具体目标对象之后，可以执行一些功能处理</span></span><br><span class="line">  		&#125;    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>实际应用时代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RealSubject  要代理的目标对象</span></span><br><span class="line">RealSubject real = <span class="keyword">new</span> RealSubject(); </span><br><span class="line"><span class="comment">// Subject 目标对象实现的接口</span></span><br><span class="line">    Subject proxySubject =   	(Subject)Proxy.newProxyInstance(Subject.class.getClassLoader(), </span><br><span class="line">     <span class="keyword">new</span> Class[]&#123;Subject.class&#125;, </span><br><span class="line">     <span class="keyword">new</span> YourHandler(real));</span><br><span class="line"> <span class="comment">// proxySubject 为中间代理类        </span></span><br><span class="line">    proxySubject.method( Object[] args);</span><br></pre></td></tr></table></figure>

<blockquote>
<ol start="3">
<li><strong><code>Cglib</code>代理</strong></li>
</ol>
</blockquote>
<p>​        Cglib代理补充了jdk中只面向接口进行代理的不足，Cglib代理支持基于对象代理，不用关心该对象是否实现了某个接口。 Cglib是一个java字节码的生成工具，它动态生成一个被代理类的子类，子类重写被代理的类的所有不是final的方法。在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。 </p>
<p>以上面的<code>StarServiceImpl</code>为被代理对象，举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  自定义中间代理类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMethodInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"Before: "</span>  + method.getName());</span><br><span class="line">        Object object = methodProxy.invokeSuper(o, objects);</span><br><span class="line">        System.out.println(<span class="string">"After: "</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试如下</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">//继承被代理类</span></span><br><span class="line">        enhancer.setSuperclass(Star.class);</span><br><span class="line">        <span class="comment">//设置回调</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> MyMethodInterceptor());</span><br><span class="line">        <span class="comment">//设置代理类对象</span></span><br><span class="line">        StarServiceImpl starService = (StarServiceImpl) enhancer.create();</span><br><span class="line">        <span class="comment">//在调用代理类中方法时会被我们实现的方法拦截器进行拦截</span></span><br><span class="line">        starService.sing();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输出结果如下：</span><br><span class="line">    Before: sing</span><br><span class="line">	sing a song</span><br><span class="line">	After: sing</span><br></pre></td></tr></table></figure>

]]></content>
      
        
        <tags>
            
            <tag> java 代理  动态代理 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java知识点总结]]></title>
      <url>/2020/04/08/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h2 id="Java知识点总结"><a href="#Java知识点总结" class="headerlink" title="Java知识点总结"></a>Java知识点总结</h2><h3 id="1-类的初始化顺序"><a href="#1-类的初始化顺序" class="headerlink" title="1.  类的初始化顺序"></a>1.  类的初始化顺序</h3><ol>
<li>父类静态变量（静态代码块）</li>
<li>子类静态变量（静态代码块）</li>
<li>父类成员变量</li>
<li>父类构造方法</li>
<li>子类成员变量</li>
<li>子类构造方法</li>
</ol>
<h3 id="2-final修饰符"><a href="#2-final修饰符" class="headerlink" title="2. final修饰符"></a>2. final修饰符</h3><ul>
<li><p>修饰变量， 必须显示地赋初值，且赋初值后不能再赋值</p>
<blockquote>
<p>被final修饰的实例变量必须显示地赋初值，且只能以下三种方式：</p>
<p>　　1.  定义时初始化</p>
<p>　　2.  在非静态初始化块中为final实例变量指定初始值</p>
<p>　　3.  在构造器中指定初始值</p>
<p>final修饰的静态变量只能在两个地方进行初始化</p>
<ol>
<li>定义final类变量时指定初始值 </li>
<li>在静态初始化块中为final类变量指定初始值 </li>
</ol>
</blockquote>
</li>
<li><p>修饰方法，该方法不能被重写</p>
</li>
<li><p>修饰类，该类不能被继承   </p>
</li>
</ul>
<h3 id="3-static修饰符"><a href="#3-static修饰符" class="headerlink" title="3.  static修饰符"></a>3.  static修饰符</h3><ul>
<li><p>修饰变量，被<code>static</code>修饰的变量实质上就是全局变量，<strong>所有的类实例（对象），共享该变量</strong>；且该变量可以以<code>类名.变量名</code>的方式进行访问</p>
</li>
<li><p>修饰方法，该方法被称为静态方法，可直接使用<code>类名.静态方法名</code>进行调用，不需要实例化对象。</p>
<blockquote>
<p>静态方法有以下特点：</p>
<ul>
<li>只能访问<code>static</code>变量</li>
<li>只能调用其他<code>static</code>方法</li>
<li>不能使用<code>this</code>或者<code>super</code>关键字，因为这两个关键字都是需要绑定对象</li>
</ul>
</blockquote>
</li>
<li><p><code>static</code>一般不能修饰类，只能修饰<strong>内部类</strong></p>
</li>
<li><p><code>import static com.*.ClassName.*</code>，静态导入所需要的静态变量，从<code>jdk5</code>开始。</p>
</li>
</ul>
<h3 id="4-private修饰构造方法"><a href="#4-private修饰构造方法" class="headerlink" title="4. private修饰构造方法"></a>4. private修饰构造方法</h3><ul>
<li><code>private</code>修饰的构造方法只能在本类里调用</li>
</ul>
<h3 id="5-重写和重载"><a href="#5-重写和重载" class="headerlink" title="5. 重写和重载"></a>5. 重写和重载</h3><ul>
<li>重写（覆写）：方法名相同，接收参数相同，返回结果相同，处理逻辑不同，发生在子类和父类之间。</li>
<li>重载（覆载）：方法名相同，接收参数不同，返回结果可以不同，发生在一个类中。</li>
</ul>
<h3 id="6-反射"><a href="#6-反射" class="headerlink" title="6. 反射"></a>6. 反射</h3><ul>
<li><code>java</code>反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为<code>java</code>语言的反射机制。</li>
</ul>
<h3 id="7-反射的应用场景"><a href="#7-反射的应用场景" class="headerlink" title="7.  反射的应用场景"></a>7.  反射的应用场景</h3><p>​        平时的业务开发中，很少用到反射，但是*<em>反射是框架设计的灵魂 *</em>，很多框架都用到了反射。</p>
<p>举例如下：</p>
<ul>
<li><p>我们在使用<code>JDBC</code>连接数据库时使用<code>Class.forName()</code>通过反射加载数据库的驱动程序； </p>
</li>
<li><p>动态代理；</p>
</li>
<li><p>Spring框架也用到很多反射机制，最经典的就是<code>xml</code>的配置模式；</p>
<blockquote>
<p>Spring 通过 <code>xml</code>配置模式装载 Bean 的过程：</p>
<ul>
<li>将程序内所有 <code>xml</code>或 <code>properties</code>配置文件加载入内存中;  </li>
<li>Java类里面解析<code>xml</code>或<code>properties</code>里面的内容，得到对应实体类的字节码字符串以及相关的属性信息;  </li>
<li>使用反射机制，根据这个字符串获得某个类的Class实例; </li>
<li>动态配置实例的属性。 </li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="8-short、int类型提升"><a href="#8-short、int类型提升" class="headerlink" title="8.short、int类型提升"></a>8.<code>short</code>、<code>int</code>类型提升</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> a = <span class="number">1</span>;</span><br><span class="line">a = a + <span class="number">1</span>; </span><br><span class="line"><span class="comment">/* 编译报错（原因：使用 + 运算符，会使得short类型自动提升为int类型，int类型的值范围大于short），所以可能</span></span><br><span class="line"><span class="comment"> * 会出现超出范围的报错，故编译不通过</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">a += <span class="number">1</span>; <span class="comment">//编译通过，java中对 += 做了特殊处理</span></span><br></pre></td></tr></table></figure>

<h3 id="9-String不变性"><a href="#9-String不变性" class="headerlink" title="9. String不变性"></a>9. <code>String</code>不变性</h3><ul>
<li>String类是被final进行修饰的，不能被继承；</li>
<li>使用<code>+</code>运算符连接两个字符串时，会创建一个新的字符串；<code>+</code>运算符底层采用了<code>StringBuilder</code>实例的<code>append()</code>方法实现；</li>
<li><code>String s = new String(&quot;hello world&quot;);</code>可能创建两个对象，也可能创建一个对象。如果在静态区中有<code>&quot;hello world&quot;</code>字符串常量对象的话，则仅仅在堆中创建一个对象。如果在静态区中没有<code>&quot;hello world&quot;</code>对象，则在堆和静态区中都需要创建对象；</li>
</ul>
<h3 id="10-为什么重写equals-方法时，一定要重写hashCode-方法"><a href="#10-为什么重写equals-方法时，一定要重写hashCode-方法" class="headerlink" title="10.  为什么重写equals()方法时，一定要重写hashCode()方法"></a>10.  为什么重写<code>equals()</code>方法时，一定要重写<code>hashCode()</code>方法</h3><ul>
<li><p>因为关于<code>hashCode()</code>方法，一致约定是 </p>
<blockquote>
<ol>
<li><strong>如果两个对象通过<code>equals</code>调用后返回是<code>true</code>，那么这个两个对象的<code>hashCode</code>方法也必须返回同样的int型散列码;</strong></li>
<li><strong>如果两个对象通过equals返回false，他们的hashCode返回的值<font color="red">允许相同</font></strong>。(然而，程序员必须意识到，<code>hashCode</code>返回独一无二的散列码，会让存储这个对象的<code>hashTables</code>更好地工作。)</li>
</ol>
</blockquote>
</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[equals()方法和hashCode()方法详解]]></title>
      <url>/2020/04/07/equals()%E6%96%B9%E6%B3%95%E5%92%8ChashCode()%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h2 id="equals-方法和hashCode-方法详解"><a href="#equals-方法和hashCode-方法详解" class="headerlink" title="equals()方法和hashCode()方法详解"></a><code>equals()</code>方法和<code>hashCode()</code>方法详解</h2><h3 id="1-Object类中equals-方法源代码如下所示："><a href="#1-Object类中equals-方法源代码如下所示：" class="headerlink" title="1. Object类中equals()方法源代码如下所示："></a>1. <code>Object</code>类中<code>equals()</code>方法源代码如下所示：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*	Object类中的equals()方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 由以上源代码知，<code>Object</code>类中的<code>equals()</code>方法是直接使用<code>==</code>运算符来判断两个对象相等的。</p>
<ul>
<li>引用类型变量使用<code>==</code>时，比较的是引用类型变量指向的对象的内存地址</li>
<li>基本类型使用<code>==</code>时，比较值</li>
</ul>
</blockquote>
<p><code>Objcect</code>类中的<code>hashCode</code>源代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns a hash code value for the object. This method is</span></span><br><span class="line"><span class="comment">    * supported for the benefit of hash tables such as those provided by</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> java.util.HashMap&#125;.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * The general contract of &#123;<span class="doctag">@code</span> hashCode&#125; is:</span></span><br><span class="line"><span class="comment">    * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">    * &lt;li&gt;Whenever it is invoked on the same object more than once during</span></span><br><span class="line"><span class="comment">    *     an execution of a Java application, the &#123;<span class="doctag">@code</span> hashCode&#125; method</span></span><br><span class="line"><span class="comment">    *     must consistently return the same integer, provided no information</span></span><br><span class="line"><span class="comment">    *     used in &#123;<span class="doctag">@code</span> equals&#125; comparisons on the object is modified.</span></span><br><span class="line"><span class="comment">    *     This integer need not remain consistent from one execution of an</span></span><br><span class="line"><span class="comment">    *     application to another execution of the same application.</span></span><br><span class="line"><span class="comment">    * &lt;li&gt;If two objects are equal according to the &#123;<span class="doctag">@code</span> equals(Object)&#125;</span></span><br><span class="line"><span class="comment">    *     method, then calling the &#123;<span class="doctag">@code</span> hashCode&#125; method on each of</span></span><br><span class="line"><span class="comment">    *     the two objects must produce the same integer result.</span></span><br><span class="line"><span class="comment">    * &lt;li&gt;It is &lt;em&gt;not&lt;/em&gt; required that if two objects are unequal</span></span><br><span class="line"><span class="comment">    *     according to the &#123;<span class="doctag">@link</span> java.lang.Object#equals(java.lang.Object)&#125;</span></span><br><span class="line"><span class="comment">    *     method, then calling the &#123;<span class="doctag">@code</span> hashCode&#125; method on each of the</span></span><br><span class="line"><span class="comment">    *     two objects must produce distinct integer results.  However, the</span></span><br><span class="line"><span class="comment">    *     programmer should be aware that producing distinct integer results</span></span><br><span class="line"><span class="comment">    *     for unequal objects may improve the performance of hash tables.</span></span><br><span class="line"><span class="comment">    * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * As much as is reasonably practical, the hashCode method defined by</span></span><br><span class="line"><span class="comment">    * class &#123;<span class="doctag">@code</span> Object&#125; does return distinct integers for distinct</span></span><br><span class="line"><span class="comment">    * objects. (This is typically implemented by converting the internal</span></span><br><span class="line"><span class="comment">    * address of the object into an integer, but this implementation</span></span><br><span class="line"><span class="comment">    * technique is not required by the</span></span><br><span class="line"><span class="comment">    * Java&amp;trade; programming language.)</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>  a hash code value for this object.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span>     java.lang.Object#equals(java.lang.Object)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span>     java.lang.System#identityHashCode</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;<span class="comment">// java8中的hashCode方法，</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的注释中有说明如下几点：</p>
<ul>
<li>对象的<code>hashCode</code>值通常是根据对象的内存地址计算得来</li>
<li>两个对象<code>equals()</code>结果为<code>true</code>时，两个对象的<code>hashCode</code>值一定相等，不同对象的<code>hashCode</code>不等</li>
<li><code>native</code>标识此方法不是<code>java</code>语言实现</li>
</ul>
</blockquote>
<p><code>Object</code>类中的<code>toString()</code>方法源代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 从这里就能看出打印对象时不重写toString()方法时，就会打印出对象的hashCode值</span></span><br><span class="line">        <span class="keyword">return</span> getClass().getName() + <span class="string">"@"</span> + Integer.toHexString(hashCode());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-String类中equals-方法和hashCode-方法"><a href="#2-String类中equals-方法和hashCode-方法" class="headerlink" title="2. String类中equals()方法和hashCode()方法"></a>2. <code>String</code>类中<code>equals()</code>方法和<code>hashCode()</code>方法</h3><blockquote>
<p><code>String</code>类中部分源代码如下所示：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line"><span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 无参构造方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.value = <span class="string">""</span>.value;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 有参构造方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.value = original.value;</span><br><span class="line">      <span class="keyword">this</span>.hash = original.hash;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*String类重写的equals方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;<span class="comment">// 此处的this指向a.equals(b)的a对象，即谁调用指向谁</span></span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">          String anotherString = (String)anObject;</span><br><span class="line">          <span class="keyword">int</span> n = value.length;</span><br><span class="line">          <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">              <span class="keyword">char</span> v1[] = value;</span><br><span class="line">              <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">              <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">              <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                  i++;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns a hash code for this string. The hash code for a</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@code</span> String&#125; object is computed as</span></span><br><span class="line"><span class="comment">   * &lt;blockquote&gt;&lt;pre&gt;</span></span><br><span class="line"><span class="comment">   * s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]</span></span><br><span class="line"><span class="comment">   * &lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment">   * using &#123;<span class="doctag">@code</span> int&#125; arithmetic, where &#123;<span class="doctag">@code</span> s[i]&#125; is the</span></span><br><span class="line"><span class="comment">   * &lt;i&gt;i&lt;/i&gt;th character of the string, &#123;<span class="doctag">@code</span> n&#125; is the length of</span></span><br><span class="line"><span class="comment">   * the string, and &#123;<span class="doctag">@code</span> ^&#125; indicates exponentiation.</span></span><br><span class="line"><span class="comment">   * (The hash value of the empty string is zero.)</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span>  a hash code value for this object.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> h = hash;</span><br><span class="line">      <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">              h = <span class="number">31</span> * h + val[i];</span><br><span class="line">          &#125;</span><br><span class="line">          hash = h;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> h;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>从上面的源码中，我们不难发现<code>String</code>类已经重写了<code>equals()</code>方法和<code>hashCode()</code>方法。</p>
<p><code>String</code>类重写的<code>equals()</code>方法判断流程如下：</p>
<blockquote>
<ol>
<li>使用<code>==</code>来判断两个对象的内存地址是否相同，相同返回<code>true；</code></li>
<li>如果两个对象的内存地址不同，程序继续往下走，判断另一个对象是否是<code>String</code>类型的；</li>
<li>如果比较对象不是<code>String</code>类型，直接返回<code>false</code>；</li>
<li>如果是<code>String</code>类型的，进行类型强转；</li>
<li>比较两个<code>String</code>的字符数组长度，如果长度不同，返回<code>false</code>；</li>
<li>利用<code>while</code>循环来逐位比较字符是否相等，直到循环结束，所有字符都相等，则返回<code>true</code>，否则返回<code>false</code>;</li>
</ol>
</blockquote>
<p>下面来看一下重写的<code>hashCode()</code>方法。</p>
<blockquote>
<ol>
<li>首先<code>String</code>类中定义了一个<code>int</code>类型的变量<code>hash</code>用来缓存<code>String</code>对象的<code>hash</code>值；</li>
<li>如果当前调用<code>hashCode()</code>方法的<code>String</code>对象在常量池没有找到，并且该对象的<code>length</code>长度大于<code>0</code>,则继续往下走，否则返回<code>0</code>;即<code>String</code>类默认<code>&quot;&quot;</code>字符串的<code>hashCode()</code>值为<code>0</code>;</li>
<li>遍历字符数组，获取每一个字符的<code>ASCII</code>码表对应的值 和之前的<code>hash</code>值相加，这样就保证了相同的字符串的<code>hashCode()</code>返回值相同，计算公式在注释里已经写出来了：<strong><code>s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]</code></strong></li>
<li>将计算出来的结果保存到<code>hash</code>变量中，并返回该值；</li>
</ol>
</blockquote>
<p>这里为什么要乘以<code>31</code>呢？原因是为了<strong>性能</strong>，不仅仅指降低了计算速度，也降低了哈希冲突的概率。</p>
<blockquote>
<p> 哈希冲突：此处指不同的字符串生成了相同的<code>hashCode</code>值。</p>
</blockquote>
<p><code>31</code>是一个<strong>奇素数</strong>。如果乘数是偶数，并且乘法溢出的话，信息就会丢失，因为与2相乘等价于移位运算（低位补<code>0</code>）。使用素数的好处并不很明显，但是习惯上使用素数来计算散列结果。 <strong><code>31</code> 有个很好的性能，即用移位和减法来代替乘法</strong>，可以得到更好的性能： <code>31 * i == (i &lt;&lt; 5）- i</code>， 现代的 <code>VM</code>  可以自动完成这种优化。这个公式可以很简单的推导出来。 —- 《<code>Effective Java</code>》 </p>
<blockquote>
<p>素数：质数又称素数，指在一个大于1的自然数中，除了1和此整数自身外，没法被其他自然数整除的数。 </p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[equals()方法和hashCode()方法详解]]></title>
      <url>/2020/04/07/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E5%86%99equals()%E6%96%B9%E6%B3%95%E6%97%B6%EF%BC%8C%E8%A6%81%E9%87%8D%E5%86%99hashCode()%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<h2 id="为什么重写equals-方法时，要重写hashCode-方法"><a href="#为什么重写equals-方法时，要重写hashCode-方法" class="headerlink" title="为什么重写equals()方法时，要重写hashCode()方法"></a>为什么重写equals()方法时，要重写hashCode()方法</h2><h3 id="1-Object类中equals-方法源代码如下所示："><a href="#1-Object类中equals-方法源代码如下所示：" class="headerlink" title="1. Object类中equals()方法源代码如下所示："></a>1. <code>Object</code>类中<code>equals()</code>方法源代码如下所示：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*	Object类中的equals()方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 由以上源代码知，<code>Object</code>类中的<code>equals()</code>方法是直接使用<code>==</code>运算符来判断两个对象相等的。</p>
<ul>
<li>引用类型变量使用<code>==</code>时，比较的是引用类型变量指向的对象的内存地址</li>
<li>基本类型使用<code>==</code>时，比较值</li>
</ul>
</blockquote>
<p><code>Objcect</code>类中的<code>hashCode</code>源代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns a hash code value for the object. This method is</span></span><br><span class="line"><span class="comment">    * supported for the benefit of hash tables such as those provided by</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> java.util.HashMap&#125;.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * The general contract of &#123;<span class="doctag">@code</span> hashCode&#125; is:</span></span><br><span class="line"><span class="comment">    * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">    * &lt;li&gt;Whenever it is invoked on the same object more than once during</span></span><br><span class="line"><span class="comment">    *     an execution of a Java application, the &#123;<span class="doctag">@code</span> hashCode&#125; method</span></span><br><span class="line"><span class="comment">    *     must consistently return the same integer, provided no information</span></span><br><span class="line"><span class="comment">    *     used in &#123;<span class="doctag">@code</span> equals&#125; comparisons on the object is modified.</span></span><br><span class="line"><span class="comment">    *     This integer need not remain consistent from one execution of an</span></span><br><span class="line"><span class="comment">    *     application to another execution of the same application.</span></span><br><span class="line"><span class="comment">    * &lt;li&gt;If two objects are equal according to the &#123;<span class="doctag">@code</span> equals(Object)&#125;</span></span><br><span class="line"><span class="comment">    *     method, then calling the &#123;<span class="doctag">@code</span> hashCode&#125; method on each of</span></span><br><span class="line"><span class="comment">    *     the two objects must produce the same integer result.</span></span><br><span class="line"><span class="comment">    * &lt;li&gt;It is &lt;em&gt;not&lt;/em&gt; required that if two objects are unequal</span></span><br><span class="line"><span class="comment">    *     according to the &#123;<span class="doctag">@link</span> java.lang.Object#equals(java.lang.Object)&#125;</span></span><br><span class="line"><span class="comment">    *     method, then calling the &#123;<span class="doctag">@code</span> hashCode&#125; method on each of the</span></span><br><span class="line"><span class="comment">    *     two objects must produce distinct integer results.  However, the</span></span><br><span class="line"><span class="comment">    *     programmer should be aware that producing distinct integer results</span></span><br><span class="line"><span class="comment">    *     for unequal objects may improve the performance of hash tables.</span></span><br><span class="line"><span class="comment">    * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * As much as is reasonably practical, the hashCode method defined by</span></span><br><span class="line"><span class="comment">    * class &#123;<span class="doctag">@code</span> Object&#125; does return distinct integers for distinct</span></span><br><span class="line"><span class="comment">    * objects. (This is typically implemented by converting the internal</span></span><br><span class="line"><span class="comment">    * address of the object into an integer, but this implementation</span></span><br><span class="line"><span class="comment">    * technique is not required by the</span></span><br><span class="line"><span class="comment">    * Java&amp;trade; programming language.)</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>  a hash code value for this object.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span>     java.lang.Object#equals(java.lang.Object)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span>     java.lang.System#identityHashCode</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;<span class="comment">// java8中的hashCode方法，</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的注释中有说明如下几点：</p>
<ul>
<li>对象的<code>hashCode</code>值通常是根据对象的内存地址计算得来</li>
<li>两个对象<code>equals()</code>结果为<code>true</code>时，两个对象的<code>hashCode</code>值一定相等，不同对象的<code>hashCode</code>不等</li>
<li><code>native</code>标识此方法不是<code>java</code>语言实现</li>
</ul>
</blockquote>
<p><code>Object</code>类中的<code>toString()</code>方法源代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 从这里就能看出打印对象时不重写toString()方法时，就会打印出对象的hashCode值</span></span><br><span class="line">        <span class="keyword">return</span> getClass().getName() + <span class="string">"@"</span> + Integer.toHexString(hashCode());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-String类中equals-方法和hashCode-方法"><a href="#2-String类中equals-方法和hashCode-方法" class="headerlink" title="2. String类中equals()方法和hashCode()方法"></a>2. <code>String</code>类中<code>equals()</code>方法和<code>hashCode()</code>方法</h3><blockquote>
<p><code>String</code>类中部分源代码如下所示：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line"><span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 无参构造方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.value = <span class="string">""</span>.value;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 有参构造方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.value = original.value;</span><br><span class="line">      <span class="keyword">this</span>.hash = original.hash;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*String类重写的equals方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;<span class="comment">// 此处的this指向a.equals(b)的a对象，即谁调用指向谁</span></span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">          String anotherString = (String)anObject;</span><br><span class="line">          <span class="keyword">int</span> n = value.length;</span><br><span class="line">          <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">              <span class="keyword">char</span> v1[] = value;</span><br><span class="line">              <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">              <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">              <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                  i++;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns a hash code for this string. The hash code for a</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@code</span> String&#125; object is computed as</span></span><br><span class="line"><span class="comment">   * &lt;blockquote&gt;&lt;pre&gt;</span></span><br><span class="line"><span class="comment">   * s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]</span></span><br><span class="line"><span class="comment">   * &lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment">   * using &#123;<span class="doctag">@code</span> int&#125; arithmetic, where &#123;<span class="doctag">@code</span> s[i]&#125; is the</span></span><br><span class="line"><span class="comment">   * &lt;i&gt;i&lt;/i&gt;th character of the string, &#123;<span class="doctag">@code</span> n&#125; is the length of</span></span><br><span class="line"><span class="comment">   * the string, and &#123;<span class="doctag">@code</span> ^&#125; indicates exponentiation.</span></span><br><span class="line"><span class="comment">   * (The hash value of the empty string is zero.)</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span>  a hash code value for this object.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> h = hash;</span><br><span class="line">      <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">              h = <span class="number">31</span> * h + val[i];</span><br><span class="line">          &#125;</span><br><span class="line">          hash = h;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> h;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>从上面的源码中，我们不难发现<code>String</code>类已经重写了<code>equals()</code>方法和<code>hashCode()</code>方法。</p>
<p><code>String</code>类重写的<code>equals()</code>方法判断流程如下：</p>
<blockquote>
<ol>
<li>使用<code>==</code>来判断两个对象的内存地址是否相同，相同返回<code>true；</code></li>
<li>如果两个对象的内存地址不同，程序继续往下走，判断另一个对象是否是<code>String</code>类型的；</li>
<li>如果比较对象不是<code>String</code>类型，直接返回<code>false</code>；</li>
<li>如果是<code>String</code>类型的，进行类型强转；</li>
<li>比较两个<code>String</code>的字符数组长度，如果长度不同，返回<code>false</code>；</li>
<li>利用<code>while</code>循环来逐位比较字符是否相等，直到循环结束，所有字符都相等，则返回<code>true</code>，否则返回<code>false</code>;</li>
</ol>
</blockquote>
<p>下面来看一下重写的<code>hashCode()</code>方法。</p>
<blockquote>
<ol>
<li>首先<code>String</code>类中定义了一个<code>int</code>类型的变量<code>hash</code>用来缓存<code>String</code>对象的<code>hash</code>值；</li>
<li>如果当前调用<code>hashCode()</code>方法的<code>String</code>对象在常量池没有找到，并且该对象的<code>length</code>长度大于<code>0</code>,则继续往下走，否则返回<code>0</code>;即<code>String</code>类默认<code>&quot;&quot;</code>字符串的<code>hashCode()</code>值为<code>0</code>;</li>
<li>遍历字符数组，获取每一个字符的<code>ASCII</code>码表对应的值 和之前的<code>hash</code>值相加，这样就保证了相同的字符串的<code>hashCode()</code>返回值相同，计算公式在注释里已经写出来了：<strong><code>s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]</code></strong></li>
<li>将计算出来的结果保存到<code>hash</code>变量中，并返回该值；</li>
</ol>
</blockquote>
<p>这里为什么要乘以<code>31</code>呢？原因是为了<strong>性能</strong>，不仅仅指降低了计算速度，也降低了哈希冲突的概率。</p>
<blockquote>
<p> 哈希冲突：此处指不同的字符串生成了相同的<code>hashCode</code>值。</p>
</blockquote>
<p><code>31</code>是一个<strong>奇素数</strong>。如果乘数是偶数，并且乘法溢出的话，信息就会丢失，因为与2相乘等价于移位运算（低位补<code>0</code>）。使用素数的好处并不很明显，但是习惯上使用素数来计算散列结果。 <strong><code>31</code> 有个很好的性能，即用移位和减法来代替乘法</strong>，可以得到更好的性能： <code>31 * i == (i &lt;&lt; 5）- i</code>， 现代的 <code>VM</code>  可以自动完成这种优化。这个公式可以很简单的推导出来。 —- 《<code>Effective Java</code>》 </p>
<blockquote>
<p>素数：质数又称素数，指在一个大于1的自然数中，除了1和此整数自身外，没法被其他自然数整除的数。 </p>
</blockquote>
<h3 id="说了这么多，为什么重写equals-方法要重写hashCode-方法呢？"><a href="#说了这么多，为什么重写equals-方法要重写hashCode-方法呢？" class="headerlink" title="说了这么多，为什么重写equals()方法要重写hashCode()方法呢？"></a>说了这么多，为什么重写equals()方法要重写hashCode()方法呢？</h3><p>原因如下：</p>
<ul>
<li><font color="red"><strong>避免两个对象不同时出现相同的hashCode值</strong></font></li>
<li><font color="red"><strong>避免重写过equals()方法的对象使用equals()判断为相等时，返回不同的hashCode值</strong></font></li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>/2020/04/04/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Vue项目中实现回车登录]]></title>
      <url>/2020/04/04/Js%E5%AE%9E%E7%8E%B0%E5%9B%9E%E8%BD%A6%E7%99%BB%E5%BD%95/</url>
      <content type="html"><![CDATA[<h3 id="Vue项目中实现回车登录"><a href="#Vue项目中实现回车登录" class="headerlink" title="Vue项目中实现回车登录"></a>Vue项目中实现回车登录</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">created()&#123;</span><br><span class="line">	<span class="keyword">let</span> that = <span class="keyword">this</span>;</span><br><span class="line">    <span class="built_in">document</span>.onkeypress = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> keycode = <span class="built_in">document</span>.all ? event.keyCode : e.which;</span><br><span class="line">      <span class="keyword">if</span> (keycode == <span class="number">13</span>) &#123;<span class="comment">// 回车键对应值为13</span></span><br><span class="line">        that.login();<span class="comment">// 登录方法名</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[The literal 10000000000 of type int is out of range]]></title>
      <url>/2019/11/05/Java%20long%E7%B1%BB%E5%9E%8B%E8%B8%A9%E5%9D%91/</url>
      <content type="html"><![CDATA[<p><img src="data:image/png;base64,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" alt="image"><br>出现上述报错的主要原因是：  </p>
<blockquote>
<p>Java中默认整数为int类型，虽然图片中的数字未超过long类型的最大值，但由于默认整数为int类型，该数超过了int类型的最大值，所以报错；  </p>
</blockquote>
<h4 id="解决方法如下："><a href="#解决方法如下：" class="headerlink" title="解决方法如下："></a>解决方法如下：</h4><blockquote>
<p>在声明时，在数字的后面添加<font color="red">l</font>或者<font color="red">L</font>即可，建议添加<font color="red">L</font>，更容易区别</p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> 踩坑 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[unix时间戳转时间]]></title>
      <url>/2019/11/05/unix%E6%97%B6%E9%97%B4%E6%88%B3%E8%BD%AC%E6%97%B6%E9%97%B4/</url>
      <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String unixTimeStr=  <span class="string">"1572251400"</span>;</span><br><span class="line"><span class="keyword">long</span> s = Long.parseLong(unixTimeStr);</span><br><span class="line">s *= <span class="number">1000</span>; <span class="comment">// 乘以1000，变成毫秒</span></span><br><span class="line">SimpleDateFormat t = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">String date = t.format(<span class="keyword">new</span> Date(s));</span><br><span class="line">System.out.println(date); <span class="comment">//2019-10-28 16:30:00</span></span><br></pre></td></tr></table></figure>]]></content>
      
        
        <tags>
            
            <tag> 时间戳 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JS中this的指向]]></title>
      <url>/2019/10/15/JS%E4%B8%ADthis%E7%9A%84%E6%8C%87%E5%90%91/</url>
      <content type="html"><![CDATA[<blockquote>
<p>JS中this的指向</p>
</blockquote>
<pre><code>1. 以函数形式调用时，this是window
2. 以方法形式调用时，this是调用方法的对象
3. 以构造函数形式调用时，this是新建的那个对象
4. 使用call()和apply()调用时，this是指定的那个对象</code></pre><p>在调用函数时，浏览器每次都会传递两个隐含的参数<br>    1. 函数的上下文对象this<br>    2. 封装实参的对象arguments<br>        – arguments是一个类数组对象(不是数组)，它可以用过索引来操作数据，也可以获取长度<br>        – 在调用函数时，我们所传递的实参都会保存在arguments中<br>        – 即使在函数中不定义形参，也可以通过arguments来进行操作，只是相对而言麻烦一些</p>
]]></content>
      
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[String类的常用方法]]></title>
      <url>/2019/10/15/Java%E4%B8%ADString%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<h3 id="String类的常用方法"><a href="#String类的常用方法" class="headerlink" title="String类的常用方法"></a>String类的常用方法</h3><blockquote>
<p><strong>split(“reg”)</strong><br>将字符串以reg为分隔符进行分割，返回一个String类型的数组    </p>
</blockquote>
<blockquote>
<p><strong>replace(char oldChar, char newChar)</strong><br>替换字符串中的字符，返回一个新的String类型的变量  </p>
</blockquote>
<blockquote>
<p><strong>replaceAll(String regex,String replacement)</strong><br>基于正则表达式的替换,比如，可以通过<code>replaceAll("\d", "*")</code>把一个字符串所有的数字字符都换成星号;如果参数不是基于正则表达式的，那么效果和replace()相同</p>
</blockquote>
<blockquote>
<p><strong>replaceFirst(String regex,String replacement)</strong><br>基于正则表达式的替换,只替换第一次出现的</p>
</blockquote>
<blockquote>
<p><strong>trim()</strong><br>去除字符串首尾的空格，返回一个新的String类型的变量  </p>
</blockquote>
<blockquote>
<p><strong>equals()</strong><br>比较两个String类型变量的内容是否相同，区分大小写  </p>
</blockquote>
<blockquote>
<p><strong>equalsIgnoreCase()</strong><br>和equals()方法的作用相同，只是忽略大小写  </p>
</blockquote>
<blockquote>
<p><strong>substring(fromTndex,toIndex)</strong><br>字符串截取，包含包含起始位置，不包含结束位置<br>如果只有起始位置，没有结束位置，就返回从起始位置到字符串的末尾  </p>
</blockquote>
<blockquote>
<p><strong>charAt(int index)</strong><br>返回字符串中指定位置的字符，Char类型   </p>
</blockquote>
<blockquote>
<p><strong>boolean statWith(String prefix)</strong><br>判断字符串是是否是以prefix为开始，是返回true，否返回false  </p>
</blockquote>
<blockquote>
<p><strong>boolean endWith(String suffix)</strong><br>判断字符串是是否是以suffix为结束，是返回true，否返回false  </p>
</blockquote>
<blockquote>
<p><strong>String toLowerCase()</strong><br>返回将当前字符串中所有字符转换成小写后的新串</p>
</blockquote>
<blockquote>
<p><strong>String toUpperCase()</strong><br>返回将当前字符串中所有字符转换成大写后的新串  </p>
</blockquote>
<blockquote>
<p><strong>contains(String str)</strong><br>判断参数s是否被包含在字符串中，是返回true，否返回false  </p>
</blockquote>
<blockquote>
<p><strong>int indexOf(int ch/String str)</strong><br>用于查找当前字符串中字符或子串，返回字符或子串在当前字符串中从左边起首次出现的位置，若没有出现则返回-1</p>
</blockquote>
<blockquote>
<p><strong>indexOf(int ch/String str, int fromIndex)</strong><br>从fromIndex位置向后查找  </p>
</blockquote>
<blockquote>
<p><strong>lastIndexOf(int ch/String str)</strong><br>从字符串的末尾位置向前查找  </p>
</blockquote>
<h3 id="字符串与基本类型的转换"><a href="#字符串与基本类型的转换" class="headerlink" title="字符串与基本类型的转换"></a>字符串与基本类型的转换</h3><pre>
int n = Integer.parseInt("12");  
float f = Float.parseFloat("12.34");  
double d = Double.parseDouble("1.124");
</pre>  

<pre>
String a = String.valueOf(12);
String b = String.valueOf(13.14);
</pre>]]></content>
      
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux环境工作常用命令]]></title>
      <url>/2019/10/15/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<h3 id="Linux环境工作常用命令"><a href="#Linux环境工作常用命令" class="headerlink" title="Linux环境工作常用命令"></a>Linux环境工作常用命令</h3><code>  
cd /  进入根目录  
mkdir dirName  创建文件夹    
touch fileName  创建一个空文件
vi/vim fileName 编辑一个文件，如果文件不存在，则会新建该文件  
mv fileName/dirName 剪切/修改 文件或者文件夹的名称  
cp -r sourceDirPath targetDirPath  复制文件夹，会将子文件夹一并复制  
tail -numf fileName  查看文件末尾num行，可以动态刷新文件，用于查看日志  
&& 命令连接符 可以多条命令连接起来，从左到右执行
ps -ef|grep processName  查看某个进程的状态
kill -9 processId 根据进程ID杀进程  
rm -rf fileName/dirName/dirPath 强制删除某个文件或者文件夹下所有内容，请慎用。如果不要强制，则去掉f  
ssh userName@HostIP  ssh远程连接  
ls -l | grep "^-" | wc -l 查看文件夹下文件个数（不包括子文件夹）  
scp -r  local_file remote_username@remote_ip:remote_folder  从本地复制到远程（从远程复制到本地，只需要将两个参数的位置调换一下）  
解压命令  
tar -xvf file.tar //解压 tar包  
tar -xzvf file.tar.gz //解压tar.gz  
tar -xjvf file.tar.bz2   //解压 tar.bz2  
tar -xZvf file.tar.Z   //解压tar.Z  
unrar e file.rar //解压rar  
unzip file.zip //解压zip
</code>]]></content>
      
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Mybatis笔记]]></title>
      <url>/2019/10/15/Mybatis/</url>
      <content type="html"><![CDATA[<h3 id="Mybatis笔记"><a href="#Mybatis笔记" class="headerlink" title="Mybatis笔记"></a>Mybatis笔记</h3><p>第一天  </p>
<blockquote>
<p>mybatis的映射配置文件位置必须和dao接口的包结构相同    </p>
<p>映射配置文件的mapper标签namespace属性的取值必须是dao接口的全限定类名  </p>
<p>映射配置文件的操作配置（select），id属性的取值必须是dao接口的方法名</p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[进程和线程]]></title>
      <url>/2019/10/15/%E9%9A%8F%E7%AC%94/</url>
      <content type="html"><![CDATA[<p>记录：  </p>
<h2 id="多任务操作系统的实现方式"><a href="#多任务操作系统的实现方式" class="headerlink" title="多任务操作系统的实现方式"></a>多任务操作系统的实现方式</h2><blockquote>
<p>单核cpu  </p>
<p>  操作系统让cpu轮流交替执行任务，因为cpu的执行效率远高于计算机内的其他组件，所以让人感觉有多个任务在同时进行，实际上确定的时间点上，cpu只执行某一个任务。    </p>
<p>多核cpu  </p>
<p> 多个核心的cpu可在真正意义上实现多任务执行。但由于任务数量会超过cpu的核心数，所以操作系统也会自动把很多任务轮流调度到每个核心上执行。 </p>
</blockquote>
<h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><p>进程：  </p>
<blockquote>
<p> 对于操作系统来说，一个任务就是一个进程（Process），比如打开一个浏览器就是启动一个浏览器进程，打开一个记事本就启动了一个记事本进程，打开两个记事本就启动了两个记事本进程，打开一个Word就启动了一个Word进程。  </p>
</blockquote>
<p>线程：</p>
<blockquote>
<p>有些进程还不止同时干一件事，比如Word，它可以同时进行打字、拼写检查、打印等事情。在一个进程内部，要同时干多件事，就需要同时运行多个“子任务”，我们把进程内的这些“子任务”称为线程（Thread）</p>
</blockquote>
<p>小结</p>
<blockquote>
<p>线程是最小的执行单元，而进程由至少一个线程组成。如何调度进程和线程，完全由操作系统决定，程序自己不能决定什么时候执行，执行多长时间  </p>
<p>进程和线程都是一个时间段的描述，是CPU工作时间段的描述<br>CPU+RAM+各种资源（比如显卡，光驱，键盘，GPS, 等等外设）构成我们的电脑，但是电脑的运行，实际就是CPU和相关寄存器以及RAM之间的事情。<br>一个最最基础的事实：CPU太快，太快，太快了，寄存器仅仅能够追的上他的脚步，RAM和别的挂在各总线上的设备完全是难以望其项背。那当多个任务要执行的时候怎么办呢？轮流着来?或者谁优先级高谁来？不管怎么样的策略，一句话就是在CPU看来就是轮流着来。</p>
</blockquote>
<blockquote>
<p>一个必须知道的事实：执行一段程序代码，实现一个功能的过程介绍 ，当得到CPU的时候，相关的资源必须也已经就位，就是显卡啊，GPS啊什么的必须就位，然后CPU开始执行。这里除了CPU以外所有的就构成了这个程序的执行环境，也就是我们所定义的程序上下文。当这个程序执行完了，或者分配给他的CPU执行时间用完了，那它就要被切换出去，等待下一次CPU的临幸。在被切换出去的最后一步工作就是保存程序上下文，因为这个是下次他被CPU临幸的运行环境，必须保存。</p>
</blockquote>
<blockquote>
<p>串联起来的事实：前面讲过在CPU看来所有的任务都是一个一个的轮流执行的，具体的轮流方法就是：先加载程序A的上下文，然后开始执行A，保存程序A的上下文，调入下一个要执行的程序B的程序上下文，然后开始执行B,保存程序B的上下文。。。。</p>
</blockquote>
<blockquote>
<p>========= 重要的东西出现了========  </p>
</blockquote>
<p>进程和线程就是这样的背景出来的，两个名词不过是对应的CPU时间段的描述，名词就是这样的功能。<br>进程就是包换上下文切换的程序执行时间总和 = CPU加载上下文+CPU执行+CPU保存上下文<br>线程是什么呢？<br>进程的颗粒度太大，每次都要有上下的调入，保存，调出。如果我们把进程比喻为一个运行在电脑上的软件，那么一个软件的执行不可能是一条逻辑执行的，必定有多个分支和多个程序段，就好比要实现程序A，实际分成 a，b，c等多个块组合而成。那么这里具体的执行就可能变成：</p>
<blockquote>
<p>程序A得到CPU =》CPU加载上下文，开始执行程序A的a小段，然后执行A的b小段，然后再执行A的c小段，最后CPU保存A的上下文。</p>
</blockquote>
<blockquote>
<p>这里a，b，c的执行是共享了A的上下文，CPU在执行的时候没有进行上下文切换的。这里的a，b，c就是线程，也就是说线程是共享了进程的上下文环境，的更为细小的CPU时间段。</p>
</blockquote>
<blockquote>
<p>到此全文结束，再一个总结：</p>
</blockquote>
<blockquote>
<p>进程和线程都是一个时间段的描述，是CPU工作时间段的描述，不过是颗粒大小不同。</p>
</blockquote>
<blockquote>
<p>进程是资源分配的最小单位，线程是CPU调度的最小单位</p>
</blockquote>
<h3 id="Java中的参数传值方式—-值传递"><a href="#Java中的参数传值方式—-值传递" class="headerlink" title="Java中的参数传值方式—-值传递"></a>Java中的参数传值方式—-值传递</h3><blockquote>
<p>Java中传递参数时：      </p>
<p>基本类型：复制一份该参数的实际值，传递<br>引用类型：复制一份该引用类型的引用的值，传递</p>
</blockquote>
<h3 id="Java中的四种引用"><a href="#Java中的四种引用" class="headerlink" title="Java中的四种引用"></a>Java中的四种引用</h3><blockquote>
<p>强引用  </p>
<p>指创建一个对象并把这个对象赋给一个引用变量比如 Object object = new Object();String a = “test”;<br>这样生成的对象一直到该方法执行结束之后才会回收，否则永远都不会回收  </p>
</blockquote>
<blockquote>
<p>软引用  </p>
</blockquote>
<pre name="code" class="java">
if(i > 0){
    System.out.println("it is a test for markdown");
}
</pre>
]]></content>
      
        
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java中到底是值传递还是引用传递]]></title>
      <url>/2019/07/15/Java%E4%B8%AD%E5%88%B0%E5%BA%95%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/</url>
      <content type="html"><![CDATA[<h2 id="Java中到底是值传递还是引用传递？"><a href="#Java中到底是值传递还是引用传递？" class="headerlink" title="Java中到底是值传递还是引用传递？"></a>Java中到底是值传递还是引用传递？</h2><p>我们先回顾一下基本概念</p>
<h3 id="实参和形参"><a href="#实参和形参" class="headerlink" title="实参和形参"></a>实参和形参</h3><p>参数在编程语言中是执行程序需要的数据，这个数据一般保存在变量中。在Java中定义一个方法时，可以定义一些参数，<br>举个例子：    </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	String myName = <span class="string">"hawk"</span>;</span><br><span class="line">	sayYourName(myName);<span class="comment">// 实际参数是myName</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayYourName</span><span class="params">(String name)</span> </span>&#123;<span class="comment">// 形式参数是name</span></span><br><span class="line">		System.out.println(name);</span><br><span class="line">	&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中定义一个名为sayYourName的方法，如果想要执行这个方法，那么你需要传入一个String类型的变量给这个方法，定义这个方法时声明的String类型的name就是形式参数，而在这个方法执行时传入的myName就是实际参数。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><blockquote>
<p>实际参数是调用有参方法的时候真正传递的内容，而形式参数是用于接收实参内容的参数。  </p>
</blockquote>
<h3 id="传参的几种方式"><a href="#传参的几种方式" class="headerlink" title="传参的几种方式"></a>传参的几种方式</h3><p> 按值传递(call by value)  </p>
<blockquote>
<p>按值传递，就是指在调用函数时，将实参对应的值做一个拷贝指向函数对应的形参。在函数内改变形参对应的值并不会影响外部实参的值  </p>
</blockquote>
<p> 按引用传递 (call by reference)</p>
<blockquote>
<p>按引用传递，是指在调用函数时，传递给函数的是实参的地址即引用，而不是实参的拷贝。在函数内部参数的值，对外部的实参是可见的。  </p>
</blockquote>
<p>按共享传递 （call by sharing）  </p>
<blockquote>
<p>按共享传递，是指在调用函数时，传递给函数的是实参的地址的拷贝（如果实参在栈中，则直接拷贝该值）。在函数内部对参数进行操作时，需要先拷贝的地址寻找到具体的值，再进行操作。如果该值在栈中，那么因为是直接拷贝的值，所以函数内部对参数进行操作不会对外部变量产生影响。如果原来拷贝的是原值在堆中的地址，那么需要先根据该地址找到堆中对应的位置，再进行操作。因为传递的是地址的拷贝所以函数内对值的操作对外部变量是可见的。  </p>
</blockquote>
<blockquote>
<p>按共享传递可以理解为<strong>按值传递</strong>的一个特例，这里的值是对象的引用地址，而不是具体对象。  </p>
</blockquote>
<p>上面描述的传参方式实际上是函数调用时参数的求值策略(Evaluation Strategy)，这个其实比较好理解，比如我们调用上面的sayYourName()方法<br>我们可以这样：sayYourName(“hawk”);<br>可以这样:sayYourName(“ha”+”wk”);<br>可以这样：sayYourName(“hawk”+x.subString(2));// 此处的x是一个变量,进行截取后和”hawk”合并    </p>
<p>但是所有这些实参的形式，都统称为表达式(Expression)。求值（Evaluation）即是指对这些表达式的简化并求解其值的过程。</p>
<p>求值策略(值传递和引用传递)的关注的点在于，这些表达式在调用函数的过程中，求值的时机、值的形式的选取等问题。求值的时机，可以是在函数调用前，也可以是在函数调用后，由被调用者自己求值。这里所谓调用后求值，可以理解为Lazy Load或On Demand的一种求值方式。<br>而且，除了按值传递和按引用传递，还有一些其它的求值策略。这些求值策略的划分依据是：求值的时机（调用前还是调用中）和值本身的传递方式。详见下表：  </p>
<table>
<tr>
    <td>求值策略</td>
    <td>求值时间</td>
    <td>传值方式</td>
</tr>
<tr>
    <td>按值传递( pass by value )</td>
    <td>调用前</td>
    <td>值的结果(只是结果的副本)</td>
</tr>
<tr>
    <td>按引用传递( pass by reference )</td>
    <td>调用前</td>
    <td>原值(原始对象，无副本)</td>
</tr>
<tr>
    <td>按名传递( pass by name )</td>
    <td>调用后(用到才求值)</td>
    <td>与值无关的一个名</td>
</tr>
</table>  

<p><strong>按值传递和按引用传递在行为表现上的差异如下：</strong>  </p>
<table>
<tr>
    <td></td>
    <td>按值传递</td>
    <td>按引用传递</td>
</tr>
<tr>
    <td>本质区别</td>
    <td>创建副本</td>
    <td>不创建副本</td>
</tr>
<tr>
    <td>表现结果</td>
    <td>函数中无法改变原始对象</td>
    <td>函数中可以改变原始对象</td>
</tr>
</table>
**这里面的改变，是指把一个变量指向另一个对象，而不是指仅仅改变属性或者成员什么的**  

<p>只要是按值传递，不管传递的参数类型是值类型还是引用类型，都会在调用栈上面创建一个实参的副本，区别只是如果传递的参数类型是值类型，该副本就是实际参数的值的复制，而对于引用类型来说，引用类型的实例(即对象)是保存在堆中的，在栈上只有一个该实例的引用（一般情况下是该实例在堆中的内存地址），此时，实际参数的副本并不是该对象，而是引用的副本。</p>
<p><strong>所以，综上所述，对于Java的函数调用方式最准确的描述是：参数藉由值传递方式，传递的值是个引用。（句中两个“值”不是一个意思，第一个值是evaluation result，第二个值是value content）</strong></p>
<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>说到Java是值传递还是引用传递，一般都会举下面三个例子，我们来一一说明一下：<br>第一个例子，基本类型参数传值：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">		changeValue(i);</span><br><span class="line">		System.out.println(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">changeValue</span><span class="params">(<span class="keyword">int</span> a )</span> </span>&#123;</span><br><span class="line">		a = <span class="number">20</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码解释如下：<br>定义了一个int类型的变量i，并赋值为10<br>调用changeValue方法，传入i，changeValue方法将传入的变量赋值为20<br>输出i  </p>
<p>结果是：<strong>10</strong><br>changValue方法内部对<strong>形参a</strong>的修改并没有影响到<strong>实参i</strong><br><strong>第一个结论：Java中基本类型的传值方式是按值传递</strong>  </p>
<p>第二个例子，引用类型传值：    </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		String i = <span class="string">"hawk"</span>;</span><br><span class="line">		changString(i);</span><br><span class="line">		System.out.println(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">changString</span><span class="params">(String a )</span> </span>&#123;</span><br><span class="line">		a = <span class="string">"HAWK"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码解释如下：<br>定义一个String类型的变量i，赋值为”hawk”<br>调用changeString方法，将传入的变量赋值为”HAWK”<br>输出i  </p>
<p>结果： <strong>hawk</strong><br>在Java中String类型虽然可以直接赋值，但是是引用类型，<strong>因为String类型的具体值保存在堆中，而不是栈上</strong><br>既然String是引用类型， 上面的例子又说明String是值传递的  那么我们是不是就可以得出：<br><strong>Java中引用类型也是值传递的</strong>，这样的结论呢？  </p>
<p>我们来看第三个例子：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">20</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Example ex = <span class="keyword">new</span> Example();</span><br><span class="line">		changValue(ex);</span><br><span class="line">		System.out.println(ex.i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">changValue</span><span class="params">(Example e )</span> </span>&#123;</span><br><span class="line">		e.i = <span class="number">30</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码解释如下：<br>实例化一个Example对象ex，ex中只有一个属性i，初始值为20<br>调用changValue方法，将ex中的属性i的值赋值为30<br>输出ex中属性i的值  </p>
<p>结果是：<strong>30</strong><br>这样的结果就让很多人产生了困惑，String类型是引用类型，对象也是引用类型，为什么第二个例子不能改变i的值，第三个例子却改变了ex中i的值呢？<strong>Java中引用类型的参数传递到底是引用传递还是值传递呢？</strong>  </p>
<p>其实，第二个例子和第三个例子我们所关注的点已经是错误的了，自然无法得出正确的结论<br>我们回顾一下<strong>引用传递和值传递的本质区别和行为表现上的区别</strong> </p>
<table>
<tr>
    <td></td>
    <td>按值传递</td>
    <td>按引用传递</td>
</tr>
<tr>
    <td>本质区别</td>
    <td>创建副本</td>
    <td>不创建副本</td>
</tr>
<tr>
    <td>表现结果</td>
    <td>函数中<b>无法改变原始对象</b></td>
    <td>函数中<b>可以改变原始对象</b></td>
</tr>
</table>
注意到了吗？我们应该关注的是**原始对象的变化**  
> **Java中，引用类型的原始对象（即原始值）是保存在堆中的，变量中存储的是原始值的引用（Java中存储的是该对象在堆中的内存地址），**
> **该引用指向堆中的对象,所以我们<font color="red">关注的关键点应该是对象的引用有没有发生变化</font>，而不是原始对象中的内容有没有发生变化**

<p><strong><font color="red">重要依据：</font>如果可以改变对象的引用，就说明是引用传递，如果不能改变对象的引用就说明是值传递</strong><br>下面我们多举一个例子： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">20</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Example ex = <span class="keyword">new</span> Example();</span><br><span class="line">		changValue(ex);</span><br><span class="line">		System.out.println(ex.i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">changValue</span><span class="params">(Example e )</span> </span>&#123;</span><br><span class="line">		e = <span class="keyword">new</span> Example();</span><br><span class="line">		e.i = <span class="number">50</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子和上面第三个例子很相似，区别在于：<br>changValue方法中将一个新的原始对象的引用赋值给了形参e<br><strong>如果Java是按引用传递的话，e = new Example();就是修改了实参ex的引用，即就是改变了原始对象<br>如果Java是按值传递的话，实参ex不会有任何变化</strong>  </p>
<p>结果：<strong>20</strong>  </p>
<p>这个结果说明：<strong>changValue方法并没有修改到ex的引用，也就是说，e只是ex的副本，对e的引用进行的所有操作都不会影响到ex，所以我们<br>从上述代码运行的结果也可以证明Java中是只有值传递的</strong></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.hollischuang.com/archives/2275" target="_blank">为什么说Java中只有值传递</a><br><a href="http://menzhongxin.com/2017/02/07/%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92-%E6%8C%89%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E5%92%8C%E6%8C%89%E5%85%B1%E4%BA%AB%E4%BC%A0%E9%80%92/" target="_blank">按值传递、按引用传递、按共享传递</a><br><a href="https://www.zhihu.com/question/20628016/answer/28970414" target="_blank">为什么 Java 只有值传递，但 C# 既有值传递，又有引用传递，这种语言设计有哪些好处？</a></p>
]]></content>
      
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
