<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[String类的常用方法]]></title>
      <url>/2019/10/15/Java%E4%B8%ADString%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<h3 id="String类的常用方法"><a href="#String类的常用方法" class="headerlink" title="String类的常用方法"></a>String类的常用方法</h3><blockquote>
<p><strong>split(“reg”)</strong><br>将字符串以reg为分隔符进行分割，返回一个String类型的数组    </p>
</blockquote>
<blockquote>
<p><strong>replace(char oldChar, char newChar)</strong><br>替换字符串中的字符，返回一个新的String类型的变量  </p>
</blockquote>
<blockquote>
<p><strong>replaceAll(String regex,String replacement)</strong><br>基于正则表达式的替换,比如，可以通过<code>replaceAll("\d", "*")</code>把一个字符串所有的数字字符都换成星号;如果参数不是基于正则表达式的，那么效果和replace()相同</p>
</blockquote>
<blockquote>
<p><strong>replaceFirst(String regex,String replacement)</strong><br>基于正则表达式的替换,只替换第一次出现的</p>
</blockquote>
<blockquote>
<p><strong>trim()</strong><br>去除字符串首尾的空格，返回一个新的String类型的变量  </p>
</blockquote>
<blockquote>
<p><strong>equals()</strong><br>比较两个String类型变量的内容是否相同，区分大小写  </p>
</blockquote>
<blockquote>
<p><strong>equalsIgnoreCase()</strong><br>和equals()方法的作用相同，只是忽略大小写  </p>
</blockquote>
<blockquote>
<p><strong>substring(fromTndex,toIndex)</strong><br>字符串截取，包含包含起始位置，不包含结束位置<br>如果只有起始位置，没有结束位置，就返回从起始位置到字符串的末尾  </p>
</blockquote>
<blockquote>
<p><strong>charAt(int index)</strong><br>返回字符串中指定位置的字符，Char类型   </p>
</blockquote>
<blockquote>
<p><strong>boolean statWith(String prefix)</strong><br>判断字符串是是否是以prefix为开始，是返回true，否返回false  </p>
</blockquote>
<blockquote>
<p><strong>boolean endWith(String suffix)</strong><br>判断字符串是是否是以suffix为结束，是返回true，否返回false  </p>
</blockquote>
<blockquote>
<p><strong>String toLowerCase()</strong><br>返回将当前字符串中所有字符转换成小写后的新串</p>
</blockquote>
<blockquote>
<p><strong>String toUpperCase()</strong><br>返回将当前字符串中所有字符转换成大写后的新串  </p>
</blockquote>
<blockquote>
<p><strong>contains(String str)</strong><br>判断参数s是否被包含在字符串中，是返回true，否返回false  </p>
</blockquote>
<blockquote>
<p><strong>int indexOf(int ch/String str)</strong><br>用于查找当前字符串中字符或子串，返回字符或子串在当前字符串中从左边起首次出现的位置，若没有出现则返回-1</p>
</blockquote>
<blockquote>
<p><strong>indexOf(int ch/String str, int fromIndex)</strong><br>从fromIndex位置向后查找  </p>
</blockquote>
<blockquote>
<p><strong>lastIndexOf(int ch/String str)</strong><br>从字符串的末尾位置向前查找  </p>
</blockquote>
<h3 id="字符串与基本类型的转换"><a href="#字符串与基本类型的转换" class="headerlink" title="字符串与基本类型的转换"></a>字符串与基本类型的转换</h3><pre>
int n = Integer.parseInt("12");  
float f = Float.parseFloat("12.34");  
double d = Double.parseDouble("1.124");
</pre>  

<pre>
String a = String.valueOf(12);
String b = String.valueOf(13.14);
</pre>]]></content>
      
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JS中this的指向]]></title>
      <url>/2019/10/15/JS%E4%B8%ADthis%E7%9A%84%E6%8C%87%E5%90%91/</url>
      <content type="html"><![CDATA[<blockquote>
<p>JS中this的指向</p>
</blockquote>
<pre><code>1. 以函数形式调用时，this是window
2. 以方法形式调用时，this是调用方法的对象
3. 以构造函数形式调用时，this是新建的那个对象
4. 使用call()和apply()调用时，this是指定的那个对象</code></pre><p>在调用函数时，浏览器每次都会传递两个隐含的参数<br>    1. 函数的上下文对象this<br>    2. 封装实参的对象arguments<br>        – arguments是一个类数组对象(不是数组)，它可以用过索引来操作数据，也可以获取长度<br>        – 在调用函数时，我们所传递的实参都会保存在arguments中<br>        – 即使在函数中不定义形参，也可以通过arguments来进行操作，只是相对而言麻烦一些</p>
]]></content>
      
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Mybatis笔记]]></title>
      <url>/2019/10/15/Mybatis/</url>
      <content type="html"><![CDATA[<h3 id="Mybatis笔记"><a href="#Mybatis笔记" class="headerlink" title="Mybatis笔记"></a>Mybatis笔记</h3><p>第一天  </p>
<blockquote>
<p>mybatis的映射配置文件位置必须和dao接口的包结构相同    </p>
<p>映射配置文件的mapper标签namespace属性的取值必须是dao接口的全限定类名  </p>
<p>映射配置文件的操作配置（select），id属性的取值必须是dao接口的方法名</p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[String类的常用方法]]></title>
      <url>/2019/10/15/%E9%9A%8F%E7%AC%94/</url>
      <content type="html"><![CDATA[<p>记录：  </p>
<h2 id="多任务操作系统的实现方式"><a href="#多任务操作系统的实现方式" class="headerlink" title="多任务操作系统的实现方式"></a>多任务操作系统的实现方式</h2><blockquote>
<p>单核cpu  </p>
<p>  操作系统让cpu轮流交替执行任务，因为cpu的执行效率远高于计算机内的其他组件，所以让人感觉有多个任务在同时进行，实际上确定的时间点上，cpu只执行某一个任务。    </p>
<p>多核cpu  </p>
<p> 多个核心的cpu可在真正意义上实现多任务执行。但由于任务数量会超过cpu的核心数，所以操作系统也会自动把很多任务轮流调度到每个核心上执行。 </p>
</blockquote>
<h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><p>进程：  </p>
<blockquote>
<p> 对于操作系统来说，一个任务就是一个进程（Process），比如打开一个浏览器就是启动一个浏览器进程，打开一个记事本就启动了一个记事本进程，打开两个记事本就启动了两个记事本进程，打开一个Word就启动了一个Word进程。  </p>
</blockquote>
<p>线程：</p>
<blockquote>
<p>有些进程还不止同时干一件事，比如Word，它可以同时进行打字、拼写检查、打印等事情。在一个进程内部，要同时干多件事，就需要同时运行多个“子任务”，我们把进程内的这些“子任务”称为线程（Thread）</p>
</blockquote>
<p>小结</p>
<blockquote>
<p>线程是最小的执行单元，而进程由至少一个线程组成。如何调度进程和线程，完全由操作系统决定，程序自己不能决定什么时候执行，执行多长时间  </p>
<p>进程和线程都是一个时间段的描述，是CPU工作时间段的描述<br>CPU+RAM+各种资源（比如显卡，光驱，键盘，GPS, 等等外设）构成我们的电脑，但是电脑的运行，实际就是CPU和相关寄存器以及RAM之间的事情。<br>一个最最基础的事实：CPU太快，太快，太快了，寄存器仅仅能够追的上他的脚步，RAM和别的挂在各总线上的设备完全是难以望其项背。那当多个任务要执行的时候怎么办呢？轮流着来?或者谁优先级高谁来？不管怎么样的策略，一句话就是在CPU看来就是轮流着来。</p>
</blockquote>
<blockquote>
<p>一个必须知道的事实：执行一段程序代码，实现一个功能的过程介绍 ，当得到CPU的时候，相关的资源必须也已经就位，就是显卡啊，GPS啊什么的必须就位，然后CPU开始执行。这里除了CPU以外所有的就构成了这个程序的执行环境，也就是我们所定义的程序上下文。当这个程序执行完了，或者分配给他的CPU执行时间用完了，那它就要被切换出去，等待下一次CPU的临幸。在被切换出去的最后一步工作就是保存程序上下文，因为这个是下次他被CPU临幸的运行环境，必须保存。</p>
</blockquote>
<blockquote>
<p>串联起来的事实：前面讲过在CPU看来所有的任务都是一个一个的轮流执行的，具体的轮流方法就是：先加载程序A的上下文，然后开始执行A，保存程序A的上下文，调入下一个要执行的程序B的程序上下文，然后开始执行B,保存程序B的上下文。。。。</p>
</blockquote>
<blockquote>
<p>========= 重要的东西出现了========  </p>
</blockquote>
<p>进程和线程就是这样的背景出来的，两个名词不过是对应的CPU时间段的描述，名词就是这样的功能。<br>进程就是包换上下文切换的程序执行时间总和 = CPU加载上下文+CPU执行+CPU保存上下文<br>线程是什么呢？<br>进程的颗粒度太大，每次都要有上下的调入，保存，调出。如果我们把进程比喻为一个运行在电脑上的软件，那么一个软件的执行不可能是一条逻辑执行的，必定有多个分支和多个程序段，就好比要实现程序A，实际分成 a，b，c等多个块组合而成。那么这里具体的执行就可能变成：</p>
<blockquote>
<p>程序A得到CPU =》CPU加载上下文，开始执行程序A的a小段，然后执行A的b小段，然后再执行A的c小段，最后CPU保存A的上下文。</p>
</blockquote>
<blockquote>
<p>这里a，b，c的执行是共享了A的上下文，CPU在执行的时候没有进行上下文切换的。这里的a，b，c就是线程，也就是说线程是共享了进程的上下文环境，的更为细小的CPU时间段。</p>
</blockquote>
<blockquote>
<p>到此全文结束，再一个总结：</p>
</blockquote>
<blockquote>
<p>进程和线程都是一个时间段的描述，是CPU工作时间段的描述，不过是颗粒大小不同。</p>
</blockquote>
<blockquote>
<p>进程是资源分配的最小单位，线程是CPU调度的最小单位</p>
</blockquote>
<h3 id="Java中的参数传值方式—-值传递"><a href="#Java中的参数传值方式—-值传递" class="headerlink" title="Java中的参数传值方式—-值传递"></a>Java中的参数传值方式—-值传递</h3><blockquote>
<p>Java中传递参数时：      </p>
<p>基本类型：复制一份该参数的实际值，传递<br>引用类型：复制一份该引用类型的引用的值，传递</p>
</blockquote>
<h3 id="Java中的四种引用"><a href="#Java中的四种引用" class="headerlink" title="Java中的四种引用"></a>Java中的四种引用</h3><blockquote>
<p>强引用  </p>
<p>指创建一个对象并把这个对象赋给一个引用变量比如 Object object = new Object();String a = “test”;<br>这样生成的对象一直到该方法执行结束之后才会回收，否则永远都不会回收  </p>
</blockquote>
<blockquote>
<p>软引用  </p>
</blockquote>
<pre name="code" class="java">
if(i > 0){
    System.out.println("it is a test for markdown");
}
</pre>
]]></content>
      
        
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux环境工作常用命令]]></title>
      <url>/2019/10/15/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<h3 id="Linux环境工作常用命令"><a href="#Linux环境工作常用命令" class="headerlink" title="Linux环境工作常用命令"></a>Linux环境工作常用命令</h3><code>  
cd /  进入根目录  
mkdir dirName  创建文件夹    
touch fileName  创建一个空文件
vi/vim fileName 编辑一个文件，如果文件不存在，则会新建该文件  
mv fileName/dirName 剪切/修改 文件或者文件夹的名称  
cp -r sourceDirPath targetDirPath  复制文件夹，会将子文件夹一并复制  
tail -numf fileName  查看文件末尾num行，可以动态刷新文件，用于查看日志  
&& 命令连接符 可以多条命令连接起来，从左到右执行
ps -ef|grep processName  查看某个进程的状态
kill -9 processId 根据进程ID杀进程  
rm -rf fileName/dirName/dirPath 强制删除某个文件或者文件夹下所有内容，请慎用。如果不要强制，则去掉f  
ssh userName@HostIP  ssh远程连接  
ls -l | grep "^-" | wc -l 查看文件夹下文件个数（不包括子文件夹）  
scp -r  local_file remote_username@remote_ip:remote_folder  从本地复制到远程（从远程复制到本地，只需要将两个参数的位置调换一下）  
解压命令  
tar -xvf file.tar //解压 tar包  
tar -xzvf file.tar.gz //解压tar.gz  
tar -xjvf file.tar.bz2   //解压 tar.bz2  
tar -xZvf file.tar.Z   //解压tar.Z  
unrar e file.rar //解压rar  
unzip file.zip //解压zip
</code>]]></content>
      
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java中到底是值传递还是引用传递]]></title>
      <url>/2019/07/15/Java%E4%B8%AD%E5%88%B0%E5%BA%95%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/</url>
      <content type="html"><![CDATA[<h2 id="Java中到底是值传递还是引用传递？"><a href="#Java中到底是值传递还是引用传递？" class="headerlink" title="Java中到底是值传递还是引用传递？"></a>Java中到底是值传递还是引用传递？</h2><p>我们先回顾一下基本概念</p>
<h3 id="实参和形参"><a href="#实参和形参" class="headerlink" title="实参和形参"></a>实参和形参</h3><p>参数在编程语言中是执行程序需要的数据，这个数据一般保存在变量中。在Java中定义一个方法时，可以定义一些参数，<br>举个例子：    </p>
<pre><code>public class Example {

public static void main(String[] args) {
    String myName = &quot;hawk&quot;;
    sayYourName(myName);// 实际参数是myName
    }
public static void sayYourName(String name) {// 形式参数是name
        System.out.println(name);
    }  
}</code></pre><p>上面的代码中定义一个名为sayYourName的方法，如果想要执行这个方法，那么你需要传入一个String类型的变量给这个方法，定义这个方法时声明的String类型的name就是形式参数，而在这个方法执行时传入的myName就是实际参数。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><blockquote>
<p>实际参数是调用有参方法的时候真正传递的内容，而形式参数是用于接收实参内容的参数。  </p>
</blockquote>
<h3 id="传参的几种方式"><a href="#传参的几种方式" class="headerlink" title="传参的几种方式"></a>传参的几种方式</h3><p> 按值传递(call by value)  </p>
<blockquote>
<p>按值传递，就是指在调用函数时，将实参对应的值做一个拷贝指向函数对应的形参。在函数内改变形参对应的值并不会影响外部实参的值  </p>
</blockquote>
<p> 按引用传递 (call by reference)</p>
<blockquote>
<p>按引用传递，是指在调用函数时，传递给函数的是实参的地址即引用，而不是实参的拷贝。在函数内部参数的值，对外部的实参是可见的。  </p>
</blockquote>
<p>按共享传递 （call by sharing）  </p>
<blockquote>
<p>按共享传递，是指在调用函数时，传递给函数的是实参的地址的拷贝（如果实参在栈中，则直接拷贝该值）。在函数内部对参数进行操作时，需要先拷贝的地址寻找到具体的值，再进行操作。如果该值在栈中，那么因为是直接拷贝的值，所以函数内部对参数进行操作不会对外部变量产生影响。如果原来拷贝的是原值在堆中的地址，那么需要先根据该地址找到堆中对应的位置，再进行操作。因为传递的是地址的拷贝所以函数内对值的操作对外部变量是可见的。  </p>
</blockquote>
<blockquote>
<p>按共享传递可以理解为<strong>按值传递</strong>的一个特例，这里的值是对象的引用地址，而不是具体对象。  </p>
</blockquote>
<p>上面描述的传参方式实际上是函数调用时参数的求值策略(Evaluation Strategy)，这个其实比较好理解，比如我们调用上面的sayYourName()方法<br>我们可以这样：sayYourName(“hawk”);<br>可以这样:sayYourName(“ha”+”wk”);<br>可以这样：sayYourName(“hawk”+x.subString(2));// 此处的x是一个变量,进行截取后和”hawk”合并    </p>
<p>但是所有这些实参的形式，都统称为表达式(Expression)。求值（Evaluation）即是指对这些表达式的简化并求解其值的过程。</p>
<p>求值策略(值传递和引用传递)的关注的点在于，这些表达式在调用函数的过程中，求值的时机、值的形式的选取等问题。求值的时机，可以是在函数调用前，也可以是在函数调用后，由被调用者自己求值。这里所谓调用后求值，可以理解为Lazy Load或On Demand的一种求值方式。<br>而且，除了按值传递和按引用传递，还有一些其它的求值策略。这些求值策略的划分依据是：求值的时机（调用前还是调用中）和值本身的传递方式。详见下表：  </p>
<table>
<tr>
    <td>求值策略</td>
    <td>求值时间</td>
    <td>传值方式</td>
</tr>
<tr>
    <td>按值传递( pass by value )</td>
    <td>调用前</td>
    <td>值的结果(只是结果的副本)</td>
</tr>
<tr>
    <td>按引用传递( pass by reference )</td>
    <td>调用前</td>
    <td>原值(原始对象，无副本)</td>
</tr>
<tr>
    <td>按名传递( pass by name )</td>
    <td>调用后(用到才求值)</td>
    <td>与值无关的一个名</td>
</tr>
</table>  

<p><strong>按值传递和按引用传递在行为表现上的差异如下：</strong>  </p>
<table>
<tr>
    <td></td>
    <td>按值传递</td>
    <td>按引用传递</td>
</tr>
<tr>
    <td>本质区别</td>
    <td>创建副本</td>
    <td>不创建副本</td>
</tr>
<tr>
    <td>表现结果</td>
    <td>函数中无法改变原始对象</td>
    <td>函数中可以改变原始对象</td>
</tr>
</table>
**这里面的改变，是指把一个变量指向另一个对象，而不是指仅仅改变属性或者成员什么的**  

<p>只要是按值传递，不管传递的参数类型是值类型还是引用类型，都会在调用栈上面创建一个实参的副本，区别只是如果传递的参数类型是值类型，该副本就是实际参数的值的复制，而对于引用类型来说，引用类型的实例(即对象)是保存在堆中的，在栈上只有一个该实例的引用（一般情况下是该实例在堆中的内存地址），此时，实际参数的副本并不是该对象，而是引用的副本。</p>
<p><strong>所以，综上所述，对于Java的函数调用方式最准确的描述是：参数藉由值传递方式，传递的值是个引用。（句中两个“值”不是一个意思，第一个值是evaluation result，第二个值是value content）</strong></p>
<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>说到Java是值传递还是引用传递，一般都会举下面三个例子，我们来一一说明一下：<br>第一个例子，基本类型参数传值：  </p>
<pre><code>public class Example {
    public static void main(String[] args) {
        int i = 10;
        changeValue(i);
        System.out.println(i);
    }
    public static void changeValue(int a ) {
        a = 20;
    }
}  </code></pre><p>上面的代码解释如下：<br>定义了一个int类型的变量i，并赋值为10<br>调用changeValue方法，传入i，changeValue方法将传入的变量赋值为20<br>输出i  </p>
<p>结果是：<strong>10</strong><br>changValue方法内部对<strong>形参a</strong>的修改并没有影响到<strong>实参i</strong><br><strong>第一个结论：Java中基本类型的传值方式是按值传递</strong>  </p>
<p>第二个例子，引用类型传值：    </p>
<pre><code>public class Example {
    public static void main(String[] args) {
        String i = &quot;hawk&quot;;
        changString(i);
        System.out.println(i);
    }
    public static void changString(String a ) {
        a = &quot;HAWK&quot;;
    }
}    </code></pre><p>上面的代码解释如下：<br>定义一个String类型的变量i，赋值为”hawk”<br>调用changeString方法，将传入的变量赋值为”HAWK”<br>输出i  </p>
<p>结果： <strong>hawk</strong><br>在Java中String类型虽然可以直接赋值，但是是引用类型，<strong>因为String类型的具体值保存在堆中，而不是栈上</strong><br>既然String是引用类型， 上面的例子又说明String是值传递的  那么我们是不是就可以得出：<br><strong>Java中引用类型也是值传递的</strong>，这样的结论呢？  </p>
<p>我们来看第三个例子：  </p>
<pre><code>public class Example {
    int i = 20;
    public static void main(String[] args) {
        Example ex = new Example();
        changValue(ex);
        System.out.println(ex.i);
    }
    public static void changValue(Example e ) {
        e.i = 30;
    }
}  </code></pre><p>上面的代码解释如下：<br>实例化一个Example对象ex，ex中只有一个属性i，初始值为20<br>调用changValue方法，将ex中的属性i的值赋值为30<br>输出ex中属性i的值  </p>
<p>结果是：<strong>30</strong><br>这样的结果就让很多人产生了困惑，String类型是引用类型，对象也是引用类型，为什么第二个例子不能改变i的值，第三个例子却改变了ex中i的值呢？<strong>Java中引用类型的参数传递到底是引用传递还是值传递呢？</strong>  </p>
<p>其实，第二个例子和第三个例子我们所关注的点已经是错误的了，自然无法得出正确的结论<br>我们回顾一下<strong>引用传递和值传递的本质区别和行为表现上的区别</strong> </p>
<table>
<tr>
    <td></td>
    <td>按值传递</td>
    <td>按引用传递</td>
</tr>
<tr>
    <td>本质区别</td>
    <td>创建副本</td>
    <td>不创建副本</td>
</tr>
<tr>
    <td>表现结果</td>
    <td>函数中<b>无法改变原始对象</b></td>
    <td>函数中<b>可以改变原始对象</b></td>
</tr>
</table>
注意到了吗？我们应该关注的是**原始对象的变化**  
> **Java中，引用类型的原始对象（即原始值）是保存在堆中的，变量中存储的是原始值的引用（Java中存储的是该对象在堆中的内存地址），**
> **该引用指向堆中的对象,所以我们<font color="red">关注的关键点应该是对象的引用有没有发生变化</font>，而不是原始对象中的内容有没有发生变化**

<p><strong><font color="red">重要依据：</font>如果可以改变对象的引用，就说明是引用传递，如果不能改变对象的引用就说明是值传递</strong><br>下面我们多举一个例子： </p>
<pre><code>public class Example {
    int i = 20;
    public static void main(String[] args) {
        Example ex = new Example();
        changValue(ex);
        System.out.println(ex.i);
    }
    public static void changValue(Example e ) {
        e = new Example();
        e.i = 50;
    }
}  </code></pre><p>这个例子和上面第三个例子很相似，区别在于：<br>changValue方法中将一个新的原始对象的引用赋值给了形参e<br><strong>如果Java是按引用传递的话，e = new Example();就是修改了实参ex的引用，即就是改变了原始对象<br>如果Java是按值传递的话，实参ex不会有任何变化</strong>  </p>
<p>结果：<strong>20</strong>  </p>
<p>这个结果说明：<strong>changValue方法并没有修改到ex的引用，也就是说，e只是ex的副本，对e的引用进行的所有操作都不会影响到ex，所以我们<br>从上述代码运行的结果也可以证明Java中是只有值传递的</strong></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.hollischuang.com/archives/2275" target="_blank">为什么说Java中只有值传递</a><br><a href="http://menzhongxin.com/2017/02/07/%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92-%E6%8C%89%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E5%92%8C%E6%8C%89%E5%85%B1%E4%BA%AB%E4%BC%A0%E9%80%92/" target="_blank">按值传递、按引用传递、按共享传递</a><br><a href="https://www.zhihu.com/question/20628016/answer/28970414" target="_blank">为什么 Java 只有值传递，但 C# 既有值传递，又有引用传递，这种语言设计有哪些好处？</a></p>
]]></content>
      
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>/2019/07/15/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      
        
    </entry>
    
  
  
</search>
