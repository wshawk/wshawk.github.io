<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MySQL基础架构</title>
      <link href="/post/b3cb123.html"/>
      <url>/post/b3cb123.html</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL基础架构"><a href="#MySQL基础架构" class="headerlink" title="MySQL基础架构"></a>MySQL基础架构</h1><blockquote><p><code>MySQL</code>大致可以分为客户端层、<code>Server</code>层和存储引擎两层。</p><p><code>Server </code>层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 <code>MySQL</code> 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</p><p>存储引擎层负责数据的存储和提取。其架构模式是<strong>插件式</strong>的，支持 <code>InnoDB</code>、<code>MyISAM</code>、<code>Memory</code> 等多个存储引擎。现在最常用的存储引擎是<code>InnoDB</code>，它从 <code>MySQL 5.5.5</code> 版本开始成为了默认存储引擎。</p><p><strong>不同的存储引擎，是共用同一个<code>Server</code>层的。</strong></p></blockquote><p>组件关系图如下：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1057015/1633496173460-f793c5c4-67f9-421a-8dff-575831e6226b.png"></p><h2 id="客户端层"><a href="#客户端层" class="headerlink" title="客户端层"></a>客户端层</h2><blockquote><p>用户访问<code>MySQL</code>的接口。在客户端，用户可以输入<code>SQL</code>语句，通过<code>SQL</code>语句，实现对数据库的访问、操作和控制。</p></blockquote><h2 id="MySQL-Server-层"><a href="#MySQL-Server-层" class="headerlink" title="MySQL Server 层"></a>MySQL Server 层</h2><h3 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h3><blockquote><p>连接器负责跟客户端建立连接、获取权限、维持和管理连接。</p></blockquote><p>注意点：</p><blockquote><ol><li>连接器在用户登录时读取用户权限<strong>并用于后续判断，</strong>所以管理员修改密码对已登录用户无效（除非该用户重新登录）</li><li>客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数 <code>wait_timeout</code> 控制的，默认值是 8 小时</li></ol></blockquote><h3 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h3><blockquote><p>把查询到的结果缓存并返回（<code>KV</code>结构，<code>Key</code>：<code>select</code>语句的<code>hash</code>值，<code>Value</code>：查询结果）。</p><p>但<code>MySQL</code>缓存机制有个弊端，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。如此一来，对于更新频繁的表来说，缓存命中率会非常低！<code>MySQL 8.0 </code>版本直接将查询缓存的整块功能移除了。</p></blockquote><h3 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h3><blockquote><p>对一条<code>SQL</code>进行词法分析、语法分析。也就是准确识别<code>select</code>/<code>update</code>/<code>insert</code>/<code>delete</code>、表名、字段名以及各种条件，并对<code>SQL</code>的语法进行校验。</p></blockquote><h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><blockquote><p>优化器会对执行的<code>SQL</code>进行优化，主要有：</p><ol><li><p>表里面有多个索引的时候，决定使用哪个索引</p></li><li><p>在一个语句有多表关联（<code>join</code>）的时候，决定各个表的连接顺序</p></li></ol></blockquote><h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><blockquote><p>执行器负责调用存储引擎，返回结果，主要有以下几个步骤</p><ol><li>权限校验（连接器阶段已经读取权限，这里只要校验当前用户是否拥有操作这张表的权限）</li><li>选择引擎</li><li>调用引擎提供的接口</li></ol></blockquote><h2 id="存储引擎层"><a href="#存储引擎层" class="headerlink" title="存储引擎层"></a>存储引擎层</h2><blockquote><p>存储引擎层负责数据的存储和提取。其架构模式是<strong>插件式</strong>的，支持 <code>InnoDB</code>、<code>MyISAM</code>、<code>Memory</code> 等多个存储引擎。现在最常用的存储引擎是<code>InnoDB</code>，它从 <code>MySQL 5.5.5</code> 版本开始成为了默认存储引擎。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL锁</title>
      <link href="/post/d940f18d.html"/>
      <url>/post/d940f18d.html</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL锁"><a href="#MySQL锁" class="headerlink" title="MySQL锁"></a>MySQL锁</h1><p>[TOC]</p><hr><h2 id="按照锁思想分类"><a href="#按照锁思想分类" class="headerlink" title="按照锁思想分类"></a>按照锁思想分类</h2><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><blockquote><p>需要应用程序实现，<code>MySQL</code>自身并未实现。</p></blockquote><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><h2 id="按照锁类型分类"><a href="#按照锁类型分类" class="headerlink" title="按照锁类型分类"></a>按照锁类型分类</h2><h3 id="读锁（共享锁、S锁）"><a href="#读锁（共享锁、S锁）" class="headerlink" title="读锁（共享锁、S锁）"></a>读锁（共享锁、S锁）</h3><blockquote><ol><li>加了读锁的事务，允许该事务进行读，不允许其他事务进行修改</li><li>同一行数据，可以被多个事务获得读锁</li><li>其他事务不能再获取写锁，只能等获得读锁的所有事务释放后，才能加写锁</li></ol></blockquote><h3 id="写锁（排他锁、X锁）"><a href="#写锁（排他锁、X锁）" class="headerlink" title="写锁（排他锁、X锁）"></a>写锁（排他锁、X锁）</h3><blockquote><ol><li>一个事务获取了写锁，那么该事务可以进行数据的查看及修改</li><li>在该事务提交（释放锁）之前，不允许其他事务对该数据进行读操作或者写操作，会被阻塞住</li><li>即添加了写锁之后，只允许拥有该锁的事务进行读、写</li></ol></blockquote><h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><blockquote><ol><li>意向锁的主要用途是显示某人正在锁定一行，或者将要锁定表中的一行</li><li>想获取读锁或者写锁，必须先获取意向锁</li><li>申请意向锁的动作是数据库自动完成的</li></ol></blockquote><h4 id="意向共享锁（IS-Lock）"><a href="#意向共享锁（IS-Lock）" class="headerlink" title="意向共享锁（IS Lock）"></a>意向共享锁（IS Lock）</h4><h4 id="意向排他锁（IX-Lock）"><a href="#意向排他锁（IX-Lock）" class="headerlink" title="意向排他锁（IX Lock）"></a>意向排他锁（IX Lock）</h4><h2 id="按照锁级别分类"><a href="#按照锁级别分类" class="headerlink" title="按照锁级别分类"></a>按照锁级别分类</h2><h3 id="全局锁（数据库级别）"><a href="#全局锁（数据库级别）" class="headerlink" title="全局锁（数据库级别）"></a>全局锁（数据库级别）</h3><blockquote><p><code>FTWRL</code>主要包括3个步骤：</p><ol><li>上全局读锁(<code>lock_global_read_lock</code>)</li><li>清理表缓存(<code>close_cached_tables</code>)</li><li>上全局<code>COMMIT</code>锁(<code>make_global_read_lock_block_commit</code>)</li></ol></blockquote><h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><blockquote><ol><li><p>上全局读锁会导致所有更新操作都会被堵塞；关闭表过程中，如果有大查询导致关闭表等待，那么所有访问这个表的查询和更新都需要等待；</p></li><li><p>上全局<code>COMMIT</code>锁时，会堵塞活跃事务提交。</p></li></ol></blockquote><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加锁：flush tables with read lock</span></span><br><span class="line"><span class="comment">// 执行后整个数据库将处于只读状态</span></span><br><span class="line"><span class="comment">// 解锁： unlock tables</span></span><br></pre></td></tr></table></figure><h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>表锁不是由<code>InnoDB</code>存储引擎层管理的，而是由其上一层──<code>MySQL Server</code>负责的。</p><blockquote><p>ps:  仅当<code>autocommit=0</code>、<code>InnoDB_table_locks = 1</code>（默认设置）时，<code>InnoDB</code>层才能知道<code>MySQL</code>加的表锁，</p><p><code>MySQL Server</code>也才能感知<code>InnoDB</code>加的行锁，这种情况下，<code>InnoDB</code>才能自动识别涉及表级锁的死锁，否则，<code>InnoDB</code>将无法自动检测并处理这种死锁。</p></blockquote><blockquote><p>在用<code> LOCK TABLES</code>对<code>InnoDB</code>表加锁时要注意，要将<code>AUTOCOMMIT</code>设为<code>0</code>，否则<code>MySQL</code>不会给表加锁；<br>事务结束前，不要用<code>UNLOCK TABLES</code>释放表锁，因为<code>UNLOCK TABLES</code>会隐含地提交事务；<br><code>COMMIT</code>或<code>ROLLBACK</code>并不能释放用<code>LOCK TABLES</code>加的表级锁，必须用<code>UNLOCK TABLES</code>释放表锁。</p></blockquote><h4 id="意向锁-1"><a href="#意向锁-1" class="headerlink" title="意向锁"></a>意向锁</h4><blockquote><ol><li>意向锁的主要用途是显示某人正在锁定一行，或者将要锁定表中的一行</li><li>想获取读锁或者写锁，必须先获取意向锁</li><li>申请意向锁的动作是数据库自动完成的</li></ol></blockquote><h4 id="自增锁"><a href="#自增锁" class="headerlink" title="自增锁"></a>自增锁</h4><p><code>Innodb_autoinc_lock_mode</code>变量控制用于<strong>自动增量</strong>锁定的算法。它允许您选择如何在可预测的自动增量值序列和插入操作的最大并发性之间进行权衡。</p><p>该变量有三个可选值：<code>0</code>、<code>1</code>、<code>2</code>。</p><h5 id="传统模式（0）"><a href="#传统模式（0）" class="headerlink" title="传统模式（0）"></a>传统模式（0）</h5><blockquote><ol><li><p>所有的<code>insert </code>都会获得一个自增锁</p></li><li><p><code>insert</code>执行结束后就立即释放自增锁，不必等待事务结束</p></li></ol></blockquote><h5 id="连续模式（1）"><a href="#连续模式（1）" class="headerlink" title="连续模式（1）"></a>连续模式（1）</h5><blockquote><ol><li><p>像执行<code>INSERT INTO</code>这样的语句时，可以提前知道要插入的数量</p></li><li><p>使用<code>mutex</code>轻量级锁，分配完毕就释放</p></li></ol></blockquote><h5 id="交叉模式（2）"><a href="#交叉模式（2）" class="headerlink" title="交叉模式（2）"></a>交叉模式（2）</h5><blockquote><ol><li>执行 <code>INSERT </code>和<code>INSERT INTO ... SELECT</code>无法预知插入的数量的情况</li><li>使用较为轻量的 <code>mutex</code> 锁</li><li><del>主从复制时， <code>binlog</code>必须为<code>Row</code>模式，如果是<code>statement</code>模式的话，可能会出现数据不一致</del>【<strong>待考证</strong>，有另一种说法见<a href="https://zhuanlan.zhihu.com/p/376811677">深入剖析 MySQL 自增锁</a>评论区】</li></ol></blockquote><h5 id="注意点-1"><a href="#注意点-1" class="headerlink" title="注意点"></a>注意点</h5><blockquote><p><code>5.1.22</code>版本及之前， 默认为 –&gt; 传统模式</p><p><code>MySQL 8.0 </code>之前，<code>InnoDB</code> 锁模式默认 –&gt; 连续模式</p><p><code>MySQL 8.0</code> 之后，默认模式 –&gt; 交叉模式</p></blockquote><h3 id="扩展（MyISAM表锁）"><a href="#扩展（MyISAM表锁）" class="headerlink" title="扩展（MyISAM表锁）"></a>扩展（<code>MyISAM</code>表锁）</h3><p><code>MyISAM</code>存储引擎只支持表锁，同时<code>MyISAM</code>不会出现死锁（下面会解释）。</p><h4 id="查询MyISAM表级锁争用情况"><a href="#查询MyISAM表级锁争用情况" class="headerlink" title="查询MyISAM表级锁争用情况"></a>查询<code>MyISAM</code>表级锁争用情况</h4><blockquote><p>通过<code>show status like &#39;table%&#39;;</code>， 查看<code>table_locks_waited</code>、<code>table_locks_immediate</code>状态变量，若<code>table_locks_waited</code>变量的值较高，则说明存在较严重的表级锁争抢情况。</p></blockquote><h4 id="DeadLock-Free"><a href="#DeadLock-Free" class="headerlink" title="DeadLock Free"></a><code>DeadLock Free</code></h4><blockquote><p><code>MyISAM</code>在执行<code>lock tables</code>时，必须同时取得所有涉及表的表锁，并且<code>MySQL</code>不支持锁升级；所以<code>MyISAM</code>中不会出现死锁。</p></blockquote><h4 id="MyISAM并发插入"><a href="#MyISAM并发插入" class="headerlink" title="MyISAM并发插入"></a><code>MyISAM</code>并发插入</h4><blockquote><p><code>MyISAM</code>表不支持<code>MVCC</code>。</p><p><code>MyISAM</code>表的读操作与写操作，以及写操作之间是串行的。</p></blockquote><p><code>concurrent_insert</code>变量。</p><blockquote><p>当<code>concurrent_insert=0</code>时，不允许并发插入功能。</p><p>当<code>concurrent_insert=1</code>时，允许对没有空洞的表使用并发插入，新数据位于数据文件结尾(<strong>默认</strong>)。</p><p>当<code>concurrent_insert=2</code>时，不管表有没有空洞，都允许在数据文件结尾并发插入。</p></blockquote><blockquote><p><strong>空洞</strong>：表的中间有被删除的行，空出来的那一行。</p></blockquote><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><blockquote><p><code>MyISAM</code>表的读操作与写操作，以及写操作之间是串行的。</p><p>并且默认情况下写操作命令的执行优先于读操作执行，即使读请求早于写请求到达，写锁也会插队到读请求前面，因为<code>MySQL</code>认为写请求一般比读请求要重要。</p><p>这也导致了有大量的并发更新操作时，读请求很有可能被阻塞。</p><p>可以通过这些方法解决：</p><ol><li><p>通过指定启动参数<code>low-priority-updates</code>，使<code>MyISAM</code>引擎默认给予读请求以优先的权利。</p></li><li><p>通过执行命令<code>SET LOW_PRIORITY_UPDATES=1</code>，使该连接发出的更新请求优先级降低。</p></li><li><p>通过指定<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>语句的<code>LOW_PRIORITY</code>属性，降低该语句的优先级。</p></li></ol></blockquote><h3 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h3><p><strong><code>InnoDB</code>行锁是通过给索引项加锁来实现的，如果没有索引，<code>InnoDB</code>将通过隐藏的聚簇索引来对记录加锁。</strong></p><h4 id="排他锁、共享锁"><a href="#排他锁、共享锁" class="headerlink" title="排他锁、共享锁"></a>排他锁、共享锁</h4><p>在获取排他锁之前，<code>InnoDB</code>会自动申请该表的意向排他锁，不需要用户手动处理。<br>对于<code>update</code>、<code>delete</code>和<code>insert</code>语句，<code>InnoDB</code>会自动给涉及到的数据行加排他锁；<br>对于普通的<code>select</code>语句，<code>InnoDB</code>不会加任何锁。<br>事务可以通过以下语句显式给数据行加共享锁或排他锁。</p><p><code>MySQL5.7</code></p><blockquote><p>共享锁：<code>select * from table_name where ... lock in share mode</code><br>排他锁：<code>select * from table_name where ... for update</code></p></blockquote><p><code>MySQL8.0</code></p><blockquote><p>共享锁：<code>select * from table_name where ... for share</code><br>排他锁：<code>select * from table_name where ... for update [nowait | skip locked]</code></p></blockquote><p><code>MySQL8.0</code>向下兼容，支持<code>MySQL5.7</code>的语法。<br><code>MySQL5.7</code>中的排他锁，如果遇到锁等待，那么<code>session</code>默认会等待<code>50s</code>，在高并发系统中，一旦出现对热点行的争用，<br>将会造成连接数的快速增加，甚至超过最大连接数。<br>所以在<code>MySQL8.0</code>中，增加了两个可选参数<code>nowait</code>、<code>skip locked</code>。</p><blockquote><p><code>nowait</code>: 发现有锁等待后，会立即返回错误，不用等到锁超时后报错<br><code>skip locked</code>: 跳过被锁定的行，直接更新其他行，这样可能会造成更新结果不符合预期</p></blockquote><h4 id="InnoDB行锁的实现方式"><a href="#InnoDB行锁的实现方式" class="headerlink" title="InnoDB行锁的实现方式"></a><code>InnoDB</code>行锁的实现方式</h4><p><code>InnoDB</code>行锁是通过给索引上的索引项加锁来实现的，如果没有索引，<code>InnoDB</code>将通过隐藏的聚簇索引来对记录加锁。</p><blockquote><p><code>InnoDB</code>这种行锁的实现特点导致了， 如果<strong>在加锁的时候不通过索引条件查询数据，那么<code>InnoDB</code>将对表中所有的记录加行锁，实际效果和表锁一样。</strong></p></blockquote><p><code>InnoDB</code>行锁是通过给索引上的索引项加锁来实现的，而不是针对记录加的锁，所以虽然是访问不同行的记录，<strong>如果索引项的值是相同的话，也是会出现锁冲突的。</strong></p><p>当表有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行，不论是使用主键索引、唯一索引还是普通索引，<code>InnoDB</code>都会使用行锁来给数据加锁。</p><h4 id="Record-Lock（记录锁）"><a href="#Record-Lock（记录锁）" class="headerlink" title="Record Lock（记录锁）"></a>Record Lock（记录锁）</h4><blockquote><p>数据行上加锁。</p></blockquote><h4 id="Gap-Lock（间隙锁）、"><a href="#Gap-Lock（间隙锁）、" class="headerlink" title="Gap Lock（间隙锁）、"></a>Gap Lock（间隙锁）、</h4><blockquote><ol><li>只有在可重复读、串行化隔离级别才有该锁</li><li>锁定范围空间的数据（范围条件、相等条件查询不存在的记录时）</li></ol></blockquote><p>举例：</p><blockquote><p>假设id有3,4,5，锁定id&gt;3的数据，是指的4，5及后面的数字都会被锁定</p></blockquote><blockquote><p>对于没有索引的列，当前读操作时，会加全表间隙锁。</p><p>非唯一索引列，如果where条件部分命中(&gt;、&lt;、like等)或者全未命中，则会加附近Gap间隙锁</p></blockquote><p>举例：</p><blockquote><p>某表数据如下，非唯一索引2,6,9,11,15。<br>执行<code>delete from table where t_id = 9</code>;<br>gap锁将会锁定的列是<code>(6,11]</code>，该区间内无法插入数据。</p></blockquote><h4 id="Next-Key-Lock（临键锁）"><a href="#Next-Key-Lock（临键锁）" class="headerlink" title="Next Key Lock（临键锁）"></a>Next Key Lock（临键锁）</h4><blockquote><p>Record Lock + Gap Lock</p></blockquote><h4 id="Insert-Intention-Lock（插入意向锁）"><a href="#Insert-Intention-Lock（插入意向锁）" class="headerlink" title="Insert Intention Lock（插入意向锁）"></a>Insert Intention Lock（插入意向锁）</h4><p>是间隙锁的一种。</p><blockquote><p>插入意向锁不会阻止任何锁，对于插入的记录会持有一个Record Lock</p><p>假设有一个记录索引包含键值<code>4</code>和<code>7</code>，不同的事务分别插入<code>5</code>和<code>6</code>，每个事务都会产生一个加在<code>4-7</code>之间的插入意向锁，<br>获取在插入行上的排它锁，但是不会被互相锁住，因为数据行并不冲突。</p></blockquote><h3 id="页锁"><a href="#页锁" class="headerlink" title="页锁"></a>页锁</h3><blockquote><p>比表锁并发高，比行锁并发低。</p><p><code>BDB</code>存储引擎支持，<code>5.1</code>版本之后就被弃用。</p></blockquote><h2 id="按照加锁方式分类"><a href="#按照加锁方式分类" class="headerlink" title="按照加锁方式分类"></a>按照加锁方式分类</h2><h3 id="自动加锁（隐式加锁）"><a href="#自动加锁（隐式加锁）" class="headerlink" title="自动加锁（隐式加锁）"></a>自动加锁（隐式加锁）</h3><h4 id="DML语句"><a href="#DML语句" class="headerlink" title="DML语句"></a>DML语句</h4><blockquote><p>自动获得所需要的表级锁和行级锁</p></blockquote><h4 id="DDL语句"><a href="#DDL语句" class="headerlink" title="DDL语句"></a>DDL语句</h4><h5 id="排他锁"><a href="#排他锁" class="headerlink" title="排他锁"></a>排他锁</h5><blockquote><p>创建、修改、删除一个数据库对象的 <code>DDL</code> 语句获得操作对象的 排它锁</p></blockquote><h5 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h5><blockquote><p>需在数据库对象之间建立相互依赖关系的 <code>DDL</code> 语句通常需共享获得 <code>DDL</code>锁</p></blockquote><h3 id="显式加锁"><a href="#显式加锁" class="headerlink" title="显式加锁"></a>显式加锁</h3><h5 id="LOCK-TABLES"><a href="#LOCK-TABLES" class="headerlink" title="LOCK TABLES"></a>LOCK TABLES</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LOCK TABLES  tbl_name  read<span class="operator">|</span>write, tbl_name read<span class="operator">|</span>write, ...  # 手动加表锁</span><br><span class="line"></span><br><span class="line">UNLOCK TABLES  # 解开该事务全部的锁，后面不跟表名，必须在事务提交之后再执行，此操作会隐式的提交事务</span><br></pre></td></tr></table></figure><h5 id="FLUSH-TABLES"><a href="#FLUSH-TABLES" class="headerlink" title="FLUSH TABLES"></a>FLUSH TABLES</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FLUSH TABLES tbl_name,... [<span class="keyword">WITH</span> READ LOCK];</span><br></pre></td></tr></table></figure><h2 id="Two-Phase-Locking-2PL，两阶段锁定"><a href="#Two-Phase-Locking-2PL，两阶段锁定" class="headerlink" title="Two-Phase Locking(2PL，两阶段锁定)"></a>Two-Phase Locking(2PL，两阶段锁定)</h2><h3 id="加锁阶段"><a href="#加锁阶段" class="headerlink" title="加锁阶段"></a>加锁阶段</h3><blockquote><p>事务开始时处于加锁阶段，此时只允许加锁，不允许解锁；并且所有加锁操作必须在解锁操作之前。</p></blockquote><h3 id="解锁阶段"><a href="#解锁阶段" class="headerlink" title="解锁阶段"></a>解锁阶段</h3><blockquote><p>事务<code>commit</code>或者<code>rollback</code>时，进入解锁阶段，此阶段只允许解锁，不允许加锁。</p></blockquote><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><blockquote><p><code>Basic 2PL</code>(基本<code>2PL</code>):  在事务过程中，分为获得锁和释放锁两个阶段</p><p><code>Strict 2PL</code>(严格<code>2PL</code>):  直到事务结束为止，都不释放获得的锁</p><p><code>Static 2PL</code>(静态<code>2PL</code>):  在事务开始前，获得所需的全部锁</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><ol><li><strong>加锁和解锁操作不能交叉执行（同一个事务内）</strong></li><li><strong>加锁总是优先于解锁</strong></li><li><strong><code>2PL</code>并不能够避免死锁，只是用来防止并发事务对数据的干扰</strong></li></ol></blockquote><p> 参考：<a href="https://www.bookstack.cn/read/aliyun-rds-core/2a01f200518fbdb0.md">数据库系统 · 事物并发控制 · Two-phase Lock Protocol</a></p><h3 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h3><blockquote><p><code>MySQL</code> 在开始某个事务的时候，会隐式提交上一个事务。所以 <code>MySQL</code> 本身是不支持事务嵌套的。</p><p>但 <code>MySQL</code> 也给我们提供了一个 <code>SAVEPOINT</code> 来做出类似事务嵌套的动作。</p></blockquote><p>参考：<a href="https://blog.csdn.net/github_35780607/article/details/115630361">MySQL事务嵌套</a></p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="关于死锁"><a href="#关于死锁" class="headerlink" title="关于死锁"></a>关于死锁</h3><blockquote><p><code>MyISAM</code>是<code>DeadLock Free</code>的，因为它总是一次获取整个事务需要的资源，要么全部满足，要么等待。</p><p>在<code>InnoDB</code>中，除了单个<code>SQL</code>组成的事务外，锁是逐步获取的，所以会出现死锁。</p></blockquote><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><blockquote><p>一般情况下，发生死锁后，<code>InnoDB</code>都能够检测到死锁，并使一个事务释放锁并回退，另一个事务获得锁，继续完成事务。</p><p>但在涉及外部锁或者涉及表锁的情况下，<code>InnoDB</code>并不能完全自动检测到死锁，这个时候，可以设置锁等待超时参数<code>innodb_lock_wait_timeout</code>，降低锁等待时间，尽快失败，避免高并发时数据库性能问题。</p></blockquote><h3 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h3><blockquote><ul><li>合理划分事务大小</li><li>在代码中理清表之间的资源关系，避免形成互相等待资源的局面</li><li>在事务中，如果要更新记录，应直接申请足够级别的锁，而不是先申请共享锁，等到更新时再申请排他锁</li></ul></blockquote><h3 id="wait-for-graph（死锁检测机制）"><a href="#wait-for-graph（死锁检测机制）" class="headerlink" title="wait-for graph（死锁检测机制）"></a>wait-for graph（死锁检测机制）</h3><h4 id="死锁的必要条件"><a href="#死锁的必要条件" class="headerlink" title="死锁的必要条件"></a>死锁的必要条件</h4><blockquote><ol><li>多个并发事务（2个或者以上）；</li><li>每个事务都持有锁（或者是已经在等待锁）；</li><li>每个事务都需要再继续持有锁（为了完成事务逻辑，还必须更新更多的行）；</li><li>事务之间产生加锁的循环等待，形成死锁。</li></ol></blockquote><h4 id="wait-for-graph-算法"><a href="#wait-for-graph-算法" class="headerlink" title="wait-for graph 算法"></a>wait-for graph 算法</h4><blockquote><p><code>InnoDB</code>将各个事务看为一个个节点，资源就是各个事务占用的锁，当事务<code>1</code>需要等待事务<code>2</code>的锁时，就生成一条有向边从<code>1</code>指向<code>2</code>，最后行成一个有向图。</p><p>我们只要检测这个有向图是否出现环路即可，出现环路就是死锁！这就是<code>wait-for graph </code>算法。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL优化笔记（MySQL）</title>
      <link href="/post/9ae99909.html"/>
      <url>/post/9ae99909.html</url>
      
        <content type="html"><![CDATA[<h1 id="SQL优化笔记（MySQL）"><a href="#SQL优化笔记（MySQL）" class="headerlink" title="SQL优化笔记（MySQL）"></a>SQL优化笔记（MySQL）</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ol><li><strong>减少IO次数</strong></li><li><strong>降低CPU的计算</strong></li></ol><h2 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h2><ol><li><strong>尽量少 join</strong></li></ol><p>　　MySQL 的优势在于简单，但这在某些方面其实也是其劣势。MySQL  优化器效率高，但是由于其统计信息的量有限，优化器工作过程出现偏差的可能性也就更多。对于复杂的多表 Join，一方面由于其优化器受限，再者在  Join 这方面所下的功夫还不够，所以性能表现离 Oracle  等关系型数据库前辈还是有一定距离。但如果是简单的单表查询，这一差距就会极小甚至在有些场景下要优于这些数据库前辈。</p><ol start="2"><li><strong>尽量少排序</strong></li></ol><p>　　排序操作会消耗较多的 CPU 资源，所以减少排序可以在缓存命中率高等 IO 能力足够的场景下会较大影响 SQL 的响应时间。</p><p>　　对于MySQL来说，减少排序有多种办法，比如：</p><p>　　上面误区中提到的通过利用索引来排序的方式进行优化</p><p>　　减少参与排序的记录条数</p><p>　　非必要不对数据进行排序</p><p>　　…</p><ol start="3"><li>**尽量避免 select ***</li></ol><p>　　很多人看到这一点后觉得比较难理解，上面不是在误区中刚刚说 select 子句中字段的多少并不会影响到读取的数据吗?</p><p>　　是的，大多数时候并不会影响到 IO 量，但是当我们还存在 order by 操作的时候，select 子句中的字段多少会在很大程度上影响到我们的排序效率，这一点可以通过我之前一篇介绍 MySQL ORDER BY 的实现分析的文章中有较为详细的介绍。</p><p>　　此外，上面误区中不是也说了，只是大多数时候是不会影响到 IO 量，当我们的查询结果仅仅只需要在索引中就能找到的时候，还是会极大减少 IO 量的。</p><ol start="4"><li><strong>尽量用 join 代替子查询</strong></li></ol><p>　　虽然 Join 性能并不佳，但是和 MySQL 的子查询比起来还是有非常大的性能优势。MySQL  的子查询执行计划一直存在较大的问题，虽然这个问题已经存在多年，但是到目前已经发布的所有稳定版本中都普遍存在，一直没有太大改善。虽然官方也在很早就承认这一问题，并且承诺尽快解决，但是至少到目前为止我们还没有看到哪一个版本较好的解决了这一问题。</p><ol start="5"><li><strong>尽量少 or</strong></li></ol><p>　　当 where 子句中存在多个条件以“或”并存的时候，MySQL 的优化器并没有很好的解决其执行计划优化问题，再加上 MySQL  特有的 SQL 与 Storage 分层架构方式，造成了其性能比较低下，很多时候使用 union all  或者是union(必要的时候)的方式来代替“or”会得到更好的效果。</p><ol start="6"><li><strong>尽量用 union all 代替 union</strong></li></ol><p>　　union 和 union all  的差异主要是前者需要将两个(或者多个)结果集合并后再进行唯一性过滤操作，这就会涉及到排序，增加大量的 CPU  运算，加大资源消耗及延迟。所以当我们可以确认不可能出现重复结果集或者不在乎重复结果集的时候，尽量使用 union all 而不是 union。</p><ol start="7"><li><strong>尽量早过滤</strong></li></ol><p>　　这一优化策略其实最常见于索引的优化设计中(将过滤性更好的字段放得更靠前)。</p><p>　　在 SQL 编写中同样可以使用这一原则来优化一些 Join 的  SQL。比如我们在多个表进行分页数据查询的时候，我们最好是能够在一个表上先过滤好数据分好页，然后再用分好页的结果集与另外的表  Join，这样可以尽可能多的减少不必要的 IO 操作，大大节省 IO 操作所消耗的时间。</p><ol start="8"><li><strong>避免类型转换</strong></li></ol><p>　　这里所说的“类型转换”是指 where 子句中出现 column 字段的类型和传入的参数类型不一致的时候发生的类型转换：</p><p>　　人为在column_name 上通过转换函数进行转换</p><p>　　直接导致 MySQL(实际上其他数据库也会有同样的问题)无法使用索引，如果非要转换，应该在传入的参数上进行转换</p><p>　　由数据库自己进行转换</p><p>　　如果我们传入的数据类型和字段类型不一致，同时我们又没有做任何类型转换处理，MySQL 可能会自己对我们的数据进行类型转换操作，也可能不进行处理而交由存储引擎去处理，这样一来，就会出现索引无法使用的情况而造成执行计划问题。</p><ol start="9"><li><strong>优先优化高并发的 SQL，而不是执行频率低某些“大”SQL</strong></li></ol><p>　　对于破坏性来说，高并发的 SQL 总是会比低频率的来得大，因为高并发的 SQL  一旦出现问题，甚至不会给我们任何喘息的机会就会将系统压跨。而对于一些虽然需要消耗大量 IO 而且响应很慢的  SQL，由于频率低，即使遇到，最多就是让整个系统响应慢一点，但至少可能撑一会儿，让我们有缓冲的机会。</p><ol start="10"><li><strong>从全局出发优化，而不是片面调整</strong></li></ol><p>　　SQL 优化不能是单独针对某一个进行，而应充分考虑系统中所有的 SQL，尤其是在通过调整索引优化 SQL 的执行计划的时候，千万不能顾此失彼，因小失大。</p><ol start="11"><li><strong>尽可能对每一条运行在数据库中的SQL进行 explain</strong></li></ol><p>　　优化 SQL，需要做到心中有数，知道 SQL 的执行计划才能判断是否有优化余地，才能判断是否存在执行计划问题。在对数据库中运行的  SQL 进行了一段时间的优化之后，很明显的问题 SQL 可能已经很少了，大多都需要去发掘，这时候就需要进行大量的 explain  操作收集执行计划，并判断是否需要进行优化。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL事务</title>
      <link href="/post/f91535f.html"/>
      <url>/post/f91535f.html</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL事务-InnoDB"><a href="#MySQL事务-InnoDB" class="headerlink" title="MySQL事务(InnoDB)"></a>MySQL事务(InnoDB)</h1><h2 id="事务的概念"><a href="#事务的概念" class="headerlink" title="事务的概念"></a>事务的概念</h2><p>事务就是一个不可分割的操作单元，其中的多个操作被认为是一个整体，要么全部执行成功，要么执行失败。</p><h2 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h2><p>通常来说，我们一般认为事务具有四个特性。</p><h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h3><blockquote><p>不同的事务之间，是互相隔离的，不会互相影响。</p><p>通过锁和<code>MVCC</code>来实现。</p></blockquote><h3 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h3><blockquote><p>一旦事务执行完成，那么对事务中影响到的数据的变化，是永久的，一般是指持久化到磁盘上或者日志文件中。</p><p>通过<code>redo log</code>来实现</p></blockquote><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><blockquote><p>一个事务中的多个操作，被认为是一个整体，不可再分割，只要其中一个操作执行失败，就认为整个事务执行失败了。</p><p>基于<code>undo log</code>。</p></blockquote><h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><blockquote><p>事务执行完成后，对于数据的变化，要求要一致。举例来说，转帐，A向B转账，B向C转账，在两个操作结束之后，数据结果要求一致。</p><p>通过回滚，以及恢复，和在并发环境下的隔离做到一致性，也就是基于上述的 <code>redo log</code>、<code>undo log</code>、<code>MVCC</code>等一起实现。</p></blockquote><h2 id="并发事务可能产生的问题"><a href="#并发事务可能产生的问题" class="headerlink" title="并发事务可能产生的问题"></a>并发事务可能产生的问题</h2><h3 id="数据丢失"><a href="#数据丢失" class="headerlink" title="数据丢失"></a>数据丢失</h3><blockquote><p>多个事务选择同一行数据进行更新，最后一个提交的事务所做的修改覆盖了前面其他事务提交的更新。</p></blockquote><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><blockquote><p>事务A可以读到事务B未<code>commit</code>的数据</p></blockquote><h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><blockquote><p>同一事务的其他实例在该实例处理其间可能会有新的<code>commit</code>，同一<code>select</code>可能返回不同结果, 查询结果的值有变化</p></blockquote><h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><blockquote><p>用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行， 查询结果行数变化。</p></blockquote><h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><p>事务隔离级别是一个标准，在不同的事务隔离级别下，对于事务特性的保证是有差异的，随之也会产生一些问题。</p><h3 id="读未提交"><a href="#读未提交" class="headerlink" title="读未提交"></a>读未提交</h3><p>不同的事务之间，会读到其他事务未提交的数据。保证了<strong>持久性</strong>、<strong>原子性</strong>，但是<strong>没有保证隔离性及一致性</strong>，会出现以下问题：</p><ul><li>脏读</li><li>幻读</li><li>不可重复读</li></ul><h3 id="读已提交"><a href="#读已提交" class="headerlink" title="读已提交"></a>读已提交</h3><p>不同事务之间，只会读取到其他事务提交的数据，解决了脏读的问题，但依然存在</p><ul><li>幻读</li><li>不可重复读</li></ul><h3 id="可重复读（MySQL默认的隔离级别）"><a href="#可重复读（MySQL默认的隔离级别）" class="headerlink" title="可重复读（MySQL默认的隔离级别）"></a>可重复读（MySQL默认的隔离级别）</h3><p>解决了不可重复读的问题，保证了同一事务中多次读取的数据是一样的。会存在</p><ul><li>幻读</li></ul><h3 id="串行化"><a href="#串行化" class="headerlink" title="串行化"></a>串行化</h3><p>不同的事务之间，不再具备并发能力，只能一个个排着队执行，解决了上述的问题，但性能极差。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github搭建Hexo双分支博客防止本地文件丢失</title>
      <link href="/post/6c408847.html"/>
      <url>/post/6c408847.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>转载于： <a href="https://www.jianshu.com/p/7d8df0de1fc7">Github搭建Hexo双分支博客防止本地文件丢失</a></p></blockquote><h1 id="一、关于搭建流程"><a href="#一、关于搭建流程" class="headerlink" title="一、关于搭建流程"></a>一、关于搭建流程</h1><ol><li><p>创建仓库，Godbn.github.io</p></li><li><p>创建两个分支:master和hexo</p></li><li><p>在options里面设置hexo为默认分支(注意这个分支保存的是网站源文件，并不是生成后上传github上用于显示的)</p></li><li><p>使用以下命令拷贝仓库到本地桌面</p></li></ol><blockquote><p>git clone <a href="mailto:&#x67;&#x69;&#x74;&#x40;&#103;&#105;&#x74;&#104;&#x75;&#x62;&#x2e;&#x63;&#111;&#x6d;">&#x67;&#x69;&#x74;&#x40;&#103;&#105;&#x74;&#104;&#x75;&#x62;&#x2e;&#x63;&#111;&#x6d;</a>:Godbn/Godbn.github.io.git</p></blockquote><ol start="5"><li>终端进入Godbn.github.io目录，依次执行</li></ol><blockquote><p>  npm install hexo</p><p>  hexo init</p><p>  npm install</p><p>  npm install hexo-deployer-git (用于生成上传至github)</p></blockquote><ol start="6"><li>修改_config.yml中的deploy参数</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/4797359-7085b85ebbfdd97d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/374/format/webp" alt="img"></p><ol start="7"><li>下载hexo themes主题自己百度安装调试好,我目前使用的是Sky，地址我贴出来</li></ol><blockquote><p><a href="https://github.com/iJinxin/hexo-theme-sky">https://github.com/iJinxin/hexo-theme-sky</a></p></blockquote><ol start="8"><li>依次执行以下三条命令提交网站相关的文件</li></ol><blockquote><p>git add .</p><p>git commit -m “…”</p><p>git push origin hexo</p></blockquote><ol start="9"><li>执行hexo g -d 生成网站并部署到github上 (每次可以在前面输入 hexo clean 清理下)</li></ol><blockquote><p>hexo clean</p><p>hexo g -d</p></blockquote><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><p><strong>分支hexo储存的是网站的原始文件</strong></p><p><strong>分支master用来储存生成的静态网页</strong></p><h1 id="二、日常改动"><a href="#二、日常改动" class="headerlink" title="二、日常改动"></a>二、日常改动</h1><h3 id="本地添加文章，样式等"><a href="#本地添加文章，样式等" class="headerlink" title="本地添加文章，样式等"></a>本地添加文章，样式等</h3><ol><li>依次执行以下命令git到分支hexo上</li></ol><blockquote><p>git add .</p><p>git commit -m “…”</p><p>git push origin hexo</p></blockquote><ol start="2"><li>再执行以下命令发布网站到分支master</li></ol><blockquote><p>hexo g -d</p></blockquote><h1 id="三、其他电脑更新github博客"><a href="#三、其他电脑更新github博客" class="headerlink" title="三、其他电脑更新github博客"></a>三、其他电脑更新github博客</h1><ol><li>使用命令将仓库拷贝到本地</li></ol><blockquote><p>git clone <a href="mailto:&#103;&#105;&#116;&#x40;&#x67;&#105;&#116;&#104;&#117;&#x62;&#x2e;&#x63;&#x6f;&#x6d;">&#103;&#105;&#116;&#x40;&#x67;&#105;&#116;&#104;&#117;&#x62;&#x2e;&#x63;&#x6f;&#x6d;</a>:Godbn/Godbn.github.io.git</p></blockquote><ol start="2"><li>在Godbn.github.io文件夹中通过以下恢复原始文件</li></ol><blockquote><p>npm install hexo</p><p>npm install</p><p>npm install hexo-deployer-git –save</p></blockquote><h1 id="四、结束"><a href="#四、结束" class="headerlink" title="四、结束"></a>四、结束</h1><p>以上是get到知乎上的回答搭建的</p><p>传送门：</p><blockquote><p><a href="https://www.zhihu.com/question/21193762">https://www.zhihu.com/question/21193762</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat概述</title>
      <link href="/post/b5f2cfa4.html"/>
      <url>/post/b5f2cfa4.html</url>
      
        <content type="html"><![CDATA[<h1 id="Tomcat概述"><a href="#Tomcat概述" class="headerlink" title="Tomcat概述"></a>Tomcat概述</h1><h2 id="1-Tomcat-核心组件"><a href="#1-Tomcat-核心组件" class="headerlink" title="1. Tomcat 核心组件"></a>1. Tomcat 核心组件</h2><p><img src="https://hawk-note-doc.oss-cn-shenzhen.aliyuncs.com/Java/tomcat/image/image-20220416104036286.png" alt="image-20220416104036286"></p><blockquote><p>Connector(连接器): 由 端口号 + 协议 组成。</p></blockquote><h2 id="2-核心组件协作过程"><a href="#2-核心组件协作过程" class="headerlink" title="2. 核心组件协作过程"></a>2. 核心组件协作过程</h2><p><img src="https://hawk-note-doc.oss-cn-shenzhen.aliyuncs.com/Java/tomcat/image/image-20220416104036286.png" alt="image-20220416104220796"></p><blockquote><p>要点：</p><ol><li>连接器可以有多个，不同的连接器可以对应同一个站点</li><li>同一个连接器下，可以有多个站点</li></ol><p>即，连接器和站点之间的关系是多对多的。</p><p>站点和应用上下文之间是一对多的关系，即一个站点对应该站点下多个应用上下文。站点和资源同样是一对多的关系</p></blockquote><h2 id="3-源码剖析"><a href="#3-源码剖析" class="headerlink" title="3. 源码剖析"></a>3. 源码剖析</h2><h3 id="3-1-server-xml"><a href="#3-1-server-xml" class="headerlink" title="3.1 server.xml"></a>3.1 server.xml</h3><p><img src="https://hawk-note-doc.oss-cn-shenzhen.aliyuncs.com/Java/tomcat/image/image-20220416111749492.png" alt="image-20220416111749492"></p><blockquote><p>Connector(连接器)：</p><ul><li>port：端口</li><li>protocol：协议</li></ul><p>Host(站点)：</p><ul><li>name: 域名</li><li>appBase：站点对应资源的路径，可配置全路径或者相对路径，相对路径是相对于tomcat的根路径。</li><li>unpackWARs：是否自动将WAR文件解压</li><li>autoDeploy：是否自动部署</li></ul></blockquote><p><img src="https://hawk-note-doc.oss-cn-shenzhen.aliyuncs.com/Java/tomcat/image/image-20220416130805986.png" alt="image-20220416130805986"></p><blockquote><p>Context(应用上下文): 在Host对应的appBase目录下的文件夹是隐式的Context， 通过Context标签可以显示的设置Host下的Context</p></blockquote><h3 id="3-2-请求流程分析"><a href="#3-2-请求流程分析" class="headerlink" title="3.2 请求流程分析"></a>3.2 请求流程分析</h3><p><img src="https://hawk-note-doc.oss-cn-shenzhen.aliyuncs.com/Java/tomcat/image/image-20220416131334951.png" alt="image-20220416131334951"></p><blockquote><p>Engine、Host、Context 每一层都有自己的一个pipline结构，里面包含多个Valve</p></blockquote><p><img src="https://hawk-note-doc.oss-cn-shenzhen.aliyuncs.com/Java/tomcat/image/image-20220416131729641.png" alt="image-20220416131729641"></p><p><img src="https://hawk-note-doc.oss-cn-shenzhen.aliyuncs.com/Java/tomcat/image/image-20220416134256318.png" alt="image-20220416134256318"></p><blockquote><p>Tomcat 请求处理源码入口为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">org.apache.catalina.connector.CoyoteAdapter#service() 方法</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (postParseSuccess) &#123;</span><br><span class="line">                <span class="comment">//check valves if we support async</span></span><br><span class="line">                request.setAsyncSupported(</span><br><span class="line">                        connector.getService().getContainer().getPipeline().isAsyncSupported());</span><br><span class="line">                <span class="comment">// Calling the container 根据connector 获取到对应的Service、Container，</span></span><br><span class="line">         <span class="comment">// 然后获取到pipline中的第一个Engine，执行invoke方法，默认会有一个标准的StandardEngine</span></span><br><span class="line">                connector.getService().getContainer().getPipeline().getFirst().invoke(</span><br><span class="line">                        request, response);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure></blockquote><p><strong>StandardEngineValve</strong>如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">StandardEngineValve</span> <span class="keyword">extends</span> <span class="title class_">ValveBase</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StandardEngineValve</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(Request request, Response response)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="comment">// 根据请求获取对应的host站点</span></span><br><span class="line">        <span class="type">Host</span> <span class="variable">host</span> <span class="operator">=</span> request.getHost();</span><br><span class="line">        <span class="keyword">if</span> (host == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!response.isError()) &#123;</span><br><span class="line">                response.sendError(<span class="number">404</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// 判断是否支持异步</span></span><br><span class="line">            <span class="keyword">if</span> (request.isAsyncSupported()) &#123;</span><br><span class="line">                request.setAsyncSupported(host.getPipeline().isAsyncSupported());</span><br><span class="line">            &#125;</span><br><span class="line">  <span class="comment">// 获取到 host 的 pipline 中的第一个 Valve 执行invoke方法，最后会到StandardHostValve</span></span><br><span class="line">            host.getPipeline().getFirst().invoke(request, response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>StandaHostValve</strong>中的invoke方法如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(Request request, Response response)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"><span class="comment">// 获取host下的context</span></span><br><span class="line">      <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> request.getContext();</span><br><span class="line">      <span class="keyword">if</span> (context == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!response.isError()) &#123;</span><br><span class="line">              response.sendError(<span class="number">404</span>);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">//....省略一些代码</span></span><br><span class="line">                      <span class="keyword">if</span> (!response.isErrorReportRequired()) &#123;</span><br><span class="line">                          <span class="comment">// context 下的pipline，最后进入StandardContextValve</span></span><br><span class="line">                          context.getPipeline().getFirst().invoke(request, response);</span><br><span class="line">                      &#125;</span><br><span class="line">  <span class="comment">//....省略一些代码        </span></span><br><span class="line">                  &#125; </span><br><span class="line">  <span class="comment">//....省略一些代码              </span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>StandardContextValve</strong>的invoke方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(Request request, Response response)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">     <span class="type">MessageBytes</span> <span class="variable">requestPathMB</span> <span class="operator">=</span> request.getRequestPathMB();</span><br><span class="line">     <span class="keyword">if</span> (!requestPathMB.startsWithIgnoreCase(<span class="string">&quot;/META-INF/&quot;</span>, <span class="number">0</span>) &amp;&amp; !requestPathMB.equalsIgnoreCase(<span class="string">&quot;/META-INF&quot;</span>) &amp;&amp; !requestPathMB.startsWithIgnoreCase(<span class="string">&quot;/WEB-INF/&quot;</span>, <span class="number">0</span>) &amp;&amp; !requestPathMB.equalsIgnoreCase(<span class="string">&quot;/WEB-INF&quot;</span>)) &#123;</span><br><span class="line">         <span class="type">Wrapper</span> <span class="variable">wrapper</span> <span class="operator">=</span> request.getWrapper();</span><br><span class="line">         <span class="keyword">if</span> (wrapper != <span class="literal">null</span> &amp;&amp; !wrapper.isUnavailable()) &#123;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 response.sendAcknowledgement(ContinueResponseTiming.IMMEDIATELY);</span><br><span class="line">             &#125; <span class="keyword">catch</span> (IOException var6) &#123;</span><br><span class="line">                 <span class="built_in">this</span>.container.getLogger().error(sm.getString(<span class="string">&quot;standardContextValve.acknowledgeException&quot;</span>), var6);</span><br><span class="line">                 request.setAttribute(<span class="string">&quot;javax.servlet.error.exception&quot;</span>, var6);</span><br><span class="line">                 response.sendError(<span class="number">500</span>);</span><br><span class="line">                 <span class="keyword">return</span>;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span> (request.isAsyncSupported()) &#123;</span><br><span class="line">                 request.setAsyncSupported(wrapper.getPipeline().isAsyncSupported());</span><br><span class="line">             &#125;</span><br><span class="line"><span class="comment">// 继续获取pipline中的valve执行，最后进入 StandardWrapperValve</span></span><br><span class="line">             wrapper.getPipeline().getFirst().invoke(request, response);</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             response.sendError(<span class="number">404</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         response.sendError(<span class="number">404</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>StandardWrapperValve</strong> 中invoke方法会在经过FilterChain最后进入Serlvet。</p><blockquote><p>总结：</p><p>总的请求处理流程是这样的：</p><p>Connector –&gt; Service –&gt; Engine  –&gt; Host –&gt; Context –&gt; Wrapper(资源)</p><p>从Engine开始到Wrapper中的每一层，都有一个pipline的对象，且都有标准实现，即形成了一个多pipline的结构。</p><p>每一个pipline中可以存在多个Valve，默认最后一个是StandardValve，我们添加的Valve都在标准Valve的前面。</p><p>执行到Engine时，会获取Engine中的pipline，然后开始依次执行pipline中xxxValve的invoke方法，直到执行到标准Valve，然后再进入下一层的pipline。</p></blockquote><h2 id="4-线程池配置理论"><a href="#4-线程池配置理论" class="headerlink" title="4. 线程池配置理论"></a>4. 线程池配置理论</h2><p>常用的配置主要有：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">tomcat:</span></span><br><span class="line">    <span class="attr">max-threads:</span> <span class="number">5</span> <span class="comment"># 最大线程数</span></span><br><span class="line">    <span class="attr">min-spare-threads:</span> <span class="number">2</span> <span class="comment"># 最小线程数，初始化的线程数量</span></span><br><span class="line">    <span class="attr">max-connections:</span> <span class="number">10</span> <span class="comment"># 最大连接数</span></span><br><span class="line">    <span class="attr">accept-count:</span> <span class="number">5</span> <span class="comment"># 等待队列</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>tomcat线程配置说明：</p><p>tomcat启动时会初始化配置指定的最小线程数量的业务线程</p><p>当业务线程满了，仍有请求来的话，会创建新的线程来处理请求，直到达到配置的最大线程数</p><p>当达到最大线程数，仍有请求进入时，会放到tomcat线程池中的 任务队列 中，此队列能够存储的请求数量为Integer.MAX_VALUE</p><p>当队列里存储的请求数 + 最大线程数 达到了配置中的 最大连接数 时，请求会进入accept-count配置的等待队列中</p><p>此时内核可以建立TCP连接，但不会在JVM中建立新的连接，当请求数量达到了 等待队列 的上限后，内核也会直接拒绝连接。</p><p>综上，tomcat最大连接数是由maxConnection + acceptCount 来决定的。</p><p>maxConnection决定能在JVM中建立的最大连接数量。</p><p>acceptCount决定在操作系统中能建立的连接数量。</p></blockquote><p>Tomcat建立连接入口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">org.apache.tomcat.util.net.Acceptor#run()</span><br><span class="line"></span><br><span class="line">   <span class="comment">// ---省略一些代码----</span></span><br><span class="line">  <span class="comment">// 此处是检查连接的数量是否达到了最大连接数</span></span><br><span class="line">  <span class="built_in">this</span>.endpoint.countUpOrAwaitConnection();</span><br><span class="line">  <span class="comment">// ---省略一些代码----</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">           socket = <span class="built_in">this</span>.endpoint.serverSocketAccept();</span><br><span class="line">      &#125;</span><br><span class="line">  <span class="comment">// ---省略一些代码----</span></span><br></pre></td></tr></table></figure><p>**org.apache.tomcat.util.net.NioEndpoint#initServerSocket()**方法</p><p><img src="https://hawk-note-doc.oss-cn-shenzhen.aliyuncs.com/Java/tomcat/image/image-20220416144101469.png" alt="image-20220416144101469"></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高并发名词</title>
      <link href="/post/b39fa119.html"/>
      <url>/post/b39fa119.html</url>
      
        <content type="html"><![CDATA[<h1 id="高并发名词"><a href="#高并发名词" class="headerlink" title="高并发名词"></a>高并发名词</h1><h2 id="1-PV（Page-View）"><a href="#1-PV（Page-View）" class="headerlink" title="1. PV（Page View）"></a>1. PV（Page View）</h2><blockquote><p>页面浏览量统计，用户每刷新一次页面，PV值加一。</p></blockquote><h2 id="2-UV（User-View）"><a href="#2-UV（User-View）" class="headerlink" title="2. UV（User View）"></a>2. UV（User View）</h2><blockquote><p>用户访问量统计，根据用户来统计，同一个用户在系统里无论点击多少个页面，UV 统计只加一。</p></blockquote><h2 id="3-RT（Response-Time）"><a href="#3-RT（Response-Time）" class="headerlink" title="3. RT（Response Time）"></a>3. RT（Response Time）</h2><blockquote><p>响应时间。前端页面发出请求开始到接收到后台响应之间的时间。</p><p>一般来说，</p><p>1ms~100ms之间的响应，人们基本感觉不到这个请求的耗时；</p><p>1s左右的响应时间，人们明显能感觉的到系统反应慢，但勉强能接受；</p><p>大于3s的响应时间，人们已经无法接受了，基本都会认为系统有问题；</p></blockquote><h2 id="4-并发用户数"><a href="#4-并发用户数" class="headerlink" title="4. 并发用户数"></a>4. 并发用户数</h2><blockquote><p>并发用户数是指系统可以同时承载的正常使用系统功能的用户的数量。</p></blockquote><h2 id="5-TPS（Transactions-Per-Second）"><a href="#5-TPS（Transactions-Per-Second）" class="headerlink" title="5. TPS（Transactions Per Second）"></a>5. TPS（Transactions Per Second）</h2><blockquote><p>系统每秒处理交易数。</p><p>比如下单事务，中间可能调用多个接口，但是属于下单这个流程，完成一整个下单流程，TPS记为 1。 </p></blockquote><h2 id="6-QPS（Query-Per-Second）"><a href="#6-QPS（Query-Per-Second）" class="headerlink" title="6.  QPS（Query Per Second）"></a>6.  QPS（Query Per Second）</h2><blockquote><p>系统每秒处理查询次数，单位是次/秒。 对于互联网业务中，如果某些业务有且仅有一个请求连接，那么TPS=QPS=HPS，一般情况下用TPS来衡量整个业务流程，用QPS来衡量接口查询次数，用HPS来表示对服务器单击请求。</p></blockquote><h2 id="7-RPS（Request-Per-Second）"><a href="#7-RPS（Request-Per-Second）" class="headerlink" title="7. RPS（Request Per Second）"></a>7. RPS（Request Per Second）</h2><blockquote><p>每秒请求数，等同于QPS，都是接口级别的统计。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP的Content-Length头字段</title>
      <link href="/post/3857b8c0.html"/>
      <url>/post/3857b8c0.html</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP的Content-Length头字段"><a href="#HTTP的Content-Length头字段" class="headerlink" title="HTTP的Content-Length头字段"></a>HTTP的Content-Length头字段</h1><p><em><strong>Content-Length</strong></em>用于<strong>描述HTTP消息实体的传输长度</strong>（<em>the transfer-length of the message-body</em>）。</p><p>在<code>HTTP</code>协议中，消息实体长度和消息实体的传输长度是有区别的。</p><blockquote><p>消息实体长度：消息实体本身的长度。</p><p>消息实体的传输长度：消息实体在传输时的长度。</p></blockquote><p>比如说gzip压缩下，消息实体长度就是压缩前的长度，消息实体的传输长度是gzip压缩后的长度。</p><p>在具体的HTTP交互中，客户端是如何获取消息长度的呢，主要基于以下几个规则：<br>响应为<code>1xx</code>，<code>204</code>，<code>304</code>或者head请求，则直接忽视掉消息实体内容。</p><p>如果有<em><strong>Transfer-Encoding</strong></em>，则优先采用<em><strong>Transfer-Encoding</strong></em>里面的方法来找到对应的长度。比如说<em><strong>Chunked</strong></em>模式。</p><p>如果<em><strong>head</strong></em>中有<em><strong>Content-Length</strong></em>，那么这个<em><strong>Content-Length</strong></em>既表示实体长度，又表示传输长度。</p><p>如果实体长度和传输长度不相等（比如说设置了<em><strong>Transfer-Encoding</strong></em>），那么则不能设置<em><strong>Content-Length</strong></em>。如果设置了<em><strong>Transfer-Encoding</strong></em>，那么<em><strong>Content-Length</strong></em>将被忽视。</p><p><strong>有chunk就不能有content-length</strong> 。</p><p>其实后面几条几乎可以忽视，简单总结后如下：<br>1、<em><strong>Content-Length</strong></em>如果存在并且有效的话，则必须和<strong>消息内容的传输长度</strong>完全一致。（经过测试，如果过短则会截断，过长则会导致超时。）<br>2、如果存在<em><strong>Transfer-Encoding</strong></em>（重点是<em><strong>chunked</strong></em>），则在<em><strong>header</strong></em>中不能有<em><strong>Content-Length</strong></em>，有也会被忽视。<br>3、如果采用短连接，则直接可以通过服务器关闭连接来确定消息的传输长度。（这个很容易懂）</p><p>结合<code>HTTP</code>协议其他的特点，比如说HTTP1.1之前的不支持keep alive。那么可以得出以下结论：<br>1、在<code>HTTP1.0</code>及之前版本中，<em><strong>Content-Length</strong></em>字段可有可无。<br>2、在<code>HTTP1.1</code>及之后版本。如果是<em><strong>keep alive</strong></em>，则<em><strong>Content-Length</strong></em>和<em><strong>chunk</strong></em>必然是二选一。若是非<em><strong>keep alive</strong></em>，则和<code>HTTP1.0</code>一样。<em><strong>Content-Length</strong></em>可有可无。</p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接口幂等性</title>
      <link href="/post/a26b78e0.html"/>
      <url>/post/a26b78e0.html</url>
      
        <content type="html"><![CDATA[<h1 id="接口幂等性"><a href="#接口幂等性" class="headerlink" title="接口幂等性"></a>接口幂等性</h1><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><p><strong>接口幂等性</strong></p><blockquote><p><strong>一次和多次请求某一个资源，对资源本身所产生的的影响均与一次执行的影响相同</strong>。</p><p>幂等性是系统服务对外的一种承诺，承诺只要调用接口成功了，多次调用对系统的影响是一致的。</p></blockquote><h2 id="2-幂等性与重复提交比较"><a href="#2-幂等性与重复提交比较" class="headerlink" title="2. 幂等性与重复提交比较"></a>2. 幂等性与重复提交比较</h2><p><strong>幂等性</strong> 更多使用的情况是第一次请求知道结果，但是由于网络抖动或连接超时等情况未进行正常返回，在这种情况下系统自动再次发起请求，其目的是确认第一次是否请求完成。</p><p><strong>重复提交</strong> 更多使用的情况是第一次请求成功或请求结果暂未返回的情况下，人为的进行多次操作。</p><p>实际上二者表现的情况是一样的，都会多次的调用一个接口，并且传参相同。</p><h2 id="3-SQL语句的幂等性"><a href="#3-SQL语句的幂等性" class="headerlink" title="3. SQL语句的幂等性"></a>3. SQL语句的幂等性</h2><h3 id="3-1-SELECT"><a href="#3-1-SELECT" class="headerlink" title="3.1 SELECT"></a>3.1 SELECT</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `table_name` <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1024</span>;</span><br></pre></td></tr></table></figure><p><code>select</code>语句具有天然的幂等性，因为select语句只是进行查询，并不会修改数据。</p><h3 id="3-2-UPDATE"><a href="#3-2-UPDATE" class="headerlink" title="3.2 UPDATE"></a>3.2 UPDATE</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> table_name <span class="keyword">SET</span> column_xx <span class="operator">=</span> <span class="string">&#x27;xxx&#x27;</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1024</span>;</span><br></pre></td></tr></table></figure><p>像上面这个<code>update</code>语句，执行多次和执行一次是一样的效果，这样的是幂等的。</p><p>下面这个<code>update</code>语句就不是幂等的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> table_name <span class="keyword">SET</span> column_xx <span class="operator">=</span> column_xx <span class="operator">+</span> <span class="number">1</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1024</span>;</span><br></pre></td></tr></table></figure><h3 id="3-3-DELETE"><a href="#3-3-DELETE" class="headerlink" title="3.3 DELETE"></a>3.3 DELETE</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1024</span>;</span><br></pre></td></tr></table></figure><p>这样的删除语句也是幂等的。</p><h3 id="3-4-INSERT"><a href="#3-4-INSERT" class="headerlink" title="3.4 INSERT"></a>3.4 INSERT</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name (xxx, xxx, xxx) <span class="keyword">VALUES</span> (aa, bb, cc);</span><br></pre></td></tr></table></figure><p>插入语句不是幂等的。除非插入的数据项中有一个唯一索引，并且语句如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name (xxx, xxx, xxx) <span class="keyword">VALUES</span> (aa, bb, cc) <span class="keyword">ON</span> DUPLICATE KEY <span class="keyword">UPDATE</span> ...</span><br></pre></td></tr></table></figure><h2 id="4-实现方案"><a href="#4-实现方案" class="headerlink" title="4. 实现方案"></a>4. 实现方案</h2><h3 id="4-1-方案一"><a href="#4-1-方案一" class="headerlink" title="4.1 方案一"></a>4.1 方案一</h3><p>下游系统提供相应查询接口。</p><p>上游系统在 <code>timeout</code> 后，首先去查询一下，如果查到了，就表明已经做了，成功了就不用做了，失败了就走失败流程。</p><h3 id="4-2-方案二"><a href="#4-2-方案二" class="headerlink" title="4.2 方案二"></a>4.2 方案二</h3><p>将这个查询操作交给下游系统，上游系统只管重试，下游系统保证一次和多次的请求产生的影响是一样的。这时我们就说下游系统提供的接口支持幂等性。</p><h2 id="5-下游系统实现接口幂等性"><a href="#5-下游系统实现接口幂等性" class="headerlink" title="5. 下游系统实现接口幂等性"></a>5. 下游系统实现接口幂等性</h2><h3 id="5-1-通过代码逻辑判断实现"><a href="#5-1-通过代码逻辑判断实现" class="headerlink" title="5.1 通过代码逻辑判断实现"></a>5.1 通过代码逻辑判断实现</h3><blockquote><p><a href="https://www.cnblogs.com/huaixiaonian/p/9577567.html">https://www.cnblogs.com/huaixiaonian/p/9577567.html</a></p></blockquote><h3 id="5-2-通过token机制实现"><a href="#5-2-通过token机制实现" class="headerlink" title="5.2 通过token机制实现"></a>5.2 通过token机制实现</h3><p>使用token机制实现接口幂等性,通用性强的实现方法</p><p>   token机制实现步骤:</p><ol><li><p>生成全局唯一的token,token放到redis或jvm内存,token会在页面跳转时获取.存放到pageScope中,支付请求提交先获取token</p></li><li><p>提交后后台校验token，执行提交逻辑,提交成功同时删除token，生成新的token更新redis ,这样当第一次提交后token更新了,页面再次提交携带的token是已删除的token后台验证会失败不让提交</p></li></ol><p>   token特点：  要申请，一次有效性，可以限流</p><p>   注意： redis要用删除操作来判断token，删除成功代表token校验通过，如果用select+delete来校验token，存在并发问题，不建议使用</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux安装Redis 6.0.5 ./install_server.sh报错</title>
      <link href="/post/d30a1526.html"/>
      <url>/post/d30a1526.html</url>
      
        <content type="html"><![CDATA[<h1 id="Linux安装Redis-6-0-5-install-server-sh报错"><a href="#Linux安装Redis-6-0-5-install-server-sh报错" class="headerlink" title="Linux安装Redis 6.0.5   ./install_server.sh报错"></a>Linux安装Redis 6.0.5   ./install_server.sh报错</h1><p>linux 安装Redis6.0.5时<br>进行到<code>./install_server.sh</code>时报错，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">This systems seems to use systemd.</span><br><span class="line">Please take a look at the provided example service unit files in this directory, and adapt and install them. Sorry!</span><br></pre></td></tr></table></figure><p>解决方案：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi ./install_server.sh</span><br></pre></td></tr></table></figure><p>注释下面的代码即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">bail <span class="keyword">if</span> this system is managed by systemd</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">_pid_1_exe=<span class="string">&quot;<span class="subst">$(readlink -f /proc/1/exe)</span>&quot;</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$&#123;_pid_1_exe##*/&#125;</span>&quot;</span> = systemd ]</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="keyword">then</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">      <span class="built_in">echo</span> <span class="string">&quot;This systems seems to use systemd.&quot;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">      <span class="built_in">echo</span> <span class="string">&quot;Please take a look at the provided example service unit files in this directory, and adapt and install them. Sorry!&quot;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">      <span class="built_in">exit</span> 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="keyword">fi</span></span></span><br></pre></td></tr></table></figure><p>然后重新运行 <code>./install_server.sh</code>即可。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7 防火墙相关命令</title>
      <link href="/post/372de7b5.html"/>
      <url>/post/372de7b5.html</url>
      
        <content type="html"><![CDATA[<h1 id="CentOS7-防火墙相关命令"><a href="#CentOS7-防火墙相关命令" class="headerlink" title="CentOS7 防火墙相关命令"></a>CentOS7 防火墙相关命令</h1><ol><li>查看防火墙状态</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --state</span><br></pre></td></tr></table></figure><ol start="2"><li>停止firewall</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld.service</span><br></pre></td></tr></table></figure><ol start="3"><li>开启firewall</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld.service</span><br></pre></td></tr></table></figure><ol start="4"><li>禁止firewall 开机启动</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl disable firewalld.service</span><br></pre></td></tr></table></figure><ol start="5"><li>设置开机启动防火墙</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable firewalld.service</span><br></pre></td></tr></table></figure><ol start="6"><li>重启防火墙</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><ol start="7"><li>对外开放端口</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">说明:</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">–zone 作用域</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">–add-port=80/tcp 添加端口，格式为：端口/通讯协议</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">–permanent 永久生效，没有此参数重启后失效</span></span><br><span class="line">firewall-cmd --zone=public --add-port=端口号/tcp --permanent</span><br></pre></td></tr></table></figure><ol start="8"><li>关闭对外端口</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --remove-port=端口号/tcp --permanent</span><br></pre></td></tr></table></figure><ol start="9"><li>查看已经对外开放的端口</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置开放某个端口后，需要重启防火墙，才能看到刚刚开启的端口</span></span><br><span class="line">firewall-cmd --list-ports</span><br></pre></td></tr></table></figure><ol start="10"><li>查看防火墙所有相关信息</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --list-all</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Bean</title>
      <link href="/post/cb377708.html"/>
      <url>/post/cb377708.html</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-Bean"><a href="#Spring-Bean" class="headerlink" title="Spring Bean"></a>Spring Bean</h1><p>在Spring中，bean 是一个被实例化，组装，并通过 Spring IoC 容器所管理的<strong>对象</strong>。（**<font color="red">也就是由spring来进行管理的资源对象</font>**）</p><h2 id="1-如何将bean放入spring容器中"><a href="#1-如何将bean放入spring容器中" class="headerlink" title="1. 如何将bean放入spring容器中"></a>1. 如何将bean放入spring容器中</h2><p><strong>既然要让spring来管理这些资源类，那么就需要将资源放入到容器中，这样spring容器才能将资源提供给有需要的类进行使用，那么如何将bean对象放入到spring容器中呢？</strong></p><p>有以下三种方法：</p><ul><li><strong><font color="red">Java config配置</font></strong></li></ul><p>使用Java config的方式进行配置时，不需要创建额外的xml文件，需要创建一个java的config类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> byJavaConfig;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span> <span class="comment">// 表明是一个配置类</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;byJavaConfig&quot;)</span> <span class="comment">// 扫描路径</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringBeanConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;helloworld&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> HelloWorld <span class="title function_">getHelloWorld</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HelloWorld</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bean对象的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="keyword">package</span> byJavaConfig;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello Spring By JavaConfig&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试运行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> byJavaConfig;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Run</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 通过IOC容器获得Bean</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringBeanConfig.class);</span><br><span class="line">        <span class="type">HelloWorld</span> <span class="variable">helloWorld</span> <span class="operator">=</span> (HelloWorld)context.getBean(<span class="string">&quot;helloworld&quot;</span>);</span><br><span class="line">        helloWorld.getMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><font color="red">xml配置</font></strong></li></ul><p>使用xml配置，需要创建一个xml文件，命名可以进行自定义，示例代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;helloWorld&quot;</span> <span class="attr">class</span>=<span class="string">&quot;byXML.HelloWorld&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>XML 格式配置文件的根元素是 <code>&lt;beans&gt;</code>，该元素包含了多个<code>&lt;bean&gt;</code>子元素，每一个<code> &lt;bean&gt;</code> 子元素定义了一个 Bean，并描述了该 Bean 如何被装配到 Spring 容器中。</p><p>bean对象的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> byXML;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello Spring By XML&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试运行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> byXML;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Run</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;spring-XML.xml&quot;</span>);</span><br><span class="line">        <span class="type">HelloWorld</span> <span class="variable">obj</span> <span class="operator">=</span> (HelloWorld) context.getBean(<span class="string">&quot;helloWorld&quot;</span>);</span><br><span class="line">        obj.getMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><font color="red">注解配置</font></strong></li></ul><p>注解配置也是需要一份xml的配置文件的，如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">         http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">         http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">         http://www.springframework.org/schema/context/spring-context-3.0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;byZHUJIE&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 声明包扫描路径 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Bean对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> byZHUJIE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component(&quot;hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello Spring By 注解&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> byZHUJIE;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Run</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span></span><br><span class="line">                (<span class="string">&quot;spring-ZHUJIE.xml&quot;</span>);</span><br><span class="line">        <span class="type">HelloWorld</span> <span class="variable">helloWorld</span> <span class="operator">=</span> (HelloWorld) ctx.getBean(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        helloWorld.getMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-Bean的作用域"><a href="#2-Bean的作用域" class="headerlink" title="2. Bean的作用域"></a>2. Bean的作用域</h2><p>Spring 容器在初始化一个 Bean 的实例时，同时会指定该实例的作用域。Spring3 为 Bean 定义了五种作用域，具体如下。</p><h4 id="1）singleton"><a href="#1）singleton" class="headerlink" title="1）singleton"></a>1）singleton</h4><p>单例模式，使用 singleton 定义的 Bean 在 Spring 容器中只有一个实例，这也是 Bean 默认的作用域。</p><h4 id="2）prototype"><a href="#2）prototype" class="headerlink" title="2）prototype"></a>2）prototype</h4><p>原型模式，每次通过 Spring 容器获取 prototype 定义的 Bean 时，容器都将创建一个新的 Bean 实例。</p><h4 id="3）request"><a href="#3）request" class="headerlink" title="3）request"></a>3）request</h4><p>在一次 HTTP 请求中，容器会返回该 Bean 的同一个实例。而对不同的 HTTP 请求，会返回不同的实例，该作用域仅在当前 HTTP Request 内有效。</p><h4 id="4）session"><a href="#4）session" class="headerlink" title="4）session"></a>4）session</h4><p>在一次 HTTP Session 中，容器会返回该 Bean 的同一个实例。而对不同的 HTTP 请求，会返回不同的实例，该作用域仅在当前 HTTP Session 内有效。</p><h4 id="5）global-Session"><a href="#5）global-Session" class="headerlink" title="5）global Session"></a>5）global Session</h4><p>在一个全局的 HTTP Session 中，容器会返回该 Bean 的同一个实例。该作用域仅在使用 portlet context 时有效。</p><h2 id="3-Bean的生命周期"><a href="#3-Bean的生命周期" class="headerlink" title="3. Bean的生命周期"></a>3. Bean的生命周期</h2><p><font color="#FF3030" size="3">注意：Spring 只帮我们管理单例模式 Bean 的完整生命周期,对于 prototype 的 bean ,Spring 在创建好交给使用者之后则不会再管理后续的生命周期。</font></p><p>1、实例化一个Bean－－也就是我们常说的new；</p><p>2、按照Spring上下文对实例化的Bean进行配置－－也就是依赖注入；</p><p>3、如果这个Bean已经实现了BeanNameAware接口，会调用它实现的setBeanName(String)方法，此处传递的就是Spring配置文件中Bean的id值</p><p>4、如果这个Bean已经实现了BeanFactoryAware接口，会调用它实现的setBeanFactory(setBeanFactory(BeanFactory)传递的是Spring工厂自身（可以用这个方式来获取其它Bean，只需在Spring配置文件中配置一个普通的Bean就可以）；</p><p>5、如果这个Bean已经实现了ApplicationContextAware接口，会调用setApplicationContext(ApplicationContext)方法，传入Spring上下文（同样这个方式也可以实现步骤4的内容，但比4更好，因为ApplicationContext是BeanFactory的子接口，有更多的实现方法）；<br><font color="#FF3030" size="3">注：去掉此步骤就是BeanFactory的Bean的生命周期</font></p><p>6、如果这个Bean关联了BeanPostProcessor接口，将会调用postProcessBeforeInitialization(Object obj, String s)方法，BeanPostProcessor经常被用作是Bean内容的更改，并且由于这个是在Bean初始化结束时调用那个的方法，也可以被应用于内存或缓存技术；</p><p>7、如果Bean在Spring配置文件中配置了init-method属性会自动调用其配置的初始化方法。</p><p>8、如果这个Bean关联了BeanPostProcessor接口，将会调用postProcessAfterInitialization(Object obj, String s)方法、；</p><p><font color="#FF3030" size="3">注：以上工作完成以后就可以应用这个Bean了，那这个Bean是一个Singleton的，所以一般情况下我们调用同一个id的Bean会是在内容地址相同的实例</font></p><p>9、当Bean不再需要时，会经过清理阶段，如果Bean实现了DisposableBean这个接口，会调用那个其实现的destroy()方法；</p><p>10、最后，如果这个Bean的Spring配置中配置了destroy-method属性，会自动调用其配置的销毁方法</p><p>简单来说就四步</p><ul><li>实例化</li><li>属性赋值</li><li>初始化</li><li>销毁</li></ul><p>其余的操作都是在穿插在这四步之中</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap详解-源码分析</title>
      <link href="/post/9ca5d950.html"/>
      <url>/post/9ca5d950.html</url>
      
        <content type="html"><![CDATA[<h1 id="HashMap详解-源码分析"><a href="#HashMap详解-源码分析" class="headerlink" title="HashMap详解-源码分析"></a>HashMap详解-源码分析</h1><h2 id="HashMap类声明"><a href="#HashMap类声明" class="headerlink" title="HashMap类声明"></a>HashMap类声明</h2><p>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable </span><br></pre></td></tr></table></figure><p>分析：</p><ul><li>继承了AbstractMap抽象类，而AbstractMap类已经实现了Map部分接口，可以直接使用</li><li>实现了Map、Cloneable、Serializable接口，即实现Map接口中的相应方法，支持clone，支持序列化及反序列化</li></ul><h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><p>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">362498820763181265L</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> modCount;</span><br><span class="line"></span><br><span class="line"> <span class="type">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>分析：</p><ul><li>serialVersionUID：序列化版本号</li><li>DEFAULT_INITIAL_CAPACITY：默认初始化的数组容量</li><li>MAXIMUM_CAPACITY：最大的容量，1&gt;&gt;30即为2的30次方</li><li>DEFAULT_LOAD_FACTOR：默认的扩容因子</li><li>TREEIFY_THRESHOLD：树化的阈值</li><li>UNTREEIFY_THRESHOLD：退化为链表的阈值</li><li>MIN_TREEIFY_CAPACITY： 树的最小容量</li><li>table：用于保存键值对元素的数组</li><li>entrySet：存放具体元素的集合</li><li>size：实际存储元素的个数</li><li>modCount：记录数组长度变化</li><li>threshold：临界值 当实际大小(容量*扩容因子)超过临界值时，会进行扩容</li><li>loadFactor：扩容因子</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的代理</title>
      <link href="/post/e63723a.html"/>
      <url>/post/e63723a.html</url>
      
        <content type="html"><![CDATA[<h3 id="Java中的代理"><a href="#Java中的代理" class="headerlink" title="Java中的代理"></a>Java中的代理</h3><pre><code>   代理模式（Proxy）是通过代理对象访问目标对象，这样可以在目标对象基础上增强额外的功能，如添加权限，访问控制和审计等功能。 </code></pre><ul><li>增加额外功能，进行增强</li><li>引入第三方代理类，进行解耦</li></ul><blockquote><ol><li><strong>静态代理</strong></li></ol></blockquote><p>请参考下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*声明一个明星接口，明星只需要关注自己的唱、跳</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StarService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sing</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">jump</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*明星接口的具体实现类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StarServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">StarService</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sing</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; sing a song &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">jump</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; just dance &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*代理类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StarServiceProxy</span> <span class="keyword">implements</span> <span class="title class_">StarService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StarService starService;</span><br><span class="line"><span class="comment">// 通过构造方法将目标实现类注入</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StarServiceProxy</span><span class="params">(StarService starService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.starService = starService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sing</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;唱歌之前先联系综艺节目，确定时间、地点&quot;</span>);</span><br><span class="line">        starService.sing();</span><br><span class="line">        System.out.println(<span class="string">&quot;表演结束之后，安排下一场演出&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">jump</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> starService.jump();</span><br><span class="line">        System.out.println(<span class="string">&quot;跳舞之后，观众鼓掌&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StarService</span> <span class="variable">starService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StarServiceImpl</span>();</span><br><span class="line">        <span class="type">StarServiceProxy</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StarServiceProxy</span>(starService);</span><br><span class="line">        proxy.sing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输出：</span><br><span class="line"> 唱歌之前先联系综艺节目，确定时间、地点</span><br><span class="line">  sing a song </span><br><span class="line"> 表演结束之后，安排下一场演出</span><br></pre></td></tr></table></figure><blockquote><p><strong>总结</strong>：</p><ul><li> 静态代理模式在不改变目标对象的前提下，实现了对目标对象的功能扩展；</li><li>不足： 静态代理<strong>实现了目标对象的所有方法</strong>，一旦目标接口增加方法，代理对象和目标对象都要进行相应的修改，增加维护成本。 </li></ul></blockquote><blockquote><ol start="2"><li><strong>动态代理</strong></li></ol></blockquote><p>Java中的动态代理需要<code>java.lang.reflect.InvocationHandler</code>接口和<code> java.lang.reflect.Proxy</code> 类的支持 。**<code>jdk</code>的动态代理是面向接口的，即<code>jdk</code>的动态代理只能代理实现接口的类，不能代理抽象类或者没有实现接口的类。**</p><p> <code>java.lang.reflect.InvocationHandler</code>接口的定义如下： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*Object proxy   被代理的对象  </span></span><br><span class="line"><span class="comment">*Method method  要调用的方法  </span></span><br><span class="line"><span class="comment">*Object[] args  方法调用时所需要参数  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InvocationHandler</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>java.lang.reflect.Proxy</code>类的定义如下： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*CLassLoader loader    类的加载器 </span></span><br><span class="line"><span class="comment">*Class&lt;?&gt; interfaces   得到全部的接口  </span></span><br><span class="line"><span class="comment">*InvocationHandler h   得到InvocationHandler接口的子类的实例</span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</span> <span class="keyword">throws</span> IllegalArgumentException  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>jdk</code>动态代理流程：</p><ol><li> 通过实现 <code>InvocationHandler </code>接口创建自己的调用处理器； </li><li> 通过为 Proxy 类指定<code> ClassLoader</code> 对象和一组<code>interface</code>来创建动态代理类； </li><li> 通过反射机制获得动态代理类的构造函数，其唯一参数类型是调用处理器接口类型； </li><li> 通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数被传入。 </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义中间代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YourHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="comment">// 目标对象  </span></span><br><span class="line">    <span class="keyword">private</span> Object targetObject;  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProxyHandler</span><span class="params">( Object proxied )</span> &#123;   </span><br><span class="line">    <span class="built_in">this</span>.proxied = proxied;   </span><br><span class="line">  &#125;  </span><br><span class="line">    </span><br><span class="line">     <span class="comment">/*proxy表示代理目标对象，method表示原对象被调用的方法，args表示方法的参数*/</span>  </span><br><span class="line">    <span class="meta">@Ovrride</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">( Object proxy, Method method, Object[] args )</span> <span class="keyword">throws</span> Throwable &#123;   </span><br><span class="line">    <span class="comment">//在转调具体目标对象之前，可以执行一些功能处理</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//转调具体目标对象的方法</span></span><br><span class="line">    <span class="keyword">return</span> method.invoke( proxy, args);  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在转调具体目标对象之后，可以执行一些功能处理</span></span><br><span class="line">  &#125;    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>实际应用时代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RealSubject  要代理的目标对象</span></span><br><span class="line"><span class="type">RealSubject</span> <span class="variable">real</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealSubject</span>(); </span><br><span class="line"><span class="comment">// Subject 目标对象实现的接口</span></span><br><span class="line">    <span class="type">Subject</span> <span class="variable">proxySubject</span> <span class="operator">=</span>   (Subject)Proxy.newProxyInstance(Subject.class.getClassLoader(), </span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Subject.class&#125;, </span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">YourHandler</span>(real));</span><br><span class="line"> <span class="comment">// proxySubject 为中间代理类        </span></span><br><span class="line">    proxySubject.method( Object[] args);</span><br></pre></td></tr></table></figure><blockquote><ol start="3"><li><strong><code>Cglib</code>代理</strong></li></ol></blockquote><p>​        Cglib代理补充了jdk中只面向接口进行代理的不足，Cglib代理支持基于对象代理，不用关心该对象是否实现了某个接口。 Cglib是一个java字节码的生成工具，它动态生成一个被代理类的子类，子类重写被代理的类的所有不是final的方法。在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。 </p><p>以上面的<code>StarServiceImpl</code>为被代理对象，举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  自定义中间代理类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMethodInterceptor</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">&quot;Before: &quot;</span>  + method.getName());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> methodProxy.invokeSuper(o, objects);</span><br><span class="line">        System.out.println(<span class="string">&quot;After: &quot;</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试如下</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">//继承被代理类</span></span><br><span class="line">        enhancer.setSuperclass(Star.class);</span><br><span class="line">        <span class="comment">//设置回调</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">MyMethodInterceptor</span>());</span><br><span class="line">        <span class="comment">//设置代理类对象</span></span><br><span class="line">        <span class="type">StarServiceImpl</span> <span class="variable">starService</span> <span class="operator">=</span> (StarServiceImpl) enhancer.create();</span><br><span class="line">        <span class="comment">//在调用代理类中方法时会被我们实现的方法拦截器进行拦截</span></span><br><span class="line">        starService.sing();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输出结果如下：</span><br><span class="line">    Before: sing</span><br><span class="line">sing a song</span><br><span class="line">After: sing</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 代理 </tag>
            
            <tag> 动态代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java知识点总结</title>
      <link href="/post/d842f132.html"/>
      <url>/post/d842f132.html</url>
      
        <content type="html"><![CDATA[<h2 id="Java知识点总结"><a href="#Java知识点总结" class="headerlink" title="Java知识点总结"></a>Java知识点总结</h2><h3 id="1-类的初始化顺序"><a href="#1-类的初始化顺序" class="headerlink" title="1.  类的初始化顺序"></a>1.  类的初始化顺序</h3><ol><li>父类静态变量（静态代码块）</li><li>子类静态变量（静态代码块）</li><li>父类成员变量</li><li>父类构造方法</li><li>子类成员变量</li><li>子类构造方法</li></ol><h3 id="2-final修饰符"><a href="#2-final修饰符" class="headerlink" title="2. final修饰符"></a>2. final修饰符</h3><ul><li><p>修饰变量， 必须显示地赋初值，且赋初值后不能再赋值</p><blockquote><p>被final修饰的实例变量必须显示地赋初值，且只能以下三种方式：</p><p>　　1.  定义时初始化</p><p>　　2.  在非静态初始化块中为final实例变量指定初始值</p><p>　　3.  在构造器中指定初始值</p><p>final修饰的静态变量只能在两个地方进行初始化</p><ol><li>定义final类变量时指定初始值 </li><li>在静态初始化块中为final类变量指定初始值 </li></ol></blockquote></li><li><p>修饰方法，该方法不能被重写</p></li><li><p>修饰类，该类不能被继承   </p></li></ul><h3 id="3-static修饰符"><a href="#3-static修饰符" class="headerlink" title="3.  static修饰符"></a>3.  static修饰符</h3><ul><li><p>修饰变量，被<code>static</code>修饰的变量实质上就是全局变量，<strong>所有的类实例（对象），共享该变量</strong>；且该变量可以以<code>类名.变量名</code>的方式进行访问</p></li><li><p>修饰方法，该方法被称为静态方法，可直接使用<code>类名.静态方法名</code>进行调用，不需要实例化对象。</p><blockquote><p>静态方法有以下特点：</p><ul><li>只能访问<code>static</code>变量</li><li>只能调用其他<code>static</code>方法</li><li>不能使用<code>this</code>或者<code>super</code>关键字，因为这两个关键字都是需要绑定对象</li></ul></blockquote></li><li><p><code>static</code>一般不能修饰类，只能修饰<strong>内部类</strong></p></li><li><p><code>import static com.*.ClassName.*</code>，静态导入所需要的静态变量，从<code>jdk5</code>开始。</p></li></ul><h3 id="4-private修饰构造方法"><a href="#4-private修饰构造方法" class="headerlink" title="4. private修饰构造方法"></a>4. private修饰构造方法</h3><ul><li><code>private</code>修饰的构造方法只能在本类里调用</li></ul><h3 id="5-重写和重载"><a href="#5-重写和重载" class="headerlink" title="5. 重写和重载"></a>5. 重写和重载</h3><ul><li>重写（覆写）：方法名相同，接收参数相同，返回结果相同，处理逻辑不同，发生在子类和父类之间。</li><li>重载（覆载）：方法名相同，接收参数不同，返回结果可以不同，发生在一个类中。</li></ul><h3 id="6-反射"><a href="#6-反射" class="headerlink" title="6. 反射"></a>6. 反射</h3><ul><li><code> java</code>反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为<code>java</code>语言的反射机制。</li></ul><h3 id="7-反射的应用场景"><a href="#7-反射的应用场景" class="headerlink" title="7.  反射的应用场景"></a>7.  反射的应用场景</h3><p>​        平时的业务开发中，很少用到反射，但是**反射是框架设计的灵魂 **，很多框架都用到了反射。</p><p>举例如下：</p><ul><li><p> 我们在使用<code>JDBC</code>连接数据库时使用<code>Class.forName()</code>通过反射加载数据库的驱动程序； </p></li><li><p> 动态代理；</p></li><li><p> Spring框架也用到很多反射机制，最经典的就是<code>xml</code>的配置模式；</p></li></ul><blockquote><p>Spring 通过 <code>xml</code>配置模式装载 Bean 的过程：</p><ul><li>将程序内所有 <code>xml</code>或 <code>properties</code>配置文件加载入内存中;  </li><li>Java类里面解析<code>xml</code>或<code>properties</code>里面的内容，得到对应实体类的字节码字符串以及相关的属性信息;  </li><li>使用反射机制，根据这个字符串获得某个类的Class实例; </li><li>动态配置实例的属性。 </li></ul></blockquote><h3 id="8-short、int类型提升"><a href="#8-short、int类型提升" class="headerlink" title="8.short、int类型提升"></a>8.<code>short</code>、<code>int</code>类型提升</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">a = a + <span class="number">1</span>; </span><br><span class="line"><span class="comment">/* 编译报错（原因：使用 + 运算符，会使得short类型自动提升为int类型，int类型的值范围大于short），所以可能</span></span><br><span class="line"><span class="comment"> * 会出现超出范围的报错，故编译不通过</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">a += <span class="number">1</span>; <span class="comment">//编译通过，java中对 += 做了特殊处理</span></span><br></pre></td></tr></table></figure><h3 id="9-String不变性"><a href="#9-String不变性" class="headerlink" title="9. String不变性"></a>9. <code>String</code>不变性</h3><ul><li>String类是被final进行修饰的，不能被继承；</li><li>使用<code>+</code>运算符连接两个字符串时，会创建一个新的字符串；<code>+</code>运算符底层采用了<code>StringBuilder</code>实例的<code>append()</code>方法实现；</li><li><code>String s = new String(&quot;hello world&quot;);</code>可能创建两个对象，也可能创建一个对象。如果在静态区中有<code>&quot;hello world&quot;</code>字符串常量对象的话，则仅仅在堆中创建一个对象。如果在静态区中没有<code>&quot;hello world&quot;</code>对象，则在堆和静态区中都需要创建对象；</li></ul><h3 id="10-为什么重写equals-方法时，一定要重写hashCode-方法"><a href="#10-为什么重写equals-方法时，一定要重写hashCode-方法" class="headerlink" title="10.  为什么重写equals()方法时，一定要重写hashCode()方法"></a>10.  为什么重写<code>equals()</code>方法时，一定要重写<code>hashCode()</code>方法</h3><ul><li><p>因为关于<code>hashCode()</code>方法，一致约定是 </p><blockquote><ol><li><strong>如果两个对象通过<code>equals</code>调用后返回是<code>true</code>，那么这个两个对象的<code>hashCode</code>方法也必须返回同样的int型散列码;</strong></li><li>**如果两个对象通过equals返回false，他们的hashCode返回的值<font color="red">允许相同</font>**。(然而，程序员必须意识到，<code>hashCode</code>返回独一无二的散列码，会让存储这个对象的<code>hashTables</code>更好地工作。)</li></ol></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么重写equals()方法时，要重写hashCode()方法</title>
      <link href="/post/300023f4.html"/>
      <url>/post/300023f4.html</url>
      
        <content type="html"><![CDATA[<h2 id="为什么重写equals-方法时，要重写hashCode-方法"><a href="#为什么重写equals-方法时，要重写hashCode-方法" class="headerlink" title="为什么重写equals()方法时，要重写hashCode()方法"></a>为什么重写equals()方法时，要重写hashCode()方法</h2><h3 id="1-Object类中equals-方法源代码如下所示："><a href="#1-Object类中equals-方法源代码如下所示：" class="headerlink" title="1. Object类中equals()方法源代码如下所示："></a>1. <code>Object</code>类中<code>equals()</code>方法源代码如下所示：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*Object类中的equals()方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p> 由以上源代码知，<code>Object</code>类中的<code>equals()</code>方法是直接使用<code>==</code>运算符来判断两个对象相等的。</p><ul><li>引用类型变量使用<code>==</code>时，比较的是引用类型变量指向的对象的内存地址</li><li>基本类型使用<code>==</code>时，比较值</li></ul></blockquote><p><code>Objcect</code>类中的<code>hashCode</code>源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns a hash code value for the object. This method is</span></span><br><span class="line"><span class="comment">    * supported for the benefit of hash tables such as those provided by</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> java.util.HashMap&#125;.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * The general contract of &#123;<span class="doctag">@code</span> hashCode&#125; is:</span></span><br><span class="line"><span class="comment">    * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">    * &lt;li&gt;Whenever it is invoked on the same object more than once during</span></span><br><span class="line"><span class="comment">    *     an execution of a Java application, the &#123;<span class="doctag">@code</span> hashCode&#125; method</span></span><br><span class="line"><span class="comment">    *     must consistently return the same integer, provided no information</span></span><br><span class="line"><span class="comment">    *     used in &#123;<span class="doctag">@code</span> equals&#125; comparisons on the object is modified.</span></span><br><span class="line"><span class="comment">    *     This integer need not remain consistent from one execution of an</span></span><br><span class="line"><span class="comment">    *     application to another execution of the same application.</span></span><br><span class="line"><span class="comment">    * &lt;li&gt;If two objects are equal according to the &#123;<span class="doctag">@code</span> equals(Object)&#125;</span></span><br><span class="line"><span class="comment">    *     method, then calling the &#123;<span class="doctag">@code</span> hashCode&#125; method on each of</span></span><br><span class="line"><span class="comment">    *     the two objects must produce the same integer result.</span></span><br><span class="line"><span class="comment">    * &lt;li&gt;It is &lt;em&gt;not&lt;/em&gt; required that if two objects are unequal</span></span><br><span class="line"><span class="comment">    *     according to the &#123;<span class="doctag">@link</span> java.lang.Object#equals(java.lang.Object)&#125;</span></span><br><span class="line"><span class="comment">    *     method, then calling the &#123;<span class="doctag">@code</span> hashCode&#125; method on each of the</span></span><br><span class="line"><span class="comment">    *     two objects must produce distinct integer results.  However, the</span></span><br><span class="line"><span class="comment">    *     programmer should be aware that producing distinct integer results</span></span><br><span class="line"><span class="comment">    *     for unequal objects may improve the performance of hash tables.</span></span><br><span class="line"><span class="comment">    * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * As much as is reasonably practical, the hashCode method defined by</span></span><br><span class="line"><span class="comment">    * class &#123;<span class="doctag">@code</span> Object&#125; does return distinct integers for distinct</span></span><br><span class="line"><span class="comment">    * objects. (This is typically implemented by converting the internal</span></span><br><span class="line"><span class="comment">    * address of the object into an integer, but this implementation</span></span><br><span class="line"><span class="comment">    * technique is not required by the</span></span><br><span class="line"><span class="comment">    * Java&amp;trade; programming language.)</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>  a hash code value for this object.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span>     java.lang.Object#equals(java.lang.Object)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span>     java.lang.System#identityHashCode</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;<span class="comment">// java8中的hashCode方法，</span></span><br></pre></td></tr></table></figure><blockquote><p>上面的注释中有说明如下几点：</p><ul><li>对象的<code>hashCode</code>值通常是根据对象的内存地址计算得来</li><li>两个对象<code>equals()</code>结果为<code>true</code>时，两个对象的<code>hashCode</code>值一定相等，不同对象的<code>hashCode</code>不等</li><li><code>native</code>标识此方法不是<code>java</code>语言实现</li></ul></blockquote><p><code>Object</code>类中的<code>toString()</code>方法源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 从这里就能看出打印对象时不重写toString()方法时，就会打印出对象的hashCode值</span></span><br><span class="line">        <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="2-String类中equals-方法和hashCode-方法"><a href="#2-String类中equals-方法和hashCode-方法" class="headerlink" title="2. String类中equals()方法和hashCode()方法"></a>2. <code>String</code>类中<code>equals()</code>方法和<code>hashCode()</code>方法</h3><blockquote><p><code>String</code>类中部分源代码如下所示：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line"><span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 无参构造方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.value = <span class="string">&quot;&quot;</span>.value;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 有参构造方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">(String original)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.value = original.value;</span><br><span class="line">      <span class="built_in">this</span>.hash = original.hash;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*String类重写的equals方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object anObject)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span> == anObject) &#123;<span class="comment">// 此处的this指向a.equals(b)的a对象，即谁调用指向谁</span></span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">          <span class="type">String</span> <span class="variable">anotherString</span> <span class="operator">=</span> (String)anObject;</span><br><span class="line">          <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> value.length;</span><br><span class="line">          <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">              <span class="type">char</span> v1[] = value;</span><br><span class="line">              <span class="type">char</span> v2[] = anotherString.value;</span><br><span class="line">              <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">              <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                  i++;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns a hash code for this string. The hash code for a</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@code</span> String&#125; object is computed as</span></span><br><span class="line"><span class="comment">   * &lt;blockquote&gt;&lt;pre&gt;</span></span><br><span class="line"><span class="comment">   * s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]</span></span><br><span class="line"><span class="comment">   * &lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment">   * using &#123;<span class="doctag">@code</span> int&#125; arithmetic, where &#123;<span class="doctag">@code</span> s[i]&#125; is the</span></span><br><span class="line"><span class="comment">   * &lt;i&gt;i&lt;/i&gt;th character of the string, &#123;<span class="doctag">@code</span> n&#125; is the length of</span></span><br><span class="line"><span class="comment">   * the string, and &#123;<span class="doctag">@code</span> ^&#125; indicates exponentiation.</span></span><br><span class="line"><span class="comment">   * (The hash value of the empty string is zero.)</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span>  a hash code value for this object.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> hash;</span><br><span class="line">      <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="type">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">              h = <span class="number">31</span> * h + val[i];</span><br><span class="line">          &#125;</span><br><span class="line">          hash = h;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> h;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从上面的源码中，我们不难发现<code>String</code>类已经重写了<code>equals()</code>方法和<code>hashCode()</code>方法。</p><p><code>String</code>类重写的<code>equals()</code>方法判断流程如下：</p><blockquote><ol><li>使用<code>==</code>来判断两个对象的内存地址是否相同，相同返回<code>true；</code></li><li>如果两个对象的内存地址不同，程序继续往下走，判断另一个对象是否是<code>String</code>类型的；</li><li>如果比较对象不是<code>String</code>类型，直接返回<code>false</code>；</li><li>如果是<code>String</code>类型的，进行类型强转；</li><li>比较两个<code>String</code>的字符数组长度，如果长度不同，返回<code>false</code>；</li><li>利用<code>while</code>循环来逐位比较字符是否相等，直到循环结束，所有字符都相等，则返回<code>true</code>，否则返回<code>false</code>;</li></ol></blockquote><p>下面来看一下重写的<code>hashCode()</code>方法。</p><blockquote><ol><li>首先<code>String</code>类中定义了一个<code>int</code>类型的变量<code>hash</code>用来缓存<code>String</code>对象的<code>hash</code>值；</li><li>如果当前调用<code>hashCode()</code>方法的<code>String</code>对象在常量池没有找到，并且该对象的<code>length</code>长度大于<code>0</code>,则继续往下走，否则返回<code>0</code>;即<code>String</code>类默认<code>&quot;&quot;</code>字符串的<code>hashCode()</code>值为<code>0</code>;</li><li>遍历字符数组，获取每一个字符的<code>ASCII</code>码表对应的值 和之前的<code>hash</code>值相加，这样就保证了相同的字符串的<code>hashCode()</code>返回值相同，计算公式在注释里已经写出来了：**<code>s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]</code>**</li><li>将计算出来的结果保存到<code>hash</code>变量中，并返回该值；</li></ol></blockquote><p>这里为什么要乘以<code>31</code>呢？原因是为了<strong>性能</strong>，不仅仅指降低了计算速度，也降低了哈希冲突的概率。</p><blockquote><p> 哈希冲突：此处指不同的字符串生成了相同的<code>hashCode</code>值。</p></blockquote><p><code>31</code>是一个<strong>奇素数</strong>。如果乘数是偶数，并且乘法溢出的话，信息就会丢失，因为与2相乘等价于移位运算（低位补<code>0</code>）。使用素数的好处并不很明显，但是习惯上使用素数来计算散列结果。 <strong><code>31</code> 有个很好的性能，即用移位和减法来代替乘法</strong>，可以得到更好的性能： <code>31 * i == (i &lt;&lt; 5）- i</code>， 现代的 <code>VM</code>  可以自动完成这种优化。这个公式可以很简单的推导出来。 —- 《<code>Effective Java</code>》 </p><blockquote><p>素数：质数又称素数，指在一个大于1的自然数中，除了1和此整数自身外，没法被其他自然数整除的数。 </p></blockquote><h3 id="说了这么多，为什么重写equals-方法要重写hashCode-方法呢？"><a href="#说了这么多，为什么重写equals-方法要重写hashCode-方法呢？" class="headerlink" title="说了这么多，为什么重写equals()方法要重写hashCode()方法呢？"></a>说了这么多，为什么重写equals()方法要重写hashCode()方法呢？</h3><p>原因如下：</p><ul><li><font color="red"><strong>避免两个对象不同时出现相同的hashCode值</strong></font></li><li><font color="red"><strong>避免重写过equals()方法的对象使用equals()判断为相等时，返回不同的hashCode值</strong></font></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>equals()方法和hashCode()方法详解</title>
      <link href="/post/e8d9b9d3.html"/>
      <url>/post/e8d9b9d3.html</url>
      
        <content type="html"><![CDATA[<h2 id="equals-方法和hashCode-方法详解"><a href="#equals-方法和hashCode-方法详解" class="headerlink" title="equals()方法和hashCode()方法详解"></a><code>equals()</code>方法和<code>hashCode()</code>方法详解</h2><h3 id="1-Object类中equals-方法源代码如下所示："><a href="#1-Object类中equals-方法源代码如下所示：" class="headerlink" title="1. Object类中equals()方法源代码如下所示："></a>1. <code>Object</code>类中<code>equals()</code>方法源代码如下所示：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*Object类中的equals()方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p> 由以上源代码知，<code>Object</code>类中的<code>equals()</code>方法是直接使用<code>==</code>运算符来判断两个对象相等的。</p><ul><li>引用类型变量使用<code>==</code>时，比较的是引用类型变量指向的对象的内存地址</li><li>基本类型使用<code>==</code>时，比较值</li></ul></blockquote><p><code>Objcect</code>类中的<code>hashCode</code>源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns a hash code value for the object. This method is</span></span><br><span class="line"><span class="comment">    * supported for the benefit of hash tables such as those provided by</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> java.util.HashMap&#125;.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * The general contract of &#123;<span class="doctag">@code</span> hashCode&#125; is:</span></span><br><span class="line"><span class="comment">    * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">    * &lt;li&gt;Whenever it is invoked on the same object more than once during</span></span><br><span class="line"><span class="comment">    *     an execution of a Java application, the &#123;<span class="doctag">@code</span> hashCode&#125; method</span></span><br><span class="line"><span class="comment">    *     must consistently return the same integer, provided no information</span></span><br><span class="line"><span class="comment">    *     used in &#123;<span class="doctag">@code</span> equals&#125; comparisons on the object is modified.</span></span><br><span class="line"><span class="comment">    *     This integer need not remain consistent from one execution of an</span></span><br><span class="line"><span class="comment">    *     application to another execution of the same application.</span></span><br><span class="line"><span class="comment">    * &lt;li&gt;If two objects are equal according to the &#123;<span class="doctag">@code</span> equals(Object)&#125;</span></span><br><span class="line"><span class="comment">    *     method, then calling the &#123;<span class="doctag">@code</span> hashCode&#125; method on each of</span></span><br><span class="line"><span class="comment">    *     the two objects must produce the same integer result.</span></span><br><span class="line"><span class="comment">    * &lt;li&gt;It is &lt;em&gt;not&lt;/em&gt; required that if two objects are unequal</span></span><br><span class="line"><span class="comment">    *     according to the &#123;<span class="doctag">@link</span> java.lang.Object#equals(java.lang.Object)&#125;</span></span><br><span class="line"><span class="comment">    *     method, then calling the &#123;<span class="doctag">@code</span> hashCode&#125; method on each of the</span></span><br><span class="line"><span class="comment">    *     two objects must produce distinct integer results.  However, the</span></span><br><span class="line"><span class="comment">    *     programmer should be aware that producing distinct integer results</span></span><br><span class="line"><span class="comment">    *     for unequal objects may improve the performance of hash tables.</span></span><br><span class="line"><span class="comment">    * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * As much as is reasonably practical, the hashCode method defined by</span></span><br><span class="line"><span class="comment">    * class &#123;<span class="doctag">@code</span> Object&#125; does return distinct integers for distinct</span></span><br><span class="line"><span class="comment">    * objects. (This is typically implemented by converting the internal</span></span><br><span class="line"><span class="comment">    * address of the object into an integer, but this implementation</span></span><br><span class="line"><span class="comment">    * technique is not required by the</span></span><br><span class="line"><span class="comment">    * Java&amp;trade; programming language.)</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>  a hash code value for this object.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span>     java.lang.Object#equals(java.lang.Object)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span>     java.lang.System#identityHashCode</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;<span class="comment">// java8中的hashCode方法，</span></span><br></pre></td></tr></table></figure><blockquote><p>上面的注释中有说明如下几点：</p><ul><li>对象的<code>hashCode</code>值通常是根据对象的内存地址计算得来</li><li>两个对象<code>equals()</code>结果为<code>true</code>时，两个对象的<code>hashCode</code>值一定相等，不同对象的<code>hashCode</code>不等</li><li><code>native</code>标识此方法不是<code>java</code>语言实现</li></ul></blockquote><p><code>Object</code>类中的<code>toString()</code>方法源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 从这里就能看出打印对象时不重写toString()方法时，就会打印出对象的hashCode值</span></span><br><span class="line">        <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="2-String类中equals-方法和hashCode-方法"><a href="#2-String类中equals-方法和hashCode-方法" class="headerlink" title="2. String类中equals()方法和hashCode()方法"></a>2. <code>String</code>类中<code>equals()</code>方法和<code>hashCode()</code>方法</h3><blockquote><p><code>String</code>类中部分源代码如下所示：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line"><span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 无参构造方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.value = <span class="string">&quot;&quot;</span>.value;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 有参构造方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">(String original)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.value = original.value;</span><br><span class="line">      <span class="built_in">this</span>.hash = original.hash;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*String类重写的equals方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object anObject)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span> == anObject) &#123;<span class="comment">// 此处的this指向a.equals(b)的a对象，即谁调用指向谁</span></span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">          <span class="type">String</span> <span class="variable">anotherString</span> <span class="operator">=</span> (String)anObject;</span><br><span class="line">          <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> value.length;</span><br><span class="line">          <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">              <span class="type">char</span> v1[] = value;</span><br><span class="line">              <span class="type">char</span> v2[] = anotherString.value;</span><br><span class="line">              <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">              <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                  i++;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns a hash code for this string. The hash code for a</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@code</span> String&#125; object is computed as</span></span><br><span class="line"><span class="comment">   * &lt;blockquote&gt;&lt;pre&gt;</span></span><br><span class="line"><span class="comment">   * s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]</span></span><br><span class="line"><span class="comment">   * &lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment">   * using &#123;<span class="doctag">@code</span> int&#125; arithmetic, where &#123;<span class="doctag">@code</span> s[i]&#125; is the</span></span><br><span class="line"><span class="comment">   * &lt;i&gt;i&lt;/i&gt;th character of the string, &#123;<span class="doctag">@code</span> n&#125; is the length of</span></span><br><span class="line"><span class="comment">   * the string, and &#123;<span class="doctag">@code</span> ^&#125; indicates exponentiation.</span></span><br><span class="line"><span class="comment">   * (The hash value of the empty string is zero.)</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span>  a hash code value for this object.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> hash;</span><br><span class="line">      <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="type">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">              h = <span class="number">31</span> * h + val[i];</span><br><span class="line">          &#125;</span><br><span class="line">          hash = h;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> h;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从上面的源码中，我们不难发现<code>String</code>类已经重写了<code>equals()</code>方法和<code>hashCode()</code>方法。</p><p><code>String</code>类重写的<code>equals()</code>方法判断流程如下：</p><blockquote><ol><li>使用<code>==</code>来判断两个对象的内存地址是否相同，相同返回<code>true；</code></li><li>如果两个对象的内存地址不同，程序继续往下走，判断另一个对象是否是<code>String</code>类型的；</li><li>如果比较对象不是<code>String</code>类型，直接返回<code>false</code>；</li><li>如果是<code>String</code>类型的，进行类型强转；</li><li>比较两个<code>String</code>的字符数组长度，如果长度不同，返回<code>false</code>；</li><li>利用<code>while</code>循环来逐位比较字符是否相等，直到循环结束，所有字符都相等，则返回<code>true</code>，否则返回<code>false</code>;</li></ol></blockquote><p>下面来看一下重写的<code>hashCode()</code>方法。</p><blockquote><ol><li>首先<code>String</code>类中定义了一个<code>int</code>类型的变量<code>hash</code>用来缓存<code>String</code>对象的<code>hash</code>值；</li><li>如果当前调用<code>hashCode()</code>方法的<code>String</code>对象在常量池没有找到，并且该对象的<code>length</code>长度大于<code>0</code>,则继续往下走，否则返回<code>0</code>;即<code>String</code>类默认<code>&quot;&quot;</code>字符串的<code>hashCode()</code>值为<code>0</code>;</li><li>遍历字符数组，获取每一个字符的<code>ASCII</code>码表对应的值 和之前的<code>hash</code>值相加，这样就保证了相同的字符串的<code>hashCode()</code>返回值相同，计算公式在注释里已经写出来了：**<code>s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]</code>**</li><li>将计算出来的结果保存到<code>hash</code>变量中，并返回该值；</li></ol></blockquote><p>这里为什么要乘以<code>31</code>呢？原因是为了<strong>性能</strong>，不仅仅指降低了计算速度，也降低了哈希冲突的概率。</p><blockquote><p> 哈希冲突：此处指不同的字符串生成了相同的<code>hashCode</code>值。</p></blockquote><p><code>31</code>是一个<strong>奇素数</strong>。如果乘数是偶数，并且乘法溢出的话，信息就会丢失，因为与2相乘等价于移位运算（低位补<code>0</code>）。使用素数的好处并不很明显，但是习惯上使用素数来计算散列结果。 <strong><code>31</code> 有个很好的性能，即用移位和减法来代替乘法</strong>，可以得到更好的性能： <code>31 * i == (i &lt;&lt; 5）- i</code>， 现代的 <code>VM</code>  可以自动完成这种优化。这个公式可以很简单的推导出来。 —- 《<code>Effective Java</code>》 </p><blockquote><p>素数：质数又称素数，指在一个大于1的自然数中，除了1和此整数自身外，没法被其他自然数整除的数。 </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/post/4a17b156.html"/>
      <url>/post/4a17b156.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue项目中实现回车登录</title>
      <link href="/post/8184ba83.html"/>
      <url>/post/8184ba83.html</url>
      
        <content type="html"><![CDATA[<h3 id="Vue项目中实现回车登录"><a href="#Vue项目中实现回车登录" class="headerlink" title="Vue项目中实现回车登录"></a>Vue项目中实现回车登录</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">created</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">let</span> that = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">onkeypress</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> keycode = <span class="variable language_">document</span>.<span class="property">all</span> ? event.<span class="property">keyCode</span> : e.<span class="property">which</span>;</span><br><span class="line">      <span class="keyword">if</span> (keycode == <span class="number">13</span>) &#123;<span class="comment">// 回车键对应值为13</span></span><br><span class="line">        that.<span class="title function_">login</span>();<span class="comment">// 登录方法名</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>The literal 10000000000 of type int is out of range</title>
      <link href="/post/b2df998f.html"/>
      <url>/post/b2df998f.html</url>
      
        <content type="html"><![CDATA[<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAkwAAABxCAIAAACofWvOAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAEXRFWHRTb2Z0d2FyZQBTbmlwYXN0ZV0Xzt0AACAASURBVHic7Z19VBRnlvBvKXGifOyMGiQgtoYuIw7vcfJGMHZz/EAHpxtPFjMMTtjDMpqlOzGu3ZkNOYnfUcK4y5zYnUSTrrhxGN4hI3Ejb07ojozBkENXMmDOjO/hFWMVkVZBJWpmAT8mKrV/VFV39Rf9VdDQ3N/xeOinb926z1PVdeve5z5VBMdxgCAIgiCxyKRoG4AgCIIgIwU6OQRBECRmQSeHIAiCxCzo5BAEQZCYBZ0cgiAIErOgk0MQBEFiFnRyCIIgSMyCTg5BEASJWdDJIUiUsenVajMbbStGD5uecENvC0dkfMKa1Wq9Tb6DzZr1ajVBEAQxoU6hkIiyk7tmrthNFO8mKj4f7gD1fq4u3k1I/unb/cqyDUfVxbuJiqPmXvnNHeOMx76HZnP70YAnwCjAmvVqgiDUejkuKza9WkvRtLEs+tcoWfuFeMPa9KSRpiktKY9HYs1q0kjRtAyqYplYi+SuNdo7aABwdNS3XYu2McC2f66vOBjAhcumZ2z1PTjGo81sYz1FAwBN1TdGemDNai1FA4DOajcoPb+0Oe/SCYIg1Gq92UcIIEjJcNWUsV9BobNyPBaN13cai/CdVTcKlowWSo2FMakAAGgjGXlwaqs20gAAOivDcZz3CYTwjAsnl7rMXr+bq9/NVWQFEp1ZoM5SAYAiqzhn5iiYNizXGuubKUffaOkZU30PkvFos7KgWKcCAJWuuCCi6wprLjPSAKAyMV7XeZteTWrd7tJpmjJqveI9trFSrnt52fqF+EdpsAt+jtJG6ObYcx0AACpThQYP13DERdsAuVEWFtkLi6JtRXQYj30flzYbLHaDJVItLhdX43UPbtPzAZ5KZ62xCJcwlrU1VjdEutfhkKdfSACUhhpTPWmkgdLqC32FsaGRNR9d3PCE6eSumSveMjpAVbK5Ju1MdX0z5QAAUOXmbS9apkl1kwFFHlO9TDgO7UeJ6g4A0FXstmS7q+zt1O8/4ktPcIianfjYhWtHJ52BUTj7AoDeTvPRk/WtfcIttCJZV1xckT2T76btjd3aVomwo5ksbhb+lo4GANv+eXV9hytKUyTr1CsrCjND0zNafRftybLWF2mGb/ceH0m/QrH5mq3hs0p7B+0I1khPm/WEllKZrNvPVGopGkBlstoLzunLjPwHxpXkYW3m6sp6V1SkUumKt1cYJHfJNj2hpdxstnpco1izmjTSoDIxNfMbqyuNFK9M6qucyqr9ujjxHh1UxZKbdKVSY3DtzdMW2kgSRtFySbcEOZ2Vs5BmodsAKp2pxuLcr4z9Ym1m19fDqhwVLtiP1x7+qonpET6Tafl5BaUli+Y4JeyHl289BbC4qmVDet3hPZZTDABAWr5+47aSFImi03W1jZamHvBkcVXLBrVEprmph3Hua8PGUnXKHK9tQGnYrjNqKQCqwWbRjP6wTDAii+Roez0pSaPRrc3a1j6PK2BwdJQZ+5y/jAj0BIBtOEjWueX96NZmLTzEbckMQUvv52pjs9vv2NFHVb8F/lyLP9qPku4XenD0UY4jlN3NEcpF5H3XLM2C1g6AjsqGFZpCZ3axs4H3xLk/Fj2cr/EJo1/eesKENmq1rj+dzgBoY5m5gPcHNj3pfqEHmqZoLVUv9YNB76++jJSmEGlKW7bQXY+tgQIAUPnMDCrnZwHQALSxTD+/pkKjjPxkOGdWa42uXxhlJGF+yG4nQL8EVzhmsB8u3XrKrYXpaWKopuYnaw+t8fA9jrqqrRanD+tpsuwFxYFtvPu6cPxfSj9iht+XtwzT07R1L1SJStzRVJhUlJFGLzcaRDgn5+gDyLKadnP1u5kSfsKso7Ih9AoCRx8doZ7sIi7gvF3v52X8VV4h7Iur381U5Ol83GsNB9vWQQMAJJtEJZxpszU3eaEooNnCt282KQAAQJHH1IuS7ld5VW6e1bRZ+Kp+sykXAAAcHY29oegZtb5nr+Atoe1nXFND7f+f4kejiHeWnXrBMznHZ7M1NxkAwNFc5jymgW2+Zt4v6NFVbA7cwQCoTAwnTIZIP9BnnBcmlc5kZRih3oFjTHzFAy0pwgi+GoLmw0RekVBpUC2dgRFjNT+5Jk2FYCpNaUnSV9GJaIvYJ2FvHOe7BIEyGmkVX6DACNZTDTYPXRH2y70OguMYq2CbzuqzuGQUIPOfrKrd0dJyoKXlQEvLDn0+AAAwX7Ve8BA8ZbH0kPm62pYDLbU6Xqrps9P8d/Za3nstrqo90NJyoKVWpycBACBf1yKGcRdav+JDQD0v03KgpXZHVX7aPH+WKQuK+Zm5hjAn5lgxFbCQDE/BxCHSwpMsa30Rn+9SFopXwAvfRk/PcNiOihffF4qcOTpl9jJLYShhnIu++qOf2/jC99SZmi2bDCGFcQCQXWTfskyT6gyJZhqW8hfxvjPeeZHIkKnvMwvUvLsS3DAA2L7oAABQZBXwagWfB7qKTQZhRzM1W1YKLkPqHYen90w9n7suKbZkR1yTottuUPIBkp8MocZitxgkIZPSUCiYfCbAPbxPXBlDYaceMGf4tKG/K5TSYGesOpX4kaYpo5aMqLhfZ7XzmUUluZDX23EudGWB+iWtg1BqhAt5ODuSA/WGQ9vWqOc4s44pJSsWAwBAz/mLXsL5ukPbFs0BgDmz5vEH5fwVqSsk9Ro1f0c4Z1FuXpq3AK+5ufa4nW+dk6LetrXEVxgHAP7HLzCsWU0QBKml+LQzFlUGIsLCE0Wyjx/pxW9ZyAxt5OXSMxzXzvFntvNyHC7KwpU6+xHKwadVmwFApcja/sIKibsKFra3s1E6dzVSyNr3uiMU9NW3XTMUznTmKnXFQmTJ9vAZ0eSFadLtMgtzgWr11DYcPfyYJMtSdenmTPxETyxra3SblItkf0HWJw5XNKDUWOycxc0qmjKSHRBG/hRAV+gMpZQGO2cIWQEABNUv2lhtK7BolACsrbGeBohmacSFC6dbpfNk/slfsUj8M6Xk0IESLwHGYrPnblDPAbhwurW5BwBgnmu+bU5JQX4z1cQA0/TR1qaPAIAkF2/YqZG4WD90nGMBqyNHlHGxhGDMkWmp3sxU5OkUyfxn2tGhNb5FvNEZkha24SBpPGIccQ8nL5mFuQDOmEyI27IKQ41iAyE6y1GCNatJj5L90SBwjKNUagwWu92ZZHTLn44txBwrpSUJgiAIUiuU1lREZ9LpQl1VaSllCcLDDY+69EkSAODU1tLnly9/fnkpZWEAIE1fukgitWjboR21VU/mk8LNHcOc2lq6d/lrpwNoD/0OQGmwi/l0mhoLDxEY68jo5MT8EqQ/5O+wBXXlCkJPWMycnw4Abqm2SLQps5dZqjfxM1tCWqn1ZCiPGumsFibJ8pyTZBHMOQ2PnH3XFOWpRFV8rlJVssIVJqTxjt8j4yoWpwR9TH3qGTHPJ04nqUxW59TWiC5DFlKGwedClZrCsb4smuUDN5XKmWVVqXTWsOJOOThdyxeSkE9WOefJqhaHoUiYbyPTnNkAklxcVbu1xHM+O2WOes22Q1tbWg7UVj0pCDc11nnlNAHANSsbLkpDheesMuIbuZxcb6dYJgC6pfw0j8eF9ZrNq7ovOD2yoRFnvIz7j9rEaz3b/rm+IbQIzPbGQX1DJytqUGYvLFb4FBzWtfR+K5zk6Q+RqaIl9T5PfBlclFx9BwBI5fvbV9/2eUMreGYUs38s1DVUHxRd/jXbG0eEibrgj6lTTz3/nJfgzp/wcF5wsuaTSgD+MSKV1HCbRIg4I+O77oA169V6s41lnTfprM0s2OORMRQVRT/AE31ccU2NWL9jt3sunBg9Llw5z/8xLyV9DgDABfvx1w6fGm4T31zhk5Nk3sadYg3LoUMb1O4ezv5a1Wt1py+I/myOelHe8PUgwmhJ08jICBHhnJx05RYAAKhKNjvL6MWK8z6jcbdQta1IBp9P7hhWj+dyMQCqerdQ0WfiqxvENXk+ZEBVstnO17tnF1lzO7StAI4OrVHiTnLXh7gCto+qO0LVebaqclca3Ge8fI2AWEafurBY0Uw7AFqPkIEmq4bTM9p9B4CZhuIsY3UHXddMg/c8X6alIouqdreWNyZ3vXhMg7E5s6Ikmarrc18d6Of8iRBlQbHKSNMAlJb069p8FMhTWkKwOeSFBppCHVD+V0p10BSlpYxe7d5FM6IiyUK50KyRt19AG0nSzW6VzuS+3HB0mLMoj/yIYQCaqNImGfQxlr2lbj+VtHy9dMldT5OFavL6LZH5BV4BHwD6uFFFvnSlSpFlqhAvqTzZRUxFlpi7SFblrmeqV7rnXGYWqLN0imSVpEmlyLKa3PXIh2bLbulcGkCyKjfPWhRayKjZstlakqWSRG9C370XnPEj4CfOM1RvNuW6W2Ja7zsnNZye4M2Woe+iPT922uksOZF8W8SZ1kt25H98hkVZuIkpGf78kQulwc6YdNI0m8nKjOxjE50zWJXekypKQ43VpJPk/USTfLkcjYWx6qSiUUJpqDH5soKmjFoZHtQYMiklh3bo853lT2lk/pNV4vKA0PTsfNJXVNbTZKFKxSk39bYdVfrFpESOJBfrq3Yc2rbIx6auh91EabpygsGFxbemF3fBL3bBiy1MYGEEQXwgelHpGrdxi68Fe35ahX47H9A8HKHIjgiOT55ZtmnZsk3P/OGypPXyH57ZtGzZpmXPfOIIWaNzuWaEnRL0xMTZM6JgdSWCRAnxmfS0kZTzFWNRQcy/gbR0yrmIYPwirvIG6bLuC/bTzWGWe/Bv2wEA0FkjXCAvTMfSxurxfvKMMOjkECRqKA12PlShtGXj+72g4hM8gDKSzrcDCYsIfC+/B0obxEtTtSNZ/hMEc3If53OQTZa9y5c/z/8r3fqR8HyTnZ6PBxsW1vnwOJ3V+8UTIeO+ZgNfmuoPdHIIEk00Fs6qU6lMNdF58JVsKA12xnMiUZhJHNevOpuz5lCtTp+fJp1vAzItX6+rbfFeRTA8/PvkVDorI0/VqTCVHP352LENwXFctG1AEARBkBEh7uoAOjkEmaAsSpsMAKd77kfbEAQZKTBdiSAIgsQs6OQQBEGQmAWdHIIgCBKzoJNDEARBYpYIn105duj9avULbW2Shg0vPmeW+/0vCIIgyLgCIzlkhOjqbnp2bdKklKRJKavN3b4kupvMFasnpfAySeq1Bpu3GMpELoMgExniSv9QtG2Ql/Y/Jf2WBYzkokhX88Hq11+mXK81ydn/5QnDXHehZoO65PAXXtvq6vrfyUMZ+WSGB5cQIDEPRnKIzHQf/OcS3sPlLPX3jsrug8LVefGGxi/7h670D325bykAAFAlBhvKyCWDIMhEc3K95w++eWT1+reT+H8vHTE0nO9yff3dwZfeTlr/9uqG77ravzK85BT7U1OvDz1JTj2uf38K+t1V1z8o37N2xZ4t71+/ZG99vXzP2hV71q7Ys7b8wy8vesqsLW+95Gyzf8hLvm4HAPiyas/aFe98YP/6dVHyS7j+QdU7a1fsWbvinQ8ueu93pJm7aXtpjm7PUebKid8/meNTpKvpwy8AAHL2v2XWzBW2stdtAACAw5VUF8rIIiMdcvPapEkpSWrPdgSJdWKm8CQYvIpTwHHjsOOTw3TOX/7j8QxJcxvd9JjjhkSMLTJNd8l464mAb5o/eJaRvAiU6ajck/zOu7mzQ9DRV7PtiLh5c+WKZlf7ntalwapqNkwqOezzm6V7/mLXZfj8yiea6hP8cxj9XFC7Pv6oDQBg8VNr54pt3U3Pvi7s/QumCwBQJmIZ1yHrovQvnAIA+GLnGzadeXw/JRNBQmICRXLnDYJnmr5v/3P9R57rP/LLo7nTAQAcbfqG79xkHTecYn95WpB5o134sum/eD3Ko7ye/T/bx7/ONPdn/Ud+GvJbGZk+gOSy2p0ff7bzHX0yAADTXG8PVUtyWa24OcAj+uc/rs17BACYvkvDbhYVujr56bpMZQaIpRNPFLnm8DrZLpSRQQZBkInk5NpZ/iZ3w4vrN6XyTT/K/9ccPr3TRn/jfk2Yvm+/IJaRNt2nvpynF+fzelLnrVFNBwC4eCOsC0tyWe2zv0gHAJg9JzmQsB/yV/4iXdyczHvp6Rmhq8gzD13p9/kvpDAuFFgbZVA/UfRCbRtAjq7u6H4fc3goE7kMZOgsfPvSPVswjEMmFhMmXdnVw6cfpz+aJm2eV5ALh1u9pBXKNakBFLa9f6op56f5qQC954/TNwAA0qeH4wzIrKXpYWzmxiPzZro+zHsolFRnFKl9uQAAAJaWHv19dX4GdJlfR5kRkAEAyDB83G/w+Q2CxDYTJ5KTj/yf5+QAALBFL7ydtP7tpBc+edkBANP3/XxegC3HNM0G53Irj39yVytkZIrRxtLSfY1f9tur8zMA3NOYKBO5DIIgE8jJiVnHG1/3SJvPN/JhXChBWFcb2wYAiunO0sEchfLofmcWdGS5dKEvsNDYJmN+Jv9HTvHzm4TKQABobuTfAq3T5KOMHDIIgkwgJwfZSqG6+rdHDgrrAb5revMTYaLuieCDsO/45GSOKt+y/5f9R57rP/Lcif/4af6IeLgZ6bxdTMcXFwHg+pfvv/OsZYSc3CjOyWme51d0tb2wWXhCR1fzQbVQ27nhH/NQRh4ZCU3CEoKKg1iQgkwsYuWJJ01vvl3kPbUGIC0hcT4MxYOc3J+d+FfemXx38KU/vuwAUEgWFXg+QkWU8drRhqdzthTOC9ofXP+g/EANA0DmuRYM2D9cu60DAPJe2/lrtVuLCzIZmD6nzJdVeyqb4BH98288PUMQzl//8dZH4WLrltLmbyBr+2dPPRGsSfLQ9GxKEeX7K9ejT7qo1eRO72UYbs9GQZnIZQQk60PcFoTgE0+QmGfiRHIAkP3T/v0/26BwVUvmKJT7Xvyl6OGC5EebjDm+1jjfOPz+J4+9eT5SIz1QP/XOa1mPCB+SH8lf/867K4N8ZNOYJkN3gqnbp1vsSvkuLT3KuF+dUSZyGYG8Lc6qS36ZHYJMFGIlkhs9xJXgOU//8kThj8RWXyEggowhug+qn3j5C4zkkInGhIrk5ECoOgH4sbSx/ZsPfSQwJyyzkvbg32Pkb4Eu24GX+ceAFefjTRgykUAnFyIZOUo+O3T4/T86H1n52G/FZ6kYMYyblbTnav9O/jqLf0f3bwDoPqhOSZqU8lhBLQDA0j0WH8lMBIlhMF0ZBr3nD/5X24cXb7Q5ozfF9A2qkKpOYhX+Cot/j52/hSxlztLSp7ZLFxvwYLoSiXnQySHIxAWdHBLzEBzHRdsGBEEQBBkRcE4OQRAEiVnQySEIgiAxCzo5BEEQJGYJ38mxZjVBEARBqPVmH8/KQhAEQZBoI8P75GjKSFJnrJwF38aIlJeXR9sEBEHC4d133422CSNC+E5OabBzBmBtelJLAVANNosGvRwC8O67O6JtAoIgoVFevjfaJowUkc7JKTUVJhUAQMc5zFkiCIIgY4vIC0+U87NksANBEARBZEeGOTkECYIHAOIBpgDEAQwB3AEYBLgXbasQBIlxZHNy9BkGQCmXNiS2SPr+6i1ml+HO+fP3/36bmBwXvyBTWfnvU340FWAg2rYhCAIAMDAwEBcXFxcXN3nyZL5yPtoWyYMM6+TIhSoAAKoBVxIgvph+5ajt//1T8eQpU+LT0mZk/SQhNf37q5dP/3ztjZOnAOIDbX5STzwV+ql1Uk+8YgMA9j11OJsHUov4pdusVhCEQj8KwxTewZX5lAibURyo4Lh8+fL169dv3759/35MPctUBienNNSYdCoAykgSBEGMnWOGjAEevHPx+oW3TNOzlz762zfSNxkfiE/84aL//b8O/zE5v6Brz47vb9wHmMyL2vQKgnD/pz8ZXetD4aSeUKjN3R4tBKEg3C6p47oxMKz518as33GcA1cUDc8YHCiGYS5dutTf33/37t1YeqYxPvEEGVESma0vTklIjBvivvvo/8Yvzn5w/qMPbdj4/aWLxH/3T3rwwW/2vuoM5jQWB8c5OO53Oiixcg6Oc3CWlZHuX7nRzn1oUAJ/4zwyd2D8LXkT6Dwaf9VhauE4B2d91Ejy8d+4bgwK5sxXqoXzfA6R/IPvOrg+8bPTAFuFR8gd9DNQ0YSP5G7duoWRnCesucxI0QA6K8NxHK4JR6Q8ePvihWkPpwHAYHvbve9uJG94Zuj27Wt1f4ChoWkzU26e+xrgB9E2MkLmGuwOjvtNobSNba6nS7bzLyjV6E2qugbbOG9EYp2bN2/euXPn3r17HMdhJOcGc4YGANAVarDuBPGEAI67d+3m4Lnum10X79+6fffate4drw50fD14rvve324N3RoEeCCwmsZXvBKYznyaR5LQHfY9NfGKDU7qieVGGiitglC/x/renL8ZP6knRBn2PbUoE3IUwjC0Ll+835s7Pws6znWP70ZPXANIiPOUNr1CSwFtXE64zVxKB/8VvVpyvGyvEOr3WOnIe472sEdZOLggTNyaX5FIeh9x762ANT/l0YWAfZRu7v/sCm+gILiT0LuzHjt6ymx+RWJJcL8UgKGhoRhzbzyypStVC0m5VCExxH0i7gGOuBeXED+74t9+kJZGTPkBDN2fPPXByVMf5OA+TJoMEPBH9ZXxTD7HOThml4p608wCwEk98eZChk9vthTXLw/khFZauBaTCnRWB2ffqPS/OaVtKuR4mW5zNdTwWVNrCaUNrd6EPfd1jDW6c1JPiPlMzsFZQUu8YgPQWBxWHahMLRz3G0lCRzr4v7FsL6Hrm/nrr62hTrd9I39vLIy822iHdJRdJwkYf21mPY64L9j3yoyPColxN4OH66MvhtlXSAMlEMRJ6NFZYUdg5fvyOtTXSQwI6ZcSg+CcHDKifP+DlFn3h/7+sP5fEh5b9F3DsbikxOTip6amp0xNT7l3/1Z8hhLg74GUPG6qWAkAoMwrVgEAgK2Jgq+MJH9/utxI+ww1/ON/c53VedGZa7BsBP5OX1vnT5M/lPMfjbFGN2xNlGpXDZ/PhBBTmpp8Hf1xIwsAJxuokkJxuF0j79QW2lH2OkkCopyXBXVaf5U1kfQxMiVBnIS+fhGqXRUacavtJS4DIvmlxATo5JAR5WbGjsrvb9+CH/7Dt7W/H/jC/jdb4w81BT8sWHur78r927eVe/cBDIajWLWLEe7BHRznsDuvI3Jtzr6nJhRl8LoQQYZhYcd58eLZfa4DsubPHfeNw/F40KmclRUmqG/sZs1vUq6kqB8iPMqBLLHwcU9ZkEWkwfdRJiWRn4Qw0mM4DojcybHnOmSwA4lRbsUvmJv6T786a3zu8kcf3rnx7d8+O3lh394b7V/c+vbyHOO/TZmVCPB9yFo1+Tr61WrxjtimD3HtWjCbMwwt3oOzjR/TIVuoN4G4C5vFCLsqNOO80WsAy1xTaxYjrC0IekpeWbAW6i3V9SCEIwAAQDUIs62s+ddGuqRQE/FRDgj7ntkGAHMN9haT6qszjPu3w/Xxa/5JvYFPjMgGKoST0G2sus2Vdb7aR2AMxwORPvGEtVUbaQCArPlYdoL45HrqPz/9DzlL2Fe3/o05CxxHPDDlwdnpWf/5f6bMige4EZbOlRZml5pU8I9k0FkdlsCbzC0oftyoVVCqXYx9Y+DNNXpT5XKSeBUAVLqS0G+i5xpqnLsosXL8VM24bpSy0sL9Tk8sJ4z8R58ybqMhHXylcuP2LIW2Yxcj2UYHTQTxK1Ebn68L4yj736n398qN86sVhJbX/jvOM6j000flxhrTxySpMLqdGP72FepAuRPCSSgdq8dNphKo924PYwxjASLsWhrWrCaN4r2FysTY5V55goxDysvL/bxqJx4gEWAKAADcB/geYADgzqgah4wZbHpF5cIWMXXWbVYvP7N9DC2LHvfYXiEqSd+u3Q/l5XsXLlyYnp6emZmZnp4eHx8/efLkEbRwFJFhTk6lQw+HBOQmwBWACwA9AD0A36KHm7iw71VS4jo8RB66zWpnKvKkXlunKs7DazJPpC9NRZAQiamHKSChwi8R01kdGLbJylxDDakmFHzyVWVqmYAFJv7AV+0gCDJ6aCwOznNeaK7B7oiKMTGFcqOd2xhtI8YiuIQAQRAEiVnQySEIgiAxC6YrEZmpqRlH78dBECTGQSeHyExZWVm0TUAQJDRaW1ujbcJIgU4OkZ0L0TYAQRBEAOfkEARBkJgFnRyCIAgSs6CTQxAEQWIWdHIIgiDR4mr7sePHjp3uHY2tJihYeIIgSGwzePZTe2e/8CEpU71qQYJMmq+2H7uStm5RKlxtP/bXS2Lr7CVrslNh4Kz9ROcgAMDsn6zLniURdjFwlu3PVK8L0Z7wtpqwoJNDECTmSchcrV6QCABX24/Z25PWZKcG3CTsXfBc7YFF69YlAFxtP/bX9jTfexwYGIREH+3DE95WExZ0cgiCTBxmpc2Gzv5BSLz66YnBpNlXLl1KWbJuUWrv6WN/vgIAkKRcvSojURL8zV6yJjvV46NTW3zi7AQ/7mbWggWiTBIM+BLubT/+50sAYD/Wo1y9KiNxoOvTEywfcAp7GehyMzLIrQBAElkmZapXpV399MRgpqDBGVC6dSqSMR3joJNDEGTicLXnUkLa6gSAqwBXIG3NumyAga5POxNWr1uTCDBw1t52dtaqpK7OpJ+sWzVL2KjX/aOLhAXZgXKGA1d7+lMyU30Ip2avWQLHOxPVqxYkwEDXpyeupK1esyqR9232s6vVCwBcRga/VeLV9mN/hSVr1qW6bPBhmHunqIAjN25BJ4cgSMwz2HnieCcAAMxesmZBIsAAAKSkpQIADPRc6e8fPHGMFWRn34S0hKRLfz3Wz0d1AInuHwPsQpK37D197M+wxH0ezjcDg/2zlav4rRIzMmezPQMAiS4jQ9hq4MqlJOXqgLsMqlOxADo5BEFiHo8JMy+E2hAns1aty4De08eOHZ+9ZE12aob7x6B2pGo98QAAAjdJREFUMXDWfmJAuW6dd/w3Nkh061S0rRlBcAkBgiATmsS0lKRL7NkBAADo7To7ANB7tRcAUhetzkzo7x/0/BgMA11tPSmrs4P2cIkJLhsGujovJSQGE1753Co1ZXY/e1ZYXnD17NlBSExIgsH+AQCAgbOsUAUaRqfGJxjJIQgysUnMyMm8coJPNs7+ybpsgEToOXb8zwAAKUvWJQDcdP8YBAOD/f1XnCnQwOsWEjNWLRk85pHwHAhsuY+tYFb2auWnJ44fEwxeBJCwIJPlO5iUqZwNgwAAqRByp8YnBMdx0bYBiR3Ky8vffXdHtK1AECQ0ysv3Lly4MD09PTMzMz09PT4+fvLkydE2Sh4wXYkgCILELOjkEARBkJgFnRyCIAgSs2DhCSIz5eV7o20CgiCIABaeICPIwMDA5cuXGYa5fPnyzZs3h4aGom0RgiC+SUxMfPjhh0mSfPjhh+Pj4ydNipE8H0ZyyAgSFxc3bdq0GTNmAMCdO3fwjgpBxixTp06dMWPGtGnTYqaukgcjOWQEuXv37u3bt/v7+2/dunXv3j082RBkzPLAAw9MmzYtKSlp6tSpcXFxBEFE2yJ5QCeHjCBDQ0P379+/e/fu/fv38UxDkLEMQRBxcXFxcXGTJ08mCAKdHIIEhj+7pP8jCDI24b2a9P/YAJ0cgiAIErPESP0MgiAIgniDTg5BEASJWdDJIQiCIDELOjkEQRAkZkEnhyAIgsQs6OQQBEGQmAWdHIIgCBKz/A8dky15IMzafQAAAABJRU5ErkJggg==" alt="image"><br>出现上述报错的主要原因是：  </p><blockquote><p>Java中默认整数为int类型，虽然图片中的数字未超过long类型的最大值，但由于默认整数为int类型，该数超过了int类型的最大值，所以报错；  </p></blockquote><h4 id="解决方法如下："><a href="#解决方法如下：" class="headerlink" title="解决方法如下："></a>解决方法如下：</h4><blockquote><p>在声明时，在数字的后面添加<font color="red">l</font>或者<font color="red">L</font>即可，建议添加<font color="red">L</font>，更容易区别</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 踩坑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>unix时间戳转时间</title>
      <link href="/post/3b7df5c1.html"/>
      <url>/post/3b7df5c1.html</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String unixTimeStr=  <span class="string">&quot;1572251400&quot;</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">s</span> <span class="operator">=</span> Long.parseLong(unixTimeStr);</span><br><span class="line">s *= <span class="number">1000</span>; <span class="comment">// 乘以1000，变成毫秒</span></span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> t.format(<span class="keyword">new</span> <span class="title class_">Date</span>(s));</span><br><span class="line">System.out.println(date); <span class="comment">//2019-10-28 16:30:00</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 时间戳 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS中this的指向</title>
      <link href="/post/b0088be2.html"/>
      <url>/post/b0088be2.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>JS中this的指向</p></blockquote><pre><code> 1. 以函数形式调用时，this是window 2. 以方法形式调用时，this是调用方法的对象 3. 以构造函数形式调用时，this是新建的那个对象 4. 使用call()和apply()调用时，this是指定的那个对象</code></pre><p>在调用函数时，浏览器每次都会传递两个隐含的参数<br>    1. 函数的上下文对象this<br>    2. 封装实参的对象arguments<br>        – arguments是一个类数组对象(不是数组)，它可以用过索引来操作数据，也可以获取长度<br>        – 在调用函数时，我们所传递的实参都会保存在arguments中<br>        – 即使在函数中不定义形参，也可以通过arguments来进行操作，只是相对而言麻烦一些</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String类的常用方法</title>
      <link href="/post/1e0a855.html"/>
      <url>/post/1e0a855.html</url>
      
        <content type="html"><![CDATA[<h3 id="String类的常用方法"><a href="#String类的常用方法" class="headerlink" title="String类的常用方法"></a>String类的常用方法</h3><blockquote><p><strong>split(“reg”)</strong><br>将字符串以reg为分隔符进行分割，返回一个String类型的数组    </p></blockquote><blockquote><p><strong>replace(char oldChar, char newChar)</strong><br>替换字符串中的字符，返回一个新的String类型的变量  </p></blockquote><blockquote><p><strong>replaceAll(String regex,String replacement)</strong><br>基于正则表达式的替换,比如，可以通过<code>replaceAll("\d", "*")</code>把一个字符串所有的数字字符都换成星号;如果参数不是基于正则表达式的，那么效果和replace()相同</p></blockquote><blockquote><p><strong>replaceFirst(String regex,String replacement)</strong><br>基于正则表达式的替换,只替换第一次出现的</p></blockquote><blockquote><p><strong>trim()</strong><br>去除字符串首尾的空格，返回一个新的String类型的变量  </p></blockquote><blockquote><p><strong>equals()</strong><br>比较两个String类型变量的内容是否相同，区分大小写  </p></blockquote><blockquote><p><strong>equalsIgnoreCase()</strong><br>和equals()方法的作用相同，只是忽略大小写  </p></blockquote><blockquote><p><strong>substring(fromTndex,toIndex)</strong><br>字符串截取，包含包含起始位置，不包含结束位置<br>如果只有起始位置，没有结束位置，就返回从起始位置到字符串的末尾  </p></blockquote><blockquote><p><strong>charAt(int index)</strong><br>返回字符串中指定位置的字符，Char类型   </p></blockquote><blockquote><p><strong>boolean statWith(String prefix)</strong><br>判断字符串是是否是以prefix为开始，是返回true，否返回false  </p></blockquote><blockquote><p><strong>boolean endWith(String suffix)</strong><br>判断字符串是是否是以suffix为结束，是返回true，否返回false  </p></blockquote><blockquote><p><strong>String toLowerCase()</strong><br>返回将当前字符串中所有字符转换成小写后的新串</p></blockquote><blockquote><p><strong>String toUpperCase()</strong><br>返回将当前字符串中所有字符转换成大写后的新串  </p></blockquote><blockquote><p><strong>contains(String str)</strong><br>判断参数s是否被包含在字符串中，是返回true，否返回false  </p></blockquote><blockquote><p><strong>int indexOf(int ch/String str)</strong><br>用于查找当前字符串中字符或子串，返回字符或子串在当前字符串中从左边起首次出现的位置，若没有出现则返回-1</p></blockquote><blockquote><p><strong>indexOf(int ch/String str, int fromIndex)</strong><br>从fromIndex位置向后查找  </p></blockquote><blockquote><p><strong>lastIndexOf(int ch/String str)</strong><br>从字符串的末尾位置向前查找  </p></blockquote><h3 id="字符串与基本类型的转换"><a href="#字符串与基本类型的转换" class="headerlink" title="字符串与基本类型的转换"></a>字符串与基本类型的转换</h3><pre>int n = Integer.parseInt("12");  float f = Float.parseFloat("12.34");  double d = Double.parseDouble("1.124");</pre>  <pre>String a = String.valueOf(12);String b = String.valueOf(13.14);</pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux环境工作常用命令</title>
      <link href="/post/5b3efa13.html"/>
      <url>/post/5b3efa13.html</url>
      
        <content type="html"><![CDATA[<h3 id="Linux环境工作常用命令"><a href="#Linux环境工作常用命令" class="headerlink" title="Linux环境工作常用命令"></a>Linux环境工作常用命令</h3><code>  cd /  进入根目录  mkdir dirName  创建文件夹    touch fileName  创建一个空文件vi/vim fileName 编辑一个文件，如果文件不存在，则会新建该文件  mv fileName/dirName 剪切/修改 文件或者文件夹的名称  cp -r sourceDirPath targetDirPath  复制文件夹，会将子文件夹一并复制  tail -numf fileName  查看文件末尾num行，可以动态刷新文件，用于查看日志  && 命令连接符 可以多条命令连接起来，从左到右执行ps -ef|grep processName  查看某个进程的状态kill -9 processId 根据进程ID杀进程  rm -rf fileName/dirName/dirPath 强制删除某个文件或者文件夹下所有内容，请慎用。如果不要强制，则去掉f  ssh userName@HostIP  ssh远程连接  ls -l | grep "^-" | wc -l 查看文件夹下文件个数（不包括子文件夹）  scp -r  local_file remote_username@remote_ip:remote_folder  从本地复制到远程（从远程复制到本地，只需要将两个参数的位置调换一下）  解压命令  tar -xvf file.tar //解压 tar包  tar -xzvf file.tar.gz //解压tar.gz  tar -xjvf file.tar.bz2   //解压 tar.bz2  tar -xZvf file.tar.Z   //解压tar.Z  unrar e file.rar //解压rar  unzip file.zip //解压zip</code>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程和线程</title>
      <link href="/post/6ac22eb.html"/>
      <url>/post/6ac22eb.html</url>
      
        <content type="html"><![CDATA[<p>记录：  </p><h2 id="多任务操作系统的实现方式"><a href="#多任务操作系统的实现方式" class="headerlink" title="多任务操作系统的实现方式"></a>多任务操作系统的实现方式</h2><blockquote><p>单核cpu  </p><p>  操作系统让cpu轮流交替执行任务，因为cpu的执行效率远高于计算机内的其他组件，所以让人感觉有多个任务在同时进行，实际上确定的时间点上，cpu只执行某一个任务。    </p><p>多核cpu  </p><p> 多个核心的cpu可在真正意义上实现多任务执行。但由于任务数量会超过cpu的核心数，所以操作系统也会自动把很多任务轮流调度到每个核心上执行。 </p></blockquote><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><p>进程：  </p><blockquote><p> 对于操作系统来说，一个任务就是一个进程（Process），比如打开一个浏览器就是启动一个浏览器进程，打开一个记事本就启动了一个记事本进程，打开两个记事本就启动了两个记事本进程，打开一个Word就启动了一个Word进程。  </p></blockquote><p>线程：</p><blockquote><p>有些进程还不止同时干一件事，比如Word，它可以同时进行打字、拼写检查、打印等事情。在一个进程内部，要同时干多件事，就需要同时运行多个“子任务”，我们把进程内的这些“子任务”称为线程（Thread）</p></blockquote><p>小结</p><blockquote><p>线程是最小的执行单元，而进程由至少一个线程组成。如何调度进程和线程，完全由操作系统决定，程序自己不能决定什么时候执行，执行多长时间  </p><p>进程和线程都是一个时间段的描述，是CPU工作时间段的描述<br>CPU+RAM+各种资源（比如显卡，光驱，键盘，GPS, 等等外设）构成我们的电脑，但是电脑的运行，实际就是CPU和相关寄存器以及RAM之间的事情。<br>一个最最基础的事实：CPU太快，太快，太快了，寄存器仅仅能够追的上他的脚步，RAM和别的挂在各总线上的设备完全是难以望其项背。那当多个任务要执行的时候怎么办呢？轮流着来?或者谁优先级高谁来？不管怎么样的策略，一句话就是在CPU看来就是轮流着来。</p></blockquote><blockquote><p>一个必须知道的事实：执行一段程序代码，实现一个功能的过程介绍 ，当得到CPU的时候，相关的资源必须也已经就位，就是显卡啊，GPS啊什么的必须就位，然后CPU开始执行。这里除了CPU以外所有的就构成了这个程序的执行环境，也就是我们所定义的程序上下文。当这个程序执行完了，或者分配给他的CPU执行时间用完了，那它就要被切换出去，等待下一次CPU的临幸。在被切换出去的最后一步工作就是保存程序上下文，因为这个是下次他被CPU临幸的运行环境，必须保存。</p></blockquote><blockquote><p>串联起来的事实：前面讲过在CPU看来所有的任务都是一个一个的轮流执行的，具体的轮流方法就是：先加载程序A的上下文，然后开始执行A，保存程序A的上下文，调入下一个要执行的程序B的程序上下文，然后开始执行B,保存程序B的上下文。。。。</p></blockquote><blockquote><p>========= 重要的东西出现了========  </p></blockquote><p>进程和线程就是这样的背景出来的，两个名词不过是对应的CPU时间段的描述，名词就是这样的功能。<br>进程就是包换上下文切换的程序执行时间总和 = CPU加载上下文+CPU执行+CPU保存上下文<br>线程是什么呢？<br>进程的颗粒度太大，每次都要有上下的调入，保存，调出。如果我们把进程比喻为一个运行在电脑上的软件，那么一个软件的执行不可能是一条逻辑执行的，必定有多个分支和多个程序段，就好比要实现程序A，实际分成 a，b，c等多个块组合而成。那么这里具体的执行就可能变成：</p><blockquote><p>程序A得到CPU =》CPU加载上下文，开始执行程序A的a小段，然后执行A的b小段，然后再执行A的c小段，最后CPU保存A的上下文。</p></blockquote><blockquote><p>这里a，b，c的执行是共享了A的上下文，CPU在执行的时候没有进行上下文切换的。这里的a，b，c就是线程，也就是说线程是共享了进程的上下文环境，的更为细小的CPU时间段。</p></blockquote><blockquote><p>到此全文结束，再一个总结：</p></blockquote><blockquote><p>进程和线程都是一个时间段的描述，是CPU工作时间段的描述，不过是颗粒大小不同。</p></blockquote><blockquote><p>进程是资源分配的最小单位，线程是CPU调度的最小单位</p></blockquote><h3 id="Java中的参数传值方式—-值传递"><a href="#Java中的参数传值方式—-值传递" class="headerlink" title="Java中的参数传值方式—-值传递"></a>Java中的参数传值方式—-值传递</h3><blockquote><p>Java中传递参数时：      </p><p>基本类型：复制一份该参数的实际值，传递<br>引用类型：复制一份该引用类型的引用的值，传递</p></blockquote><h3 id="Java中的四种引用"><a href="#Java中的四种引用" class="headerlink" title="Java中的四种引用"></a>Java中的四种引用</h3><blockquote><p>强引用  </p><p>指创建一个对象并把这个对象赋给一个引用变量比如 Object object = new Object();String a = “test”;<br>这样生成的对象一直到该方法执行结束之后才会回收，否则永远都不会回收  </p></blockquote><blockquote><p>软引用  </p></blockquote><pre name="code" class="java">if(i > 0){    System.out.println("it is a test for markdown");}</pre>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中到底是值传递还是引用传递</title>
      <link href="/post/4338db12.html"/>
      <url>/post/4338db12.html</url>
      
        <content type="html"><![CDATA[<h2 id="Java中到底是值传递还是引用传递？"><a href="#Java中到底是值传递还是引用传递？" class="headerlink" title="Java中到底是值传递还是引用传递？"></a>Java中到底是值传递还是引用传递？</h2><p>我们先回顾一下基本概念</p><h3 id="实参和形参"><a href="#实参和形参" class="headerlink" title="实参和形参"></a>实参和形参</h3><p>参数在编程语言中是执行程序需要的数据，这个数据一般保存在变量中。在Java中定义一个方法时，可以定义一些参数，<br>举个例子：    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">myName</span> <span class="operator">=</span> <span class="string">&quot;hawk&quot;</span>;</span><br><span class="line">sayYourName(myName);<span class="comment">// 实际参数是myName</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sayYourName</span><span class="params">(String name)</span> &#123;<span class="comment">// 形式参数是name</span></span><br><span class="line">System.out.println(name);</span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中定义一个名为sayYourName的方法，如果想要执行这个方法，那么你需要传入一个String类型的变量给这个方法，定义这个方法时声明的String类型的name就是形式参数，而在这个方法执行时传入的myName就是实际参数。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><blockquote><p>实际参数是调用有参方法的时候真正传递的内容，而形式参数是用于接收实参内容的参数。  </p></blockquote><h3 id="传参的几种方式"><a href="#传参的几种方式" class="headerlink" title="传参的几种方式"></a>传参的几种方式</h3><p> 按值传递(call by value)  </p><blockquote><p>按值传递，就是指在调用函数时，将实参对应的值做一个拷贝指向函数对应的形参。在函数内改变形参对应的值并不会影响外部实参的值  </p></blockquote><p> 按引用传递 (call by reference)</p><blockquote><p>按引用传递，是指在调用函数时，传递给函数的是实参的地址即引用，而不是实参的拷贝。在函数内部参数的值，对外部的实参是可见的。  </p></blockquote><p>按共享传递 （call by sharing）  </p><blockquote><p>按共享传递，是指在调用函数时，传递给函数的是实参的地址的拷贝（如果实参在栈中，则直接拷贝该值）。在函数内部对参数进行操作时，需要先拷贝的地址寻找到具体的值，再进行操作。如果该值在栈中，那么因为是直接拷贝的值，所以函数内部对参数进行操作不会对外部变量产生影响。如果原来拷贝的是原值在堆中的地址，那么需要先根据该地址找到堆中对应的位置，再进行操作。因为传递的是地址的拷贝所以函数内对值的操作对外部变量是可见的。  </p></blockquote><blockquote><p>按共享传递可以理解为<strong>按值传递</strong>的一个特例，这里的值是对象的引用地址，而不是具体对象。  </p></blockquote><p>上面描述的传参方式实际上是函数调用时参数的求值策略(Evaluation Strategy)，这个其实比较好理解，比如我们调用上面的sayYourName()方法<br>我们可以这样：sayYourName(“hawk”);<br>可以这样:sayYourName(“ha”+”wk”);<br>可以这样：sayYourName(“hawk”+x.subString(2));// 此处的x是一个变量,进行截取后和”hawk”合并    </p><p>但是所有这些实参的形式，都统称为表达式(Expression)。求值（Evaluation）即是指对这些表达式的简化并求解其值的过程。</p><p>求值策略(值传递和引用传递)的关注的点在于，这些表达式在调用函数的过程中，求值的时机、值的形式的选取等问题。求值的时机，可以是在函数调用前，也可以是在函数调用后，由被调用者自己求值。这里所谓调用后求值，可以理解为Lazy Load或On Demand的一种求值方式。<br>而且，除了按值传递和按引用传递，还有一些其它的求值策略。这些求值策略的划分依据是：求值的时机（调用前还是调用中）和值本身的传递方式。详见下表：  </p><table><tr>    <td>求值策略</td>    <td>求值时间</td>    <td>传值方式</td></tr><tr>    <td>按值传递( pass by value )</td>    <td>调用前</td>    <td>值的结果(只是结果的副本)</td></tr><tr>    <td>按引用传递( pass by reference )</td>    <td>调用前</td>    <td>原值(原始对象，无副本)</td></tr><tr>    <td>按名传递( pass by name )</td>    <td>调用后(用到才求值)</td>    <td>与值无关的一个名</td></tr></table>  <p><strong>按值传递和按引用传递在行为表现上的差异如下：</strong>  </p><table><tr>    <td></td>    <td>按值传递</td>    <td>按引用传递</td></tr><tr>    <td>本质区别</td>    <td>创建副本</td>    <td>不创建副本</td></tr><tr>    <td>表现结果</td>    <td>函数中无法改变原始对象</td>    <td>函数中可以改变原始对象</td></tr></table>**这里面的改变，是指把一个变量指向另一个对象，而不是指仅仅改变属性或者成员什么的**  <p>只要是按值传递，不管传递的参数类型是值类型还是引用类型，都会在调用栈上面创建一个实参的副本，区别只是如果传递的参数类型是值类型，该副本就是实际参数的值的复制，而对于引用类型来说，引用类型的实例(即对象)是保存在堆中的，在栈上只有一个该实例的引用（一般情况下是该实例在堆中的内存地址），此时，实际参数的副本并不是该对象，而是引用的副本。</p><p><strong>所以，综上所述，对于Java的函数调用方式最准确的描述是：参数藉由值传递方式，传递的值是个引用。（句中两个“值”不是一个意思，第一个值是evaluation result，第二个值是value content）</strong></p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>说到Java是值传递还是引用传递，一般都会举下面三个例子，我们来一一说明一下：<br>第一个例子，基本类型参数传值：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">changeValue(i);</span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">changeValue</span><span class="params">(<span class="type">int</span> a )</span> &#123;</span><br><span class="line">a = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>上面的代码解释如下：<br>定义了一个int类型的变量i，并赋值为10<br>调用changeValue方法，传入i，changeValue方法将传入的变量赋值为20<br>输出i  </p><p>结果是：<strong>10</strong><br>changValue方法内部对<strong>形参a</strong>的修改并没有影响到<strong>实参i</strong><br><strong>第一个结论：Java中基本类型的传值方式是按值传递</strong>  </p><p>第二个例子，引用类型传值：    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">i</span> <span class="operator">=</span> <span class="string">&quot;hawk&quot;</span>;</span><br><span class="line">changString(i);</span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">changString</span><span class="params">(String a )</span> &#123;</span><br><span class="line">a = <span class="string">&quot;HAWK&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>上面的代码解释如下：<br>定义一个String类型的变量i，赋值为”hawk”<br>调用changeString方法，将传入的变量赋值为”HAWK”<br>输出i  </p><p>结果： <strong>hawk</strong><br>在Java中String类型虽然可以直接赋值，但是是引用类型，<strong>因为String类型的具体值保存在堆中，而不是栈上</strong><br>既然String是引用类型， 上面的例子又说明String是值传递的  那么我们是不是就可以得出：<br><strong>Java中引用类型也是值传递的</strong>，这样的结论呢？  </p><p>我们来看第三个例子：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Example</span> <span class="variable">ex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Example</span>();</span><br><span class="line">changValue(ex);</span><br><span class="line">System.out.println(ex.i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">changValue</span><span class="params">(Example e )</span> &#123;</span><br><span class="line">e.i = <span class="number">30</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>上面的代码解释如下：<br>实例化一个Example对象ex，ex中只有一个属性i，初始值为20<br>调用changValue方法，将ex中的属性i的值赋值为30<br>输出ex中属性i的值  </p><p>结果是：<strong>30</strong><br>这样的结果就让很多人产生了困惑，String类型是引用类型，对象也是引用类型，为什么第二个例子不能改变i的值，第三个例子却改变了ex中i的值呢？<strong>Java中引用类型的参数传递到底是引用传递还是值传递呢？</strong>  </p><p>其实，第二个例子和第三个例子我们所关注的点已经是错误的了，自然无法得出正确的结论<br>我们回顾一下<strong>引用传递和值传递的本质区别和行为表现上的区别</strong> </p><table><tr>    <td></td>    <td>按值传递</td>    <td>按引用传递</td></tr><tr>    <td>本质区别</td>    <td>创建副本</td>    <td>不创建副本</td></tr><tr>    <td>表现结果</td>    <td>函数中<b>无法改变原始对象</b></td>    <td>函数中<b>可以改变原始对象</b></td></tr></table>注意到了吗？我们应该关注的是**原始对象的变化**  > **Java中，引用类型的原始对象（即原始值）是保存在堆中的，变量中存储的是原始值的引用（Java中存储的是该对象在堆中的内存地址），**> **该引用指向堆中的对象,所以我们<font color="red">关注的关键点应该是对象的引用有没有发生变化</font>，而不是原始对象中的内容有没有发生变化**<p><strong><font color="red">重要依据：</font>如果可以改变对象的引用，就说明是引用传递，如果不能改变对象的引用就说明是值传递</strong><br>下面我们多举一个例子： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Example</span> <span class="variable">ex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Example</span>();</span><br><span class="line">changValue(ex);</span><br><span class="line">System.out.println(ex.i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">changValue</span><span class="params">(Example e )</span> &#123;</span><br><span class="line">e = <span class="keyword">new</span> <span class="title class_">Example</span>();</span><br><span class="line">e.i = <span class="number">50</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>这个例子和上面第三个例子很相似，区别在于：<br>changValue方法中将一个新的原始对象的引用赋值给了形参e<br><strong>如果Java是按引用传递的话，e = new Example();就是修改了实参ex的引用，即就是改变了原始对象<br>如果Java是按值传递的话，实参ex不会有任何变化</strong>  </p><p>结果：<strong>20</strong>  </p><p>这个结果说明：<strong>changValue方法并没有修改到ex的引用，也就是说，e只是ex的副本，对e的引用进行的所有操作都不会影响到ex，所以我们<br>从上述代码运行的结果也可以证明Java中是只有值传递的</strong></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.hollischuang.com/archives/2275" target="_blank">为什么说Java中只有值传递</a><br><a href="http://menzhongxin.com/2017/02/07/%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92-%E6%8C%89%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E5%92%8C%E6%8C%89%E5%85%B1%E4%BA%AB%E4%BC%A0%E9%80%92/" target="_blank">按值传递、按引用传递、按共享传递</a><br><a href="https://www.zhihu.com/question/20628016/answer/28970414" target="_blank">为什么 Java 只有值传递，但 C# 既有值传递，又有引用传递，这种语言设计有哪些好处？</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
